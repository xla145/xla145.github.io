{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[],"Cache":[{"_id":"source/_posts/Java-集合.md","hash":"42f137571567e64002772f9af7db4906099aecaf","modified":1563079044657},{"_id":"source/_posts/JAVA-8的新特性-1.md","hash":"48e3520e8266fed96fafccbd657d5158d4e59501","modified":1563073886952},{"_id":"source/_posts/Java-动态代理为啥需要接口？？？.md","hash":"26b3aa590840c32a31a87f065f61b9c11adad04c","modified":1563073886954},{"_id":"source/_posts/JAVA-笔记.md","hash":"14cf1f0e368cd70928e7ef8f701adc84669ea72c","modified":1563073886953},{"_id":"source/_posts/Linux下项目自动部署脚本.md","hash":"588756e82b1aac79bd04077e442903195e8425b6","modified":1563073886954},{"_id":"source/_posts/ModelAttribute-对象没有无参的构造函数出错详解-1.md","hash":"77c746be4c3d39887a0031a05f69ec6311e308ba","modified":1563077804469},{"_id":"source/_posts/cookie-和-session-的区别.md","hash":"39109b579b2e037d55edcfe21715718749799dbb","modified":1563073886957},{"_id":"source/_posts/dubbo-学习笔记（一）.md","hash":"446bd85ce9c50dfdcd5cae9c05349fae42caafbc","modified":1563077804408},{"_id":"source/_posts/get-请求中文乱码问题.md","hash":"6c23a5039e06b93fdfb149d6c33e8f25deee5c4f","modified":1563073886961},{"_id":"source/_posts/gitLab-搭建.md","hash":"ea3766e536fcbe786f9d88a1841e1815437c873b","modified":1563073886961},{"_id":"source/_posts/markdown的使用笔记.md","hash":"67d34313149b5d3d0ea59e9adc8e9322b7cc3f67","modified":1563080975732},{"_id":"source/_posts/js实现粘贴板功能.md","hash":"c3443bcfe20a5feaf52453b8924d9226e87246fa","modified":1563073886962},{"_id":"source/_posts/java-反射笔记.md","hash":"780f5d2877b600836135db314df46ba82732408a","modified":1563073886962},{"_id":"source/_posts/shiro-笔记（一）.md","hash":"c48b715ea69e9a3932bc72a7dedde5531d40e863","modified":1563073886977},{"_id":"source/_posts/mybatis-学习.md","hash":"91b5a93e09f5773d7d40a174dcca2df0c3780394","modified":1563075435749},{"_id":"source/_posts/spring-boot-如何创建和使用freemaker自定义标签.md","hash":"57b906265bc3f0e3a0bbe22dbca62656a194c51c","modified":1563073886977},{"_id":"source/_posts/spring boot 学习笔记.md","hash":"86dcff09cae7e467db6e49d8257906c894719cec","modified":1563073886977},{"_id":"source/_posts/spring-mvc-RequestBody-和-RequestParam-比较.md","hash":"d498482624c039bab265d38f1d9b2f0b434bb2d9","modified":1563073886978},{"_id":"source/_posts/了解Java中的代理.md","hash":"f0213b6eb034d795b7ec56e78a30298c623e33a3","modified":1563073886978},{"_id":"source/_posts/spring-bean的作用域.md","hash":"038bd9d2aabf2a10847d3f7763652f5f0f2f073c","modified":1563079044705},{"_id":"source/_posts/关于executeUpdate方法返回的值问题.md","hash":"47228cb19c4cbab667ce24e7858ab62c3cf2c82e","modified":1563073886979},{"_id":"source/_posts/关于Volatile的那点事.md","hash":"fb301e6644d2f30bf5d6ee6a2f911e1960451c38","modified":1563078498393},{"_id":"source/_posts/双通道存储器技术.md","hash":"8855336bc4e7334c249fc766c9a53a6d50691a0d","modified":1563073886979},{"_id":"source/_posts/jvm-面试问题总结-一.md","hash":"b35912c535185bc3f4d999eb7ddf3750746405e8","modified":1563077804345},{"_id":"source/_posts/使用iframe遇到的问题.md","hash":"18f425b57891bcb4c6c43cd332fceaad92a23df6","modified":1563078856891},{"_id":"source/_posts/烈火军校.md","hash":"fbeb5b8e414a4d11ae92c4376ebec035ea9b48ee","modified":1586061984985},{"_id":"source/_posts/理解-linux-cpu-负载.md","hash":"31f1a3fee9c58c22a1eca8a3c5eeb2c780a3c740","modified":1563077804438},{"_id":"source/404/index.html","hash":"75f79c7a9f1072300986dc8b56e6cca36b2b7646","modified":1585987443424},{"_id":"source/about/index.md","hash":"4eced9ed1b425e5060050d28819318140e177862","modified":1585980240423},{"_id":"source/archives/index.md","hash":"03861cccba634479b0937738be068e1d5551c044","modified":1563073886982},{"_id":"source/tags/index.md","hash":"0ef4b65393ece6745631b6d1caa65bea1bb9450f","modified":1563073886982},{"_id":"source/_posts/如何使用flatMap.md","hash":"a275df77b1610360e730204b50d986b993a23318","modified":1563079044748},{"_id":"source/_posts/工具网站.md","hash":"121b6060fc2aeb281bfdfd1a4d2dd23c8de51cbb","modified":1578987863868},{"_id":"source/_posts/mysql-Linux下离线安装mysql.md","hash":"cdd8b708c710964f39a10f19b513a9e9a6f43675","modified":1585993083816},{"_id":"public/404/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988179},{"_id":"public/about/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988179},{"_id":"public/archives/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988179},{"_id":"public/tags/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988179},{"_id":"public/2020/04/05/烈火军校/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988179},{"_id":"public/2019/12/05/mysql-Linux下离线安装mysql/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988179},{"_id":"public/2019/03/22/mybatis-学习/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988179},{"_id":"public/2019/03/21/dubbo-学习笔记（一）/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988179},{"_id":"public/2019/03/15/使用iframe遇到的问题/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988179},{"_id":"public/2019/03/15/Java-集合/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988179},{"_id":"public/2019/03/15/理解-linux-cpu-负载/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988179},{"_id":"public/2019/03/15/关于Volatile的那点事/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988179},{"_id":"public/2019/03/15/如何使用flatMap/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988179},{"_id":"public/2019/03/15/工具网站/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988179},{"_id":"public/2019/03/15/spring-bean的作用域/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988180},{"_id":"public/2019/03/15/关于executeUpdate方法返回的值问题/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988180},{"_id":"public/2019/03/15/jvm-面试问题总结-一/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988180},{"_id":"public/2019/03/15/了解Java中的代理/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988181},{"_id":"public/2019/03/15/Java-动态代理为啥需要接口？？？/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988181},{"_id":"public/2019/03/15/shiro-笔记（一）/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988181},{"_id":"public/2019/02/26/markdown的使用笔记/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988181},{"_id":"public/2019/02/26/双通道存储器技术/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988181},{"_id":"public/2019/02/26/cookie-和-session-的区别/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988181},{"_id":"public/2019/02/22/JAVA-8的新特性-1/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988181},{"_id":"public/2019/02/22/gitLab-搭建/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988181},{"_id":"public/2019/02/22/js实现粘贴板功能/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988181},{"_id":"public/2019/02/22/get-请求中文乱码问题/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988181},{"_id":"public/2019/02/20/java-反射笔记/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988181},{"_id":"public/2019/02/19/JAVA-笔记/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988181},{"_id":"public/2019/02/19/spring-boot-如何创建和使用freemaker自定义标签/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988181},{"_id":"public/2019/02/19/spring-mvc-RequestBody-和-RequestParam-比较/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988181},{"_id":"public/2019/02/18/ModelAttribute-对象没有无参的构造函数出错详解-1/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988181},{"_id":"public/2019/02/18/Linux下项目自动部署脚本/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988181},{"_id":"public/2019/02/18/spring boot 学习笔记/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988181},{"_id":"public/archives/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988181},{"_id":"public/archives/page/3/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988181},{"_id":"public/archives/2019/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988182},{"_id":"public/archives/2019/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988182},{"_id":"public/archives/2019/page/3/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988182},{"_id":"public/archives/2019/02/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988182},{"_id":"public/archives/2019/02/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988182},{"_id":"public/archives/2019/03/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988182},{"_id":"public/archives/2019/03/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988182},{"_id":"public/archives/2019/12/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988182},{"_id":"public/archives/2020/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988182},{"_id":"public/archives/2020/04/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988182},{"_id":"public/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988182},{"_id":"public/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988182},{"_id":"public/page/3/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988182},{"_id":"public/tags/JAVA/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988182},{"_id":"public/tags/java/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988182},{"_id":"public/tags/动态代理/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988182},{"_id":"public/tags/Lambda-表达式/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988182},{"_id":"public/tags/http/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988183},{"_id":"public/tags/网络安全/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988183},{"_id":"public/tags/dubbo/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988184},{"_id":"public/tags/markdown/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988185},{"_id":"public/tags/springMvc/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988185},{"_id":"public/tags/字符编码/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988185},{"_id":"public/tags/JavaScript/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988185},{"_id":"public/tags/浏览器兼容性/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988185},{"_id":"public/tags/反射机制/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988185},{"_id":"public/tags/github/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988185},{"_id":"public/tags/linux/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988185},{"_id":"public/tags/CentOS/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988186},{"_id":"public/tags/mybatis/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988186},{"_id":"public/tags/spring/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988186},{"_id":"public/tags/多线程/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988186},{"_id":"public/tags/并发/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988186},{"_id":"public/tags/HTML/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988186},{"_id":"public/tags/JVM/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988186},{"_id":"public/tags/硬件/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988186},{"_id":"public/tags/内存/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988186},{"_id":"public/tags/JAVA-8/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988186},{"_id":"public/tags/工具/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988186},{"_id":"public/tags/mysql/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586061988186}],"Category":[],"Data":[],"Page":[{"_content":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/>\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n  <meta name=\"robots\" content=\"all\" />\n  <meta name=\"robots\" content=\"index,follow\"/>\n</head>\n<body>\n\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homePageUrl=\"your site url \" homePageName=\"回到我的主页\"></script>\n\n</body>\n</html>\n","source":"404/index.html","raw":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/>\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n  <meta name=\"robots\" content=\"all\" />\n  <meta name=\"robots\" content=\"index,follow\"/>\n</head>\n<body>\n\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homePageUrl=\"your site url \" homePageName=\"回到我的主页\"></script>\n\n</body>\n</html>\n","date":"2020-04-04T08:04:03.485Z","updated":"2020-04-04T08:04:03.424Z","path":"404/index.html","title":"","comments":1,"layout":"page","_id":"ck8mkcttu00014osx6pkmc5oz","content":"<!DOCTYPE HTML>\n<html>\n<head><meta name=\"generator\" content=\"Hexo 3.8.0\">\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n  <meta name=\"robots\" content=\"all\">\n  <meta name=\"robots\" content=\"index,follow\">\n</head>\n<body>\n\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homepageurl=\"your site url \" homepagename=\"回到我的主页\"></script>\n\n</body>\n</html>\n","site":{"data":{}},"excerpt":"","more":"<!DOCTYPE HTML>\n<html>\n<head><meta name=\"generator\" content=\"Hexo 3.8.0\">\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n  <meta name=\"robots\" content=\"all\">\n  <meta name=\"robots\" content=\"index,follow\">\n</head>\n<body>\n\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homepageurl=\"your site url \" homepagename=\"回到我的主页\"></script>\n\n</body>\n</html>\n"},{"title":"关于我","date":"2020-04-04T05:46:05.000Z","_content":"\n>  **low 皮的程序猿**\n\n喜欢瞎捣鼓\n\n喜欢打球，看球赛\n\n\n平时搞一些小工具，小网站 ：戳我 👉 [开源作品](https://github.com/xla145/)\n","source":"about/index.md","raw":"---\ntitle: 关于我\ndate: 2020-04-04 13:46:05\n---\n\n>  **low 皮的程序猿**\n\n喜欢瞎捣鼓\n\n喜欢打球，看球赛\n\n\n平时搞一些小工具，小网站 ：戳我 👉 [开源作品](https://github.com/xla145/)\n","updated":"2020-04-04T06:04:00.423Z","path":"about/index.html","comments":1,"layout":"page","_id":"ck8mkctvf002f4osxvajlztcb","content":"<blockquote>\n<p> <strong>low 皮的程序猿</strong></p>\n</blockquote>\n<p>喜欢瞎捣鼓</p>\n<p>喜欢打球，看球赛</p>\n<p>平时搞一些小工具，小网站 ：戳我 👉 <a href=\"https://github.com/xla145/\" target=\"_blank\" rel=\"noopener\">开源作品</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p> <strong>low 皮的程序猿</strong></p>\n</blockquote>\n<p>喜欢瞎捣鼓</p>\n<p>喜欢打球，看球赛</p>\n<p>平时搞一些小工具，小网站 ：戳我 👉 <a href=\"https://github.com/xla145/\" target=\"_blank\" rel=\"noopener\">开源作品</a></p>\n"},{"title":"archives","date":"2019-02-21T09:42:27.000Z","layout":"archives","_content":"","source":"archives/index.md","raw":"---\ntitle: archives\ndate: 2019-02-21 17:42:27\nlayout: archives\n---\n","updated":"2019-07-14T03:11:26.982Z","path":"archives/index.html","comments":1,"_id":"ck8mkctvh002g4osxsaeqns2k","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2019-02-21T09:35:46.000Z","layout":"tags","type":"tags","tags":["JAVA","反射机制"],"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2019-02-21 17:35:46\nlayout: tags\ntype: \"tags\"\ntags:\n- JAVA\n- 反射机制\n---\n","updated":"2019-07-14T03:11:26.982Z","path":"tags/index.html","comments":1,"_id":"ck8mkctvi002h4osxfuh3g22s","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Java 集合","date":"2019-03-15T01:56:13.000Z","_content":"\n# 1.\t什么叫数据结构？\n在计算机科学中，数据结构（英语：data structure）是计算机中存储、组织数据的方式。数据结构意味着接口或封装：一个数据结构可被视为两个函数之间的接口，或者是由数据类型联合组成的存储内容的访问方法封装。\n# 2. 结构有哪些？\n常见的数据结构主要有8种，引用百度百科的图：\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190228100803325.png)\n# 3.\t一些数据结构在Java中的具体体现？\n1.\tList 接口\nList 具体实现类有ArrayList, LinkedList, Vector，下面我们来介绍一下它们的原理，区别和使用方式\n* ArrayList\nArrayList 实现于 List、RandomAccess 接口。可以插入空数据，也支持随机访问。内部实现采用动态数组，当容量不够时，自动扩容至（当前容量1.5倍）。元素的顺序按照插入的顺序排列。默认初始容量为10。随机访问效率高，随机插入、删除效率低。主要的属性是elementData 数组，以及 size 大小。在执行添加add（）方法时\n```\n\tpublic boolean add(E e) {\n\t    ensureCapacityInternal(size + 1);  // Increments modCount!!\n\t    elementData[size++] = e;\n\t    return true;\n\t}\n```\n 主要是做扩容判断，然后再将数据插入到数组中。Add（int index，E data）方法是在特定的位置，插入特定的元素。Index 不大于数组的大小，这种方式添加\n ```\n\tpublic void add(int index, E element) {\n\t    rangeCheckForAdd(index);\n\t    ensureCapacityInternal(size + 1);  // Increments modCount!!\n\t    System.arraycopy(elementData, index, elementData, index + 1,\n\t                     size - index);\n\t    elementData[index] = element;\n\t    size++;\n\t}\n```\n首先检查index是否超过当前数组的大小，是否扩容判断，数组的复制将需要插入的位置的元素往后移一位，最后执行插入特定元素。\n数组的开销主要在于，创建开辟数组空间和数组中的元素移动，所以在平时的操作中，尽量避免使用Add（int index，E data）方法，创建数组前确认数组的长度等。\n* \tLinkedList\nLinkedList内部使用双向链表实现，随机访问效率低，随机插入、删除效率高。可以当作堆栈、队列、双向队列来使用。LinkedList也是非线程安全的。\n链表为啥插入或删除效率高，访问效率低？\n主要原因是双链表就是每个node不仅包含指向下后一个结点的引用，还包含着指向前一个结点的引用。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而顺序表相应的时间复杂度O(1)。\n链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。接下来单独写一篇关于链表的文章，来具体了解一下链表。\n* Vector\nVector跟ArrayList是类似的，内部实现也是动态数组，随机访问效率高。Vector是线程安全的。\n由于Vector内部使用了synchronized，所以线程是安全的，但是整体的开销就很大，效率不高。\n2.\tSet\nSet是不能包含重合元素的容器，其实现类有HashSet，继承于它的接口有SortedSet接口等。Set中提供了加、减、和交等集合操作函数。Set不能按照索引随机访问元素，这是它与List的一个重要区别。\n讲两个set实现类 hashSet 和 TreeSet\n* \thashSet\nHashSet内部是使用HashMap实现的，HashSet的key值是不允许重复的，如果放入的对象是自定义对象，那么最好能够同时重写hashCode与equals函数，这样就能自定义添加的对象在什么样的情况下是一样的，即能保证在业务逻辑下能添加对象到HashSet中，保证业务逻辑的正确性。另外，HashSet里的元素不是按照顺序存储的。HashSet是非线程安全的。\n*\tTreeSet\n一般情况下set是无序的，但是TreeSet存储的元素是按顺序存储的，如果是存储的元素是自定义对象，那么需要实现Comparable接口。TreeSet也是非线程安全的。\n3.\tMap\nMap集合提供了按照“键值对”存储元素的方法，一个键唯一映射一个值。集合中“键值对”整体作为一个实体元素时，类似List集合，但是如果分开来讲，Map是一个两列元素的集合：键是一列，值是一列。与Set集合一样，Map也没有提供随机访问的能力，只能通过键来访问对应的值。\nMap的每一个元素都是一个Map.Entry，这个实体的结构是< Key, Value >样式。\n* Map总结\nHashMap存储键值对。当程序试图将一个key-value对放入 HashMap 中时，程序首先根据该key的hashCode()返回值决定该Entry的存储位置：如果两个Entry的key的hashCode() 返回值相同，那它们的存储位置相同。如果这两个Entry的key通过equals比较返回true，新添加Entry的value将覆盖集合中原有Entry的 value，但key不会覆盖。如果这两个Entry的key通过equals 比较返回false，新添加的Entry将与集合中原有Entry形成Entry 链，而且新添加的 Entry 位于 Entry 链的头部。由于HashMap多线程下扩容会出线程不安全，具体参考[谈谈HashMap线程不安全的体现]( https://blog.csdn.net/qq_24184997/article/details/87979866)这篇文章。\n接下来一篇单独讲一下hashMap 在Java8跟之前版本的变化和另一个ConcurrentHashMap 能解决并发情况下的线程不安全\n# 4. 总结：\n大概讲了一下什么是数据结构，Java集合中一些实现类底层使用的数据结构，并详细介绍了一些Java集合实现类的特点和区别。\n\n参考文档:\n[数据结构](https://zh.wikipedia.org/zh-hans/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)\n[JCSprout](https://crossoverjie.top/JCSprout/#/?id=introduction)\n","source":"_posts/Java-集合.md","raw":"---\ntitle: Java 集合\ndate: 2019-03-15 09:56:13\ntags:\n- JAVA\n---\n\n# 1.\t什么叫数据结构？\n在计算机科学中，数据结构（英语：data structure）是计算机中存储、组织数据的方式。数据结构意味着接口或封装：一个数据结构可被视为两个函数之间的接口，或者是由数据类型联合组成的存储内容的访问方法封装。\n# 2. 结构有哪些？\n常见的数据结构主要有8种，引用百度百科的图：\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190228100803325.png)\n# 3.\t一些数据结构在Java中的具体体现？\n1.\tList 接口\nList 具体实现类有ArrayList, LinkedList, Vector，下面我们来介绍一下它们的原理，区别和使用方式\n* ArrayList\nArrayList 实现于 List、RandomAccess 接口。可以插入空数据，也支持随机访问。内部实现采用动态数组，当容量不够时，自动扩容至（当前容量1.5倍）。元素的顺序按照插入的顺序排列。默认初始容量为10。随机访问效率高，随机插入、删除效率低。主要的属性是elementData 数组，以及 size 大小。在执行添加add（）方法时\n```\n\tpublic boolean add(E e) {\n\t    ensureCapacityInternal(size + 1);  // Increments modCount!!\n\t    elementData[size++] = e;\n\t    return true;\n\t}\n```\n 主要是做扩容判断，然后再将数据插入到数组中。Add（int index，E data）方法是在特定的位置，插入特定的元素。Index 不大于数组的大小，这种方式添加\n ```\n\tpublic void add(int index, E element) {\n\t    rangeCheckForAdd(index);\n\t    ensureCapacityInternal(size + 1);  // Increments modCount!!\n\t    System.arraycopy(elementData, index, elementData, index + 1,\n\t                     size - index);\n\t    elementData[index] = element;\n\t    size++;\n\t}\n```\n首先检查index是否超过当前数组的大小，是否扩容判断，数组的复制将需要插入的位置的元素往后移一位，最后执行插入特定元素。\n数组的开销主要在于，创建开辟数组空间和数组中的元素移动，所以在平时的操作中，尽量避免使用Add（int index，E data）方法，创建数组前确认数组的长度等。\n* \tLinkedList\nLinkedList内部使用双向链表实现，随机访问效率低，随机插入、删除效率高。可以当作堆栈、队列、双向队列来使用。LinkedList也是非线程安全的。\n链表为啥插入或删除效率高，访问效率低？\n主要原因是双链表就是每个node不仅包含指向下后一个结点的引用，还包含着指向前一个结点的引用。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而顺序表相应的时间复杂度O(1)。\n链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。接下来单独写一篇关于链表的文章，来具体了解一下链表。\n* Vector\nVector跟ArrayList是类似的，内部实现也是动态数组，随机访问效率高。Vector是线程安全的。\n由于Vector内部使用了synchronized，所以线程是安全的，但是整体的开销就很大，效率不高。\n2.\tSet\nSet是不能包含重合元素的容器，其实现类有HashSet，继承于它的接口有SortedSet接口等。Set中提供了加、减、和交等集合操作函数。Set不能按照索引随机访问元素，这是它与List的一个重要区别。\n讲两个set实现类 hashSet 和 TreeSet\n* \thashSet\nHashSet内部是使用HashMap实现的，HashSet的key值是不允许重复的，如果放入的对象是自定义对象，那么最好能够同时重写hashCode与equals函数，这样就能自定义添加的对象在什么样的情况下是一样的，即能保证在业务逻辑下能添加对象到HashSet中，保证业务逻辑的正确性。另外，HashSet里的元素不是按照顺序存储的。HashSet是非线程安全的。\n*\tTreeSet\n一般情况下set是无序的，但是TreeSet存储的元素是按顺序存储的，如果是存储的元素是自定义对象，那么需要实现Comparable接口。TreeSet也是非线程安全的。\n3.\tMap\nMap集合提供了按照“键值对”存储元素的方法，一个键唯一映射一个值。集合中“键值对”整体作为一个实体元素时，类似List集合，但是如果分开来讲，Map是一个两列元素的集合：键是一列，值是一列。与Set集合一样，Map也没有提供随机访问的能力，只能通过键来访问对应的值。\nMap的每一个元素都是一个Map.Entry，这个实体的结构是< Key, Value >样式。\n* Map总结\nHashMap存储键值对。当程序试图将一个key-value对放入 HashMap 中时，程序首先根据该key的hashCode()返回值决定该Entry的存储位置：如果两个Entry的key的hashCode() 返回值相同，那它们的存储位置相同。如果这两个Entry的key通过equals比较返回true，新添加Entry的value将覆盖集合中原有Entry的 value，但key不会覆盖。如果这两个Entry的key通过equals 比较返回false，新添加的Entry将与集合中原有Entry形成Entry 链，而且新添加的 Entry 位于 Entry 链的头部。由于HashMap多线程下扩容会出线程不安全，具体参考[谈谈HashMap线程不安全的体现]( https://blog.csdn.net/qq_24184997/article/details/87979866)这篇文章。\n接下来一篇单独讲一下hashMap 在Java8跟之前版本的变化和另一个ConcurrentHashMap 能解决并发情况下的线程不安全\n# 4. 总结：\n大概讲了一下什么是数据结构，Java集合中一些实现类底层使用的数据结构，并详细介绍了一些Java集合实现类的特点和区别。\n\n参考文档:\n[数据结构](https://zh.wikipedia.org/zh-hans/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)\n[JCSprout](https://crossoverjie.top/JCSprout/#/?id=introduction)\n","slug":"Java-集合","published":1,"updated":"2019-07-14T04:37:24.657Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8mkcttq00004osxqgnfq3da","content":"<h1 id=\"1-什么叫数据结构？\"><a href=\"#1-什么叫数据结构？\" class=\"headerlink\" title=\"1.    什么叫数据结构？\"></a>1.    什么叫数据结构？</h1><p>在计算机科学中，数据结构（英语：data structure）是计算机中存储、组织数据的方式。数据结构意味着接口或封装：一个数据结构可被视为两个函数之间的接口，或者是由数据类型联合组成的存储内容的访问方法封装。</p>\n<h1 id=\"2-结构有哪些？\"><a href=\"#2-结构有哪些？\" class=\"headerlink\" title=\"2. 结构有哪些？\"></a>2. 结构有哪些？</h1><p>常见的数据结构主要有8种，引用百度百科的图：<br> <img src=\"https://img-blog.csdnimg.cn/20190228100803325.png\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"3-一些数据结构在Java中的具体体现？\"><a href=\"#3-一些数据结构在Java中的具体体现？\" class=\"headerlink\" title=\"3.    一些数据结构在Java中的具体体现？\"></a>3.    一些数据结构在Java中的具体体现？</h1><ol>\n<li>List 接口<br>List 具体实现类有ArrayList, LinkedList, Vector，下面我们来介绍一下它们的原理，区别和使用方式</li>\n</ol>\n<ul>\n<li><p>ArrayList<br>ArrayList 实现于 List、RandomAccess 接口。可以插入空数据，也支持随机访问。内部实现采用动态数组，当容量不够时，自动扩容至（当前容量1.5倍）。元素的顺序按照插入的顺序排列。默认初始容量为10。随机访问效率高，随机插入、删除效率低。主要的属性是elementData 数组，以及 size 大小。在执行添加add（）方法时</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public boolean add(E e) &#123;</span><br><span class=\"line\">    ensureCapacityInternal(size + 1);  // Increments modCount!!</span><br><span class=\"line\">    elementData[size++] = e;</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>主要是做扩容判断，然后再将数据插入到数组中。Add（int index，E data）方法是在特定的位置，插入特定的元素。Index 不大于数组的大小，这种方式添加</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void add(int index, E element) &#123;</span><br><span class=\"line\">    rangeCheckForAdd(index);</span><br><span class=\"line\">    ensureCapacityInternal(size + 1);  // Increments modCount!!</span><br><span class=\"line\">    System.arraycopy(elementData, index, elementData, index + 1,</span><br><span class=\"line\">                     size - index);</span><br><span class=\"line\">    elementData[index] = element;</span><br><span class=\"line\">    size++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>首先检查index是否超过当前数组的大小，是否扩容判断，数组的复制将需要插入的位置的元素往后移一位，最后执行插入特定元素。<br>数组的开销主要在于，创建开辟数组空间和数组中的元素移动，所以在平时的操作中，尽量避免使用Add（int index，E data）方法，创建数组前确认数组的长度等。</p>\n<ul>\n<li>LinkedList<br>LinkedList内部使用双向链表实现，随机访问效率低，随机插入、删除效率高。可以当作堆栈、队列、双向队列来使用。LinkedList也是非线程安全的。<br>链表为啥插入或删除效率高，访问效率低？<br>主要原因是双链表就是每个node不仅包含指向下后一个结点的引用，还包含着指向前一个结点的引用。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而顺序表相应的时间复杂度O(1)。<br>链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。接下来单独写一篇关于链表的文章，来具体了解一下链表。</li>\n<li>Vector<br>Vector跟ArrayList是类似的，内部实现也是动态数组，随机访问效率高。Vector是线程安全的。<br>由于Vector内部使用了synchronized，所以线程是安全的，但是整体的开销就很大，效率不高。</li>\n</ul>\n<ol start=\"2\">\n<li>Set<br>Set是不能包含重合元素的容器，其实现类有HashSet，继承于它的接口有SortedSet接口等。Set中提供了加、减、和交等集合操作函数。Set不能按照索引随机访问元素，这是它与List的一个重要区别。<br>讲两个set实现类 hashSet 和 TreeSet</li>\n</ol>\n<ul>\n<li>hashSet<br>HashSet内部是使用HashMap实现的，HashSet的key值是不允许重复的，如果放入的对象是自定义对象，那么最好能够同时重写hashCode与equals函数，这样就能自定义添加的对象在什么样的情况下是一样的，即能保证在业务逻辑下能添加对象到HashSet中，保证业务逻辑的正确性。另外，HashSet里的元素不是按照顺序存储的。HashSet是非线程安全的。</li>\n<li>TreeSet<br>一般情况下set是无序的，但是TreeSet存储的元素是按顺序存储的，如果是存储的元素是自定义对象，那么需要实现Comparable接口。TreeSet也是非线程安全的。</li>\n</ul>\n<ol start=\"3\">\n<li>Map<br>Map集合提供了按照“键值对”存储元素的方法，一个键唯一映射一个值。集合中“键值对”整体作为一个实体元素时，类似List集合，但是如果分开来讲，Map是一个两列元素的集合：键是一列，值是一列。与Set集合一样，Map也没有提供随机访问的能力，只能通过键来访问对应的值。<br>Map的每一个元素都是一个Map.Entry，这个实体的结构是&lt; Key, Value &gt;样式。</li>\n</ol>\n<ul>\n<li>Map总结<br>HashMap存储键值对。当程序试图将一个key-value对放入 HashMap 中时，程序首先根据该key的hashCode()返回值决定该Entry的存储位置：如果两个Entry的key的hashCode() 返回值相同，那它们的存储位置相同。如果这两个Entry的key通过equals比较返回true，新添加Entry的value将覆盖集合中原有Entry的 value，但key不会覆盖。如果这两个Entry的key通过equals 比较返回false，新添加的Entry将与集合中原有Entry形成Entry 链，而且新添加的 Entry 位于 Entry 链的头部。由于HashMap多线程下扩容会出线程不安全，具体参考<a href=\"https://blog.csdn.net/qq_24184997/article/details/87979866\" target=\"_blank\" rel=\"noopener\">谈谈HashMap线程不安全的体现</a>这篇文章。<br>接下来一篇单独讲一下hashMap 在Java8跟之前版本的变化和另一个ConcurrentHashMap 能解决并发情况下的线程不安全<h1 id=\"4-总结：\"><a href=\"#4-总结：\" class=\"headerlink\" title=\"4. 总结：\"></a>4. 总结：</h1>大概讲了一下什么是数据结构，Java集合中一些实现类底层使用的数据结构，并详细介绍了一些Java集合实现类的特点和区别。</li>\n</ul>\n<p>参考文档:<br><a href=\"https://zh.wikipedia.org/zh-hans/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\" target=\"_blank\" rel=\"noopener\">数据结构</a><br><a href=\"https://crossoverjie.top/JCSprout/#/?id=introduction\" target=\"_blank\" rel=\"noopener\">JCSprout</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-什么叫数据结构？\"><a href=\"#1-什么叫数据结构？\" class=\"headerlink\" title=\"1.    什么叫数据结构？\"></a>1.    什么叫数据结构？</h1><p>在计算机科学中，数据结构（英语：data structure）是计算机中存储、组织数据的方式。数据结构意味着接口或封装：一个数据结构可被视为两个函数之间的接口，或者是由数据类型联合组成的存储内容的访问方法封装。</p>\n<h1 id=\"2-结构有哪些？\"><a href=\"#2-结构有哪些？\" class=\"headerlink\" title=\"2. 结构有哪些？\"></a>2. 结构有哪些？</h1><p>常见的数据结构主要有8种，引用百度百科的图：<br> <img src=\"https://img-blog.csdnimg.cn/20190228100803325.png\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"3-一些数据结构在Java中的具体体现？\"><a href=\"#3-一些数据结构在Java中的具体体现？\" class=\"headerlink\" title=\"3.    一些数据结构在Java中的具体体现？\"></a>3.    一些数据结构在Java中的具体体现？</h1><ol>\n<li>List 接口<br>List 具体实现类有ArrayList, LinkedList, Vector，下面我们来介绍一下它们的原理，区别和使用方式</li>\n</ol>\n<ul>\n<li><p>ArrayList<br>ArrayList 实现于 List、RandomAccess 接口。可以插入空数据，也支持随机访问。内部实现采用动态数组，当容量不够时，自动扩容至（当前容量1.5倍）。元素的顺序按照插入的顺序排列。默认初始容量为10。随机访问效率高，随机插入、删除效率低。主要的属性是elementData 数组，以及 size 大小。在执行添加add（）方法时</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public boolean add(E e) &#123;</span><br><span class=\"line\">    ensureCapacityInternal(size + 1);  // Increments modCount!!</span><br><span class=\"line\">    elementData[size++] = e;</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>主要是做扩容判断，然后再将数据插入到数组中。Add（int index，E data）方法是在特定的位置，插入特定的元素。Index 不大于数组的大小，这种方式添加</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void add(int index, E element) &#123;</span><br><span class=\"line\">    rangeCheckForAdd(index);</span><br><span class=\"line\">    ensureCapacityInternal(size + 1);  // Increments modCount!!</span><br><span class=\"line\">    System.arraycopy(elementData, index, elementData, index + 1,</span><br><span class=\"line\">                     size - index);</span><br><span class=\"line\">    elementData[index] = element;</span><br><span class=\"line\">    size++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>首先检查index是否超过当前数组的大小，是否扩容判断，数组的复制将需要插入的位置的元素往后移一位，最后执行插入特定元素。<br>数组的开销主要在于，创建开辟数组空间和数组中的元素移动，所以在平时的操作中，尽量避免使用Add（int index，E data）方法，创建数组前确认数组的长度等。</p>\n<ul>\n<li>LinkedList<br>LinkedList内部使用双向链表实现，随机访问效率低，随机插入、删除效率高。可以当作堆栈、队列、双向队列来使用。LinkedList也是非线程安全的。<br>链表为啥插入或删除效率高，访问效率低？<br>主要原因是双链表就是每个node不仅包含指向下后一个结点的引用，还包含着指向前一个结点的引用。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而顺序表相应的时间复杂度O(1)。<br>链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。接下来单独写一篇关于链表的文章，来具体了解一下链表。</li>\n<li>Vector<br>Vector跟ArrayList是类似的，内部实现也是动态数组，随机访问效率高。Vector是线程安全的。<br>由于Vector内部使用了synchronized，所以线程是安全的，但是整体的开销就很大，效率不高。</li>\n</ul>\n<ol start=\"2\">\n<li>Set<br>Set是不能包含重合元素的容器，其实现类有HashSet，继承于它的接口有SortedSet接口等。Set中提供了加、减、和交等集合操作函数。Set不能按照索引随机访问元素，这是它与List的一个重要区别。<br>讲两个set实现类 hashSet 和 TreeSet</li>\n</ol>\n<ul>\n<li>hashSet<br>HashSet内部是使用HashMap实现的，HashSet的key值是不允许重复的，如果放入的对象是自定义对象，那么最好能够同时重写hashCode与equals函数，这样就能自定义添加的对象在什么样的情况下是一样的，即能保证在业务逻辑下能添加对象到HashSet中，保证业务逻辑的正确性。另外，HashSet里的元素不是按照顺序存储的。HashSet是非线程安全的。</li>\n<li>TreeSet<br>一般情况下set是无序的，但是TreeSet存储的元素是按顺序存储的，如果是存储的元素是自定义对象，那么需要实现Comparable接口。TreeSet也是非线程安全的。</li>\n</ul>\n<ol start=\"3\">\n<li>Map<br>Map集合提供了按照“键值对”存储元素的方法，一个键唯一映射一个值。集合中“键值对”整体作为一个实体元素时，类似List集合，但是如果分开来讲，Map是一个两列元素的集合：键是一列，值是一列。与Set集合一样，Map也没有提供随机访问的能力，只能通过键来访问对应的值。<br>Map的每一个元素都是一个Map.Entry，这个实体的结构是&lt; Key, Value &gt;样式。</li>\n</ol>\n<ul>\n<li>Map总结<br>HashMap存储键值对。当程序试图将一个key-value对放入 HashMap 中时，程序首先根据该key的hashCode()返回值决定该Entry的存储位置：如果两个Entry的key的hashCode() 返回值相同，那它们的存储位置相同。如果这两个Entry的key通过equals比较返回true，新添加Entry的value将覆盖集合中原有Entry的 value，但key不会覆盖。如果这两个Entry的key通过equals 比较返回false，新添加的Entry将与集合中原有Entry形成Entry 链，而且新添加的 Entry 位于 Entry 链的头部。由于HashMap多线程下扩容会出线程不安全，具体参考<a href=\"https://blog.csdn.net/qq_24184997/article/details/87979866\" target=\"_blank\" rel=\"noopener\">谈谈HashMap线程不安全的体现</a>这篇文章。<br>接下来一篇单独讲一下hashMap 在Java8跟之前版本的变化和另一个ConcurrentHashMap 能解决并发情况下的线程不安全<h1 id=\"4-总结：\"><a href=\"#4-总结：\" class=\"headerlink\" title=\"4. 总结：\"></a>4. 总结：</h1>大概讲了一下什么是数据结构，Java集合中一些实现类底层使用的数据结构，并详细介绍了一些Java集合实现类的特点和区别。</li>\n</ul>\n<p>参考文档:<br><a href=\"https://zh.wikipedia.org/zh-hans/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\" target=\"_blank\" rel=\"noopener\">数据结构</a><br><a href=\"https://crossoverjie.top/JCSprout/#/?id=introduction\" target=\"_blank\" rel=\"noopener\">JCSprout</a></p>\n"},{"title":"JAVA 笔记","date":"2019-02-19T10:22:46.000Z","_content":"1. 面向对象和面向过程的主要区别\n\n      面向过程：性能相对较高\n      \n      面向对象：易扩展性，复用，维护\n2. Java的一点特点\n    \n    跨平台: Java 虚拟机实现平台无关性\n    支持多线程，网络编程\n3. jvm 和 jre\n    \n    Jvm：运行 Java 字节码的虚拟机\n    Java 是编译与解释共存的语言：机器码的运行效率高于 Java 解释器的\n    即时编辑器（JIT）: 优化将字节码转换为机器特定语言的过程相似的字节码\n    热点代码: 经常需要被调用的方法和代码块\n4. hashCode 和 equals\n    \n    对象的hashCode 作用：hashCode是一个整型，提高比较效率\n5. 线程，程序，进程\n    \n    程序: 程序是静态的代码\n    线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。\n    join() 定义在Thread.java中,作用是等待当前线程死亡，然后执行下一步\n    Thread sleep：睡眠，超时后自动回到就绪状态（不会释放对象锁的所有权），等待获取资源cpu\n    Object wait（This method should only be called by a thread that is the owner\n    * of this object's monitor.）：释放对象锁的所有权，线程处于阻塞状态，等待调用notify/notifyall\n    Wait和notify/notifyall 为啥是Object的方法\n    wait等待的是对象monitor，由于Java中的每一个对象都有一个内置的monitor对象，自然所有的类都理应有wait/notify方法\n    Yield（）\n6. 为什么局部变量需要显式设置初始化值 \n    \n    主要原因是执行顺序，对于局部变量而言，其赋值和取值访问顺序是确定的。Javac 不给局部变量设置初始值，主要原因是一种策略决定，一种规范\n\n\n\n\n","source":"_posts/JAVA-笔记.md","raw":"---\ntitle: JAVA 笔记\ndate: 2019-02-19 18:22:46\ntags:\n- JAVA\n---\n1. 面向对象和面向过程的主要区别\n\n      面向过程：性能相对较高\n      \n      面向对象：易扩展性，复用，维护\n2. Java的一点特点\n    \n    跨平台: Java 虚拟机实现平台无关性\n    支持多线程，网络编程\n3. jvm 和 jre\n    \n    Jvm：运行 Java 字节码的虚拟机\n    Java 是编译与解释共存的语言：机器码的运行效率高于 Java 解释器的\n    即时编辑器（JIT）: 优化将字节码转换为机器特定语言的过程相似的字节码\n    热点代码: 经常需要被调用的方法和代码块\n4. hashCode 和 equals\n    \n    对象的hashCode 作用：hashCode是一个整型，提高比较效率\n5. 线程，程序，进程\n    \n    程序: 程序是静态的代码\n    线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。\n    join() 定义在Thread.java中,作用是等待当前线程死亡，然后执行下一步\n    Thread sleep：睡眠，超时后自动回到就绪状态（不会释放对象锁的所有权），等待获取资源cpu\n    Object wait（This method should only be called by a thread that is the owner\n    * of this object's monitor.）：释放对象锁的所有权，线程处于阻塞状态，等待调用notify/notifyall\n    Wait和notify/notifyall 为啥是Object的方法\n    wait等待的是对象monitor，由于Java中的每一个对象都有一个内置的monitor对象，自然所有的类都理应有wait/notify方法\n    Yield（）\n6. 为什么局部变量需要显式设置初始化值 \n    \n    主要原因是执行顺序，对于局部变量而言，其赋值和取值访问顺序是确定的。Javac 不给局部变量设置初始值，主要原因是一种策略决定，一种规范\n\n\n\n\n","slug":"JAVA-笔记","published":1,"updated":"2019-07-14T03:11:26.953Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8mkcttv00024osx32wfm9v4","content":"<ol>\n<li><p>面向对象和面向过程的主要区别</p>\n<p>   面向过程：性能相对较高</p>\n<p>   面向对象：易扩展性，复用，维护</p>\n</li>\n<li><p>Java的一点特点</p>\n<p> 跨平台: Java 虚拟机实现平台无关性<br> 支持多线程，网络编程</p>\n</li>\n<li><p>jvm 和 jre</p>\n<p> Jvm：运行 Java 字节码的虚拟机<br> Java 是编译与解释共存的语言：机器码的运行效率高于 Java 解释器的<br> 即时编辑器（JIT）: 优化将字节码转换为机器特定语言的过程相似的字节码<br> 热点代码: 经常需要被调用的方法和代码块</p>\n</li>\n<li><p>hashCode 和 equals</p>\n<p> 对象的hashCode 作用：hashCode是一个整型，提高比较效率</p>\n</li>\n<li><p>线程，程序，进程</p>\n<p> 程序: 程序是静态的代码<br> 线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。<br> join() 定义在Thread.java中,作用是等待当前线程死亡，然后执行下一步<br> Thread sleep：睡眠，超时后自动回到就绪状态（不会释放对象锁的所有权），等待获取资源cpu<br> Object wait（This method should only be called by a thread that is the owner</p>\n<ul>\n<li>of this object’s monitor.）：释放对象锁的所有权，线程处于阻塞状态，等待调用notify/notifyall<br>Wait和notify/notifyall 为啥是Object的方法<br>wait等待的是对象monitor，由于Java中的每一个对象都有一个内置的monitor对象，自然所有的类都理应有wait/notify方法<br>Yield（）</li>\n</ul>\n</li>\n<li><p>为什么局部变量需要显式设置初始化值 </p>\n<p> 主要原因是执行顺序，对于局部变量而言，其赋值和取值访问顺序是确定的。Javac 不给局部变量设置初始值，主要原因是一种策略决定，一种规范</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li><p>面向对象和面向过程的主要区别</p>\n<p>   面向过程：性能相对较高</p>\n<p>   面向对象：易扩展性，复用，维护</p>\n</li>\n<li><p>Java的一点特点</p>\n<p> 跨平台: Java 虚拟机实现平台无关性<br> 支持多线程，网络编程</p>\n</li>\n<li><p>jvm 和 jre</p>\n<p> Jvm：运行 Java 字节码的虚拟机<br> Java 是编译与解释共存的语言：机器码的运行效率高于 Java 解释器的<br> 即时编辑器（JIT）: 优化将字节码转换为机器特定语言的过程相似的字节码<br> 热点代码: 经常需要被调用的方法和代码块</p>\n</li>\n<li><p>hashCode 和 equals</p>\n<p> 对象的hashCode 作用：hashCode是一个整型，提高比较效率</p>\n</li>\n<li><p>线程，程序，进程</p>\n<p> 程序: 程序是静态的代码<br> 线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。<br> join() 定义在Thread.java中,作用是等待当前线程死亡，然后执行下一步<br> Thread sleep：睡眠，超时后自动回到就绪状态（不会释放对象锁的所有权），等待获取资源cpu<br> Object wait（This method should only be called by a thread that is the owner</p>\n<ul>\n<li>of this object’s monitor.）：释放对象锁的所有权，线程处于阻塞状态，等待调用notify/notifyall<br>Wait和notify/notifyall 为啥是Object的方法<br>wait等待的是对象monitor，由于Java中的每一个对象都有一个内置的monitor对象，自然所有的类都理应有wait/notify方法<br>Yield（）</li>\n</ul>\n</li>\n<li><p>为什么局部变量需要显式设置初始化值 </p>\n<p> 主要原因是执行顺序，对于局部变量而言，其赋值和取值访问顺序是确定的。Javac 不给局部变量设置初始值，主要原因是一种策略决定，一种规范</p>\n</li>\n</ol>\n"},{"title":"Java 动态代理为啥需要接口？？？","date":"2019-03-15T01:43:16.000Z","_content":"\n带着问题，我们直接查看源码：\n```\npublic static Object newProxyInstance(ClassLoader loader,\n                                          Class<?>[] interfaces,\n                                          InvocationHandler h)\n        throws IllegalArgumentException\n    {\n        Objects.requireNonNull(h);\n\n        final Class<?>[] intfs = interfaces.clone();\n        final SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            checkProxyAccess(Reflection.getCallerClass(), loader, intfs);\n        }\n\n        /*\n         * Look up or generate the designated proxy class.\n         */\n        Class<?> cl = getProxyClass0(loader, intfs);\n\n        /*\n         * Invoke its constructor with the designated invocation handler.\n         */\n        try {\n            if (sm != null) {\n                checkNewProxyPermission(Reflection.getCallerClass(), cl);\n            }\n\n            final Constructor<?> cons = cl.getConstructor(constructorParams);\n            final InvocationHandler ih = h;\n            if (!Modifier.isPublic(cl.getModifiers())) {\n                AccessController.doPrivileged(new PrivilegedAction<Void>() {\n                    public Void run() {\n                        cons.setAccessible(true);\n                        return null;\n                    }\n                });\n            }\n            return cons.newInstance(new Object[]{h});\n        }\n        ....\n    }\n```\n从源码上，首先进行一系列的判断逻辑，然后到了\nClass<?> cl = getProxyClass0(loader, intfs);\n获取代理类的Class 对象，接下来执行\n final Constructor<?> cons = cl.getConstructor(constructorParams);\n 获取Class的构造对象，通过cons.newInstance(new Object[]{h}); 返回一个代理类实例对象，具体参考 [Java反射](http://www.xulian.net.cn/2019/02/20/java-%E5%8F%8D%E5%B0%84%E7%AC%94%E8%AE%B0/) 。\n 目前我们只知道代理类对象的创建过程，但是为啥只能传入接口还是得不到解决，那我们只能继续查看getProxyClass0源码：\n 具体实现步骤：\n 1. 验证，通过类加载对象和接口列表获取代理类的Class对象，如果缓存中存在则返回，没有就通过代理类工厂创建代理类\n 2. 创建代理类\n通过ProxyClassFactory工厂创建代理类，核心代码如下\n```\nString proxyName = proxyPkg + proxyClassNamePrefix + num;\nbyte[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags);\ndefineClass0(loader, proxyName, proxyClassFile, 0, proxyClassFile.length);\n```\n定义一个类的名称，通过传入的接口列表和访问标志生成一个代理类的字节码，最后调用defineClass0方法将字节码加载到类加载器中，创建一个代理类。\n现在我们来实现将代理类的字节码写入本地，查看具体代理类的信息：\n```\nbyte[] proxyClassFile = ProxyGenerator.generateProxyClass(\n                \"$proxy1\", new Class[] {Worker.class}, Modifier.PUBLIC);\n        FileOutputStream fos = null;\n        try {\n            fos = new FileOutputStream(\"D:/$proxy1.class\");\n            fos.write(proxyClassFile);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                fos.flush();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n```\n通过反编译启查看字节码：\n```\npublic class $proxy1 extends Proxy  implements Worker {\n....\npublic final void work()  throws  {\n    try  {\n      this.h.invoke(this, m3, null);\n      return;\n    }\n    ....\n  }\n....\n}\n```\n现在我们终于得到答案，为啥动态代理需要使用接口，主要原因是代理类已经继承了Proxy类，Java不支持多继承所以导致动态代理需要使用接口，接口支持多继承。终于可以说服自己为啥动态代理需要接口了。。。。。\n\n参考文档：\njdk 8\n","source":"_posts/Java-动态代理为啥需要接口？？？.md","raw":"---\ntitle: Java 动态代理为啥需要接口？？？\ndate: 2019-03-15 09:43:16\ntags:\n- java\n- 动态代理\n---\n\n带着问题，我们直接查看源码：\n```\npublic static Object newProxyInstance(ClassLoader loader,\n                                          Class<?>[] interfaces,\n                                          InvocationHandler h)\n        throws IllegalArgumentException\n    {\n        Objects.requireNonNull(h);\n\n        final Class<?>[] intfs = interfaces.clone();\n        final SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            checkProxyAccess(Reflection.getCallerClass(), loader, intfs);\n        }\n\n        /*\n         * Look up or generate the designated proxy class.\n         */\n        Class<?> cl = getProxyClass0(loader, intfs);\n\n        /*\n         * Invoke its constructor with the designated invocation handler.\n         */\n        try {\n            if (sm != null) {\n                checkNewProxyPermission(Reflection.getCallerClass(), cl);\n            }\n\n            final Constructor<?> cons = cl.getConstructor(constructorParams);\n            final InvocationHandler ih = h;\n            if (!Modifier.isPublic(cl.getModifiers())) {\n                AccessController.doPrivileged(new PrivilegedAction<Void>() {\n                    public Void run() {\n                        cons.setAccessible(true);\n                        return null;\n                    }\n                });\n            }\n            return cons.newInstance(new Object[]{h});\n        }\n        ....\n    }\n```\n从源码上，首先进行一系列的判断逻辑，然后到了\nClass<?> cl = getProxyClass0(loader, intfs);\n获取代理类的Class 对象，接下来执行\n final Constructor<?> cons = cl.getConstructor(constructorParams);\n 获取Class的构造对象，通过cons.newInstance(new Object[]{h}); 返回一个代理类实例对象，具体参考 [Java反射](http://www.xulian.net.cn/2019/02/20/java-%E5%8F%8D%E5%B0%84%E7%AC%94%E8%AE%B0/) 。\n 目前我们只知道代理类对象的创建过程，但是为啥只能传入接口还是得不到解决，那我们只能继续查看getProxyClass0源码：\n 具体实现步骤：\n 1. 验证，通过类加载对象和接口列表获取代理类的Class对象，如果缓存中存在则返回，没有就通过代理类工厂创建代理类\n 2. 创建代理类\n通过ProxyClassFactory工厂创建代理类，核心代码如下\n```\nString proxyName = proxyPkg + proxyClassNamePrefix + num;\nbyte[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags);\ndefineClass0(loader, proxyName, proxyClassFile, 0, proxyClassFile.length);\n```\n定义一个类的名称，通过传入的接口列表和访问标志生成一个代理类的字节码，最后调用defineClass0方法将字节码加载到类加载器中，创建一个代理类。\n现在我们来实现将代理类的字节码写入本地，查看具体代理类的信息：\n```\nbyte[] proxyClassFile = ProxyGenerator.generateProxyClass(\n                \"$proxy1\", new Class[] {Worker.class}, Modifier.PUBLIC);\n        FileOutputStream fos = null;\n        try {\n            fos = new FileOutputStream(\"D:/$proxy1.class\");\n            fos.write(proxyClassFile);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                fos.flush();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n```\n通过反编译启查看字节码：\n```\npublic class $proxy1 extends Proxy  implements Worker {\n....\npublic final void work()  throws  {\n    try  {\n      this.h.invoke(this, m3, null);\n      return;\n    }\n    ....\n  }\n....\n}\n```\n现在我们终于得到答案，为啥动态代理需要使用接口，主要原因是代理类已经继承了Proxy类，Java不支持多继承所以导致动态代理需要使用接口，接口支持多继承。终于可以说服自己为啥动态代理需要接口了。。。。。\n\n参考文档：\njdk 8\n","slug":"Java-动态代理为啥需要接口？？？","published":1,"updated":"2019-07-14T03:11:26.954Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8mkcttz00044osx3l9fw33g","content":"<p>带着问题，我们直接查看源码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static Object newProxyInstance(ClassLoader loader,</span><br><span class=\"line\">                                          Class&lt;?&gt;[] interfaces,</span><br><span class=\"line\">                                          InvocationHandler h)</span><br><span class=\"line\">        throws IllegalArgumentException</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Objects.requireNonNull(h);</span><br><span class=\"line\"></span><br><span class=\"line\">        final Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class=\"line\">        final SecurityManager sm = System.getSecurityManager();</span><br><span class=\"line\">        if (sm != null) &#123;</span><br><span class=\"line\">            checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        /*</span><br><span class=\"line\">         * Look up or generate the designated proxy class.</span><br><span class=\"line\">         */</span><br><span class=\"line\">        Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class=\"line\"></span><br><span class=\"line\">        /*</span><br><span class=\"line\">         * Invoke its constructor with the designated invocation handler.</span><br><span class=\"line\">         */</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            if (sm != null) &#123;</span><br><span class=\"line\">                checkNewProxyPermission(Reflection.getCallerClass(), cl);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class=\"line\">            final InvocationHandler ih = h;</span><br><span class=\"line\">            if (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class=\"line\">                AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class=\"line\">                    public Void run() &#123;</span><br><span class=\"line\">                        cons.setAccessible(true);</span><br><span class=\"line\">                        return null;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return cons.newInstance(new Object[]&#123;h&#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ....</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>从源码上，首先进行一系列的判断逻辑，然后到了<br>Class&lt;?&gt; cl = getProxyClass0(loader, intfs);<br>获取代理类的Class 对象，接下来执行<br> final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);<br> 获取Class的构造对象，通过cons.newInstance(new Object[]{h}); 返回一个代理类实例对象，具体参考 <a href=\"http://www.xulian.net.cn/2019/02/20/java-%E5%8F%8D%E5%B0%84%E7%AC%94%E8%AE%B0/\" target=\"_blank\" rel=\"noopener\">Java反射</a> 。<br> 目前我们只知道代理类对象的创建过程，但是为啥只能传入接口还是得不到解决，那我们只能继续查看getProxyClass0源码：<br> 具体实现步骤：</p>\n<ol>\n<li>验证，通过类加载对象和接口列表获取代理类的Class对象，如果缓存中存在则返回，没有就通过代理类工厂创建代理类</li>\n<li>创建代理类<br>通过ProxyClassFactory工厂创建代理类，核心代码如下<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String proxyName = proxyPkg + proxyClassNamePrefix + num;</span><br><span class=\"line\">byte[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags);</span><br><span class=\"line\">defineClass0(loader, proxyName, proxyClassFile, 0, proxyClassFile.length);</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>定义一个类的名称，通过传入的接口列表和访问标志生成一个代理类的字节码，最后调用defineClass0方法将字节码加载到类加载器中，创建一个代理类。<br>现在我们来实现将代理类的字节码写入本地，查看具体代理类的信息：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">byte[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class=\"line\">                &quot;$proxy1&quot;, new Class[] &#123;Worker.class&#125;, Modifier.PUBLIC);</span><br><span class=\"line\">        FileOutputStream fos = null;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            fos = new FileOutputStream(&quot;D:/$proxy1.class&quot;);</span><br><span class=\"line\">            fos.write(proxyClassFile);</span><br><span class=\"line\">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; catch (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; finally &#123;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                fos.flush();</span><br><span class=\"line\">            &#125; catch (IOException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></p>\n<p>通过反编译启查看字节码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class $proxy1 extends Proxy  implements Worker &#123;</span><br><span class=\"line\">....</span><br><span class=\"line\">public final void work()  throws  &#123;</span><br><span class=\"line\">    try  &#123;</span><br><span class=\"line\">      this.h.invoke(this, m3, null);</span><br><span class=\"line\">      return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ....</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">....</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>现在我们终于得到答案，为啥动态代理需要使用接口，主要原因是代理类已经继承了Proxy类，Java不支持多继承所以导致动态代理需要使用接口，接口支持多继承。终于可以说服自己为啥动态代理需要接口了。。。。。</p>\n<p>参考文档：<br>jdk 8</p>\n","site":{"data":{}},"excerpt":"","more":"<p>带着问题，我们直接查看源码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static Object newProxyInstance(ClassLoader loader,</span><br><span class=\"line\">                                          Class&lt;?&gt;[] interfaces,</span><br><span class=\"line\">                                          InvocationHandler h)</span><br><span class=\"line\">        throws IllegalArgumentException</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Objects.requireNonNull(h);</span><br><span class=\"line\"></span><br><span class=\"line\">        final Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class=\"line\">        final SecurityManager sm = System.getSecurityManager();</span><br><span class=\"line\">        if (sm != null) &#123;</span><br><span class=\"line\">            checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        /*</span><br><span class=\"line\">         * Look up or generate the designated proxy class.</span><br><span class=\"line\">         */</span><br><span class=\"line\">        Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class=\"line\"></span><br><span class=\"line\">        /*</span><br><span class=\"line\">         * Invoke its constructor with the designated invocation handler.</span><br><span class=\"line\">         */</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            if (sm != null) &#123;</span><br><span class=\"line\">                checkNewProxyPermission(Reflection.getCallerClass(), cl);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class=\"line\">            final InvocationHandler ih = h;</span><br><span class=\"line\">            if (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class=\"line\">                AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class=\"line\">                    public Void run() &#123;</span><br><span class=\"line\">                        cons.setAccessible(true);</span><br><span class=\"line\">                        return null;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return cons.newInstance(new Object[]&#123;h&#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ....</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>从源码上，首先进行一系列的判断逻辑，然后到了<br>Class&lt;?&gt; cl = getProxyClass0(loader, intfs);<br>获取代理类的Class 对象，接下来执行<br> final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);<br> 获取Class的构造对象，通过cons.newInstance(new Object[]{h}); 返回一个代理类实例对象，具体参考 <a href=\"http://www.xulian.net.cn/2019/02/20/java-%E5%8F%8D%E5%B0%84%E7%AC%94%E8%AE%B0/\" target=\"_blank\" rel=\"noopener\">Java反射</a> 。<br> 目前我们只知道代理类对象的创建过程，但是为啥只能传入接口还是得不到解决，那我们只能继续查看getProxyClass0源码：<br> 具体实现步骤：</p>\n<ol>\n<li>验证，通过类加载对象和接口列表获取代理类的Class对象，如果缓存中存在则返回，没有就通过代理类工厂创建代理类</li>\n<li>创建代理类<br>通过ProxyClassFactory工厂创建代理类，核心代码如下<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String proxyName = proxyPkg + proxyClassNamePrefix + num;</span><br><span class=\"line\">byte[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags);</span><br><span class=\"line\">defineClass0(loader, proxyName, proxyClassFile, 0, proxyClassFile.length);</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>定义一个类的名称，通过传入的接口列表和访问标志生成一个代理类的字节码，最后调用defineClass0方法将字节码加载到类加载器中，创建一个代理类。<br>现在我们来实现将代理类的字节码写入本地，查看具体代理类的信息：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">byte[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class=\"line\">                &quot;$proxy1&quot;, new Class[] &#123;Worker.class&#125;, Modifier.PUBLIC);</span><br><span class=\"line\">        FileOutputStream fos = null;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            fos = new FileOutputStream(&quot;D:/$proxy1.class&quot;);</span><br><span class=\"line\">            fos.write(proxyClassFile);</span><br><span class=\"line\">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; catch (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; finally &#123;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                fos.flush();</span><br><span class=\"line\">            &#125; catch (IOException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></p>\n<p>通过反编译启查看字节码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class $proxy1 extends Proxy  implements Worker &#123;</span><br><span class=\"line\">....</span><br><span class=\"line\">public final void work()  throws  &#123;</span><br><span class=\"line\">    try  &#123;</span><br><span class=\"line\">      this.h.invoke(this, m3, null);</span><br><span class=\"line\">      return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ....</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">....</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>现在我们终于得到答案，为啥动态代理需要使用接口，主要原因是代理类已经继承了Proxy类，Java不支持多继承所以导致动态代理需要使用接口，接口支持多继承。终于可以说服自己为啥动态代理需要接口了。。。。。</p>\n<p>参考文档：<br>jdk 8</p>\n"},{"title":"JAVA 8的新特性 - 1","date":"2019-02-22T09:34:48.000Z","_content":"Java 8 相比之前主要变化？\n\n# 1. Lambda 表达式\n\n可传递的一种匿名函数的方式：它没有名称，但是它有参数列表、函数体、返回类型，可能还有一个可抛出的异常列表。下面我们用例子来解释:\n\n* 匿名------我们说匿名，是因为它不像普通的方法那样有一个明确的名称：写得少而想  \n得多！\n\n* 函数------我们说它是函数，是因为Lambda函数不像方法那样属于某个特定的类。但和方法一样， Lambda有参数列表、函数主体、返回类型，还可能有可以抛出的异常列表。\n\n* 传递------Lambda表达式可以作为参数传递给方法或存储在变量中。\n\n* 简洁------无需像匿名类那样写很多模板代码。\n\n我们通过一段代码来发现Lambda 表达式的简洁之处：\n\n1：找出Person列表中 比传入age 更老的Person 列表，不通过Lambda表达式，写法如下：\n```\n    public static void printPersonsOlderThan(List\\<Person\\> roster, int age){\n        for (Person p : roster) {\n            if (p.getAge() \\>= age) {\n        \n                 p.printPerson();\n            }\n        }\n    }\n```\n2：接下来如果我们使用Lambda 表达式重写上段代码：\n\n```\nroster\n    .stream()\n    .filter(p -> {p.getAge() > age}).forEach(p -> p. p.printPerson());\n```\n使用Lambda 表达式之后让代码更整洁，读起来更清晰\n\nLambda 表达式词法：\n```\n* 在括号中参数列表用逗号分隔\n* 使用 ->\n* 如果有return声明，在Lambda 表达式中， 就必要用花括号来括起语句\n```\np -> {\n    return p. p.printPerson()\n}\n\n然而如果是一个void方法就不必使用{}\n\nemail -> System.out.println(email)\n\n\n# 2. 方法的引用\n\n重复使用现有的方法定义，并像Lambda一样传递它们函数式数据处理。下面就是四种方法的引用：\n\n\n    | **Kind**      | **Example**                          |\n    | 静态方法引用        | ContainingClass::staticMethodName    |\n    | 特定对象的方法引用     | containingObject::instanceMethodName |\n    | 特定类型的任意对象方法引用 | ContainingType::methodName           |\n    | 构造引用          | ClassName::new                       |\n\n下面我们通过代码来解释一下：\n\n```\npublic class Person {\n    public enum Sex {\n\n        MALE, FEMALE\n\n    }\n    String name;\n    LocalDate birthday;\n    Sex gender;\n    String emailAddress;\n    public int getAge() {\n        // ...\n    }\n    \n    public Calendar getBirthday() {\n        return birthday;\n    }    \n\n    public static int compareByAge(Person a, Person b) {\n        return a.birthday.compareTo(b.birthday);\n    }\n\n}\n```\n\n* 静态方法引用\n```\nPerson::compareByAge\n```\n\n* 特定对象的方法引用\n\n跟着一个例子来解释特定对象的方法引用\n\n```\nclass Student {\n\n    public int compareByAge(String a, String b) {\n\n        return a.compareTo(b);\n\n    }\n\n    public static void main(String[] args) {\n\n        Student stu = new Student();\n\n        String[] arr = {\"ABC\",\"abc\",\"sdf\",\"ddddd\",\"rrrttt\"};\n\n        Arrays.sort(arr,(a, b) -> stu.compareByAge(a,b));\n\n        Arrays.stream(arr).forEach(System.out::println);\n\n    }\n\n}\n```\n\n方法接收的是一个String对象\n\n\n* 特定类型的任意对象方法引用\n\n```\nString[] stringArray = { \"Barbara\", \"James\", \"Mary\", \"John\",\n\"Patricia\", \"Robert\", \"Michael\", \"Linda\" };\nArrays.sort(stringArray, String::compareToIgnoreCase);\n```\n这个方法引用将调用a.compareToIgnoreCase(b)方法\n```\n 构造引用\n使用Lambda 表达式 （） -\\> {return new HashMap\\<\\>();}\n```\n使用构造引用 HashSet::new 让Lambda 表达式有了一种快捷的写法\n```\n 特定对象的方法引用 和特定类型的任意对象方法引用的区别\nString::compareToIgnoreCase 中，当你引用对象的方法时，这个对象本身就是一个Lambda表达式的参数Lambda表达式(String s) -\\> s. compareToIgnoreCase ()可以写作String:: compareToIgnoreCase。而特定对象的方法引用则是(a, b) -\\> stu.compareByAge(a,b),等价stu::compareByAge\n```\n![](JAVA-8的新特性-1/1550828240.jpg)\n\n\n\n# 3. 接口的默认方法和静态方法\n\nJava 8 允许在接口中添加默认方法，这个默认方法和之前的抽象方法不一样，主要在于抽象方法实现者必要实现，默认方法实现者都包含，如果需要可以重写这个方法。具体我们通过例子来解释：\n\n创建一个car 接口，声明一个默认方法和一个静态方法\n\n\n```\npublic interface Car {\n\n    default void print() {\n\n        System.out.println(\"default------------\");\n\n    }\n\n    static Car create( Supplier<Car> supplier ) {\n\n        return supplier.get();\n\n    }\n\n}\n```\n实现newCar类\n```\npublic class NewCar implements Car {\n    public static void main(String[] args) {\n\n        Car newCar = Car.create(NewCar::new);\n\n        newCar.print();\n\n    }\n}\n```\n\n覆盖默认方法 OverriddenCar\n\n\n```\npublic class OverriddenCar implements Car {\n\n    @Override\n\n    public void print() {\n\n        System.out.println(\"OverriddenCar------------------\");\n\n    }\n\n    public static void main(String[] args) {\n\n        Car overriddenCar = Car.create(OverriddenCar::new);\n\n        overriddenCar.print();\n\n        Car newCar = Car.create(NewCar::new);\n\n        newCar.print();\n\n    }\n\n}\n```\n打印结果\n```\nOverriddenCar------------------\ndefault------------\n```\n\n在JVM中，默认方法的实现是非常高效的，并且通过字节码指令为方法调用提供了支持。默认方法允许继续使用现有的Java接口，而同时能够保障正常的编译过程。这方面好的例子是大量的方法被添加到java.util.Collection接口中去：stream()，parallelStream()，forEach()，removeIf()，......\n\n\n尽管默认方法非常强大，但是在使用默认方法时我们需要小心注意一个地方：在声明一个默认方法前，请仔细思考是不是真的有必要使用默认方法，因为默认方法会带给程序歧义，并且在复杂的继承体系中容易产生编译错误。\n\n参考文档：\n\n  [Java 8新特性终极指南](http://www.importnew.com/11908.html)\n\n  Java+8 实战书籍\n\n  [Java tutorial ](https://docs.oracle.com/javase/tutorial/)","source":"_posts/JAVA-8的新特性-1.md","raw":"---\ntitle: JAVA 8的新特性 - 1\ndate: 2019-02-22 17:34:48\ntags:\n- JAVA\n- Lambda 表达式\n---\nJava 8 相比之前主要变化？\n\n# 1. Lambda 表达式\n\n可传递的一种匿名函数的方式：它没有名称，但是它有参数列表、函数体、返回类型，可能还有一个可抛出的异常列表。下面我们用例子来解释:\n\n* 匿名------我们说匿名，是因为它不像普通的方法那样有一个明确的名称：写得少而想  \n得多！\n\n* 函数------我们说它是函数，是因为Lambda函数不像方法那样属于某个特定的类。但和方法一样， Lambda有参数列表、函数主体、返回类型，还可能有可以抛出的异常列表。\n\n* 传递------Lambda表达式可以作为参数传递给方法或存储在变量中。\n\n* 简洁------无需像匿名类那样写很多模板代码。\n\n我们通过一段代码来发现Lambda 表达式的简洁之处：\n\n1：找出Person列表中 比传入age 更老的Person 列表，不通过Lambda表达式，写法如下：\n```\n    public static void printPersonsOlderThan(List\\<Person\\> roster, int age){\n        for (Person p : roster) {\n            if (p.getAge() \\>= age) {\n        \n                 p.printPerson();\n            }\n        }\n    }\n```\n2：接下来如果我们使用Lambda 表达式重写上段代码：\n\n```\nroster\n    .stream()\n    .filter(p -> {p.getAge() > age}).forEach(p -> p. p.printPerson());\n```\n使用Lambda 表达式之后让代码更整洁，读起来更清晰\n\nLambda 表达式词法：\n```\n* 在括号中参数列表用逗号分隔\n* 使用 ->\n* 如果有return声明，在Lambda 表达式中， 就必要用花括号来括起语句\n```\np -> {\n    return p. p.printPerson()\n}\n\n然而如果是一个void方法就不必使用{}\n\nemail -> System.out.println(email)\n\n\n# 2. 方法的引用\n\n重复使用现有的方法定义，并像Lambda一样传递它们函数式数据处理。下面就是四种方法的引用：\n\n\n    | **Kind**      | **Example**                          |\n    | 静态方法引用        | ContainingClass::staticMethodName    |\n    | 特定对象的方法引用     | containingObject::instanceMethodName |\n    | 特定类型的任意对象方法引用 | ContainingType::methodName           |\n    | 构造引用          | ClassName::new                       |\n\n下面我们通过代码来解释一下：\n\n```\npublic class Person {\n    public enum Sex {\n\n        MALE, FEMALE\n\n    }\n    String name;\n    LocalDate birthday;\n    Sex gender;\n    String emailAddress;\n    public int getAge() {\n        // ...\n    }\n    \n    public Calendar getBirthday() {\n        return birthday;\n    }    \n\n    public static int compareByAge(Person a, Person b) {\n        return a.birthday.compareTo(b.birthday);\n    }\n\n}\n```\n\n* 静态方法引用\n```\nPerson::compareByAge\n```\n\n* 特定对象的方法引用\n\n跟着一个例子来解释特定对象的方法引用\n\n```\nclass Student {\n\n    public int compareByAge(String a, String b) {\n\n        return a.compareTo(b);\n\n    }\n\n    public static void main(String[] args) {\n\n        Student stu = new Student();\n\n        String[] arr = {\"ABC\",\"abc\",\"sdf\",\"ddddd\",\"rrrttt\"};\n\n        Arrays.sort(arr,(a, b) -> stu.compareByAge(a,b));\n\n        Arrays.stream(arr).forEach(System.out::println);\n\n    }\n\n}\n```\n\n方法接收的是一个String对象\n\n\n* 特定类型的任意对象方法引用\n\n```\nString[] stringArray = { \"Barbara\", \"James\", \"Mary\", \"John\",\n\"Patricia\", \"Robert\", \"Michael\", \"Linda\" };\nArrays.sort(stringArray, String::compareToIgnoreCase);\n```\n这个方法引用将调用a.compareToIgnoreCase(b)方法\n```\n 构造引用\n使用Lambda 表达式 （） -\\> {return new HashMap\\<\\>();}\n```\n使用构造引用 HashSet::new 让Lambda 表达式有了一种快捷的写法\n```\n 特定对象的方法引用 和特定类型的任意对象方法引用的区别\nString::compareToIgnoreCase 中，当你引用对象的方法时，这个对象本身就是一个Lambda表达式的参数Lambda表达式(String s) -\\> s. compareToIgnoreCase ()可以写作String:: compareToIgnoreCase。而特定对象的方法引用则是(a, b) -\\> stu.compareByAge(a,b),等价stu::compareByAge\n```\n![](JAVA-8的新特性-1/1550828240.jpg)\n\n\n\n# 3. 接口的默认方法和静态方法\n\nJava 8 允许在接口中添加默认方法，这个默认方法和之前的抽象方法不一样，主要在于抽象方法实现者必要实现，默认方法实现者都包含，如果需要可以重写这个方法。具体我们通过例子来解释：\n\n创建一个car 接口，声明一个默认方法和一个静态方法\n\n\n```\npublic interface Car {\n\n    default void print() {\n\n        System.out.println(\"default------------\");\n\n    }\n\n    static Car create( Supplier<Car> supplier ) {\n\n        return supplier.get();\n\n    }\n\n}\n```\n实现newCar类\n```\npublic class NewCar implements Car {\n    public static void main(String[] args) {\n\n        Car newCar = Car.create(NewCar::new);\n\n        newCar.print();\n\n    }\n}\n```\n\n覆盖默认方法 OverriddenCar\n\n\n```\npublic class OverriddenCar implements Car {\n\n    @Override\n\n    public void print() {\n\n        System.out.println(\"OverriddenCar------------------\");\n\n    }\n\n    public static void main(String[] args) {\n\n        Car overriddenCar = Car.create(OverriddenCar::new);\n\n        overriddenCar.print();\n\n        Car newCar = Car.create(NewCar::new);\n\n        newCar.print();\n\n    }\n\n}\n```\n打印结果\n```\nOverriddenCar------------------\ndefault------------\n```\n\n在JVM中，默认方法的实现是非常高效的，并且通过字节码指令为方法调用提供了支持。默认方法允许继续使用现有的Java接口，而同时能够保障正常的编译过程。这方面好的例子是大量的方法被添加到java.util.Collection接口中去：stream()，parallelStream()，forEach()，removeIf()，......\n\n\n尽管默认方法非常强大，但是在使用默认方法时我们需要小心注意一个地方：在声明一个默认方法前，请仔细思考是不是真的有必要使用默认方法，因为默认方法会带给程序歧义，并且在复杂的继承体系中容易产生编译错误。\n\n参考文档：\n\n  [Java 8新特性终极指南](http://www.importnew.com/11908.html)\n\n  Java+8 实战书籍\n\n  [Java tutorial ](https://docs.oracle.com/javase/tutorial/)","slug":"JAVA-8的新特性-1","published":1,"updated":"2019-07-14T03:11:26.952Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8mkctu000054osxam7epwq9","content":"<p>Java 8 相比之前主要变化？</p>\n<h1 id=\"1-Lambda-表达式\"><a href=\"#1-Lambda-表达式\" class=\"headerlink\" title=\"1. Lambda 表达式\"></a>1. Lambda 表达式</h1><p>可传递的一种匿名函数的方式：它没有名称，但是它有参数列表、函数体、返回类型，可能还有一个可抛出的异常列表。下面我们用例子来解释:</p>\n<ul>\n<li><p>匿名——我们说匿名，是因为它不像普通的方法那样有一个明确的名称：写得少而想<br>得多！</p>\n</li>\n<li><p>函数——我们说它是函数，是因为Lambda函数不像方法那样属于某个特定的类。但和方法一样， Lambda有参数列表、函数主体、返回类型，还可能有可以抛出的异常列表。</p>\n</li>\n<li><p>传递——Lambda表达式可以作为参数传递给方法或存储在变量中。</p>\n</li>\n<li><p>简洁——无需像匿名类那样写很多模板代码。</p>\n</li>\n</ul>\n<p>我们通过一段代码来发现Lambda 表达式的简洁之处：</p>\n<p>1：找出Person列表中 比传入age 更老的Person 列表，不通过Lambda表达式，写法如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void printPersonsOlderThan(List\\&lt;Person\\&gt; roster, int age)&#123;</span><br><span class=\"line\">    for (Person p : roster) &#123;</span><br><span class=\"line\">        if (p.getAge() \\&gt;= age) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">             p.printPerson();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>2：接下来如果我们使用Lambda 表达式重写上段代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">roster</span><br><span class=\"line\">    .stream()</span><br><span class=\"line\">    .filter(p -&gt; &#123;p.getAge() &gt; age&#125;).forEach(p -&gt; p. p.printPerson());</span><br></pre></td></tr></table></figure>\n<p>使用Lambda 表达式之后让代码更整洁，读起来更清晰</p>\n<p>Lambda 表达式词法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* 在括号中参数列表用逗号分隔</span><br><span class=\"line\">* 使用 -&gt;</span><br><span class=\"line\">* 如果有return声明，在Lambda 表达式中， 就必要用花括号来括起语句</span><br></pre></td></tr></table></figure></p>\n<p>p -&gt; {<br>    return p. p.printPerson()<br>}</p>\n<p>然而如果是一个void方法就不必使用{}</p>\n<p>email -&gt; System.out.println(email)</p>\n<h1 id=\"2-方法的引用\"><a href=\"#2-方法的引用\" class=\"headerlink\" title=\"2. 方法的引用\"></a>2. 方法的引用</h1><p>重复使用现有的方法定义，并像Lambda一样传递它们函数式数据处理。下面就是四种方法的引用：</p>\n<pre><code>| **Kind**      | **Example**                          |\n| 静态方法引用        | ContainingClass::staticMethodName    |\n| 特定对象的方法引用     | containingObject::instanceMethodName |\n| 特定类型的任意对象方法引用 | ContainingType::methodName           |\n| 构造引用          | ClassName::new                       |\n</code></pre><p>下面我们通过代码来解释一下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Person &#123;</span><br><span class=\"line\">    public enum Sex &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        MALE, FEMALE</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    String name;</span><br><span class=\"line\">    LocalDate birthday;</span><br><span class=\"line\">    Sex gender;</span><br><span class=\"line\">    String emailAddress;</span><br><span class=\"line\">    public int getAge() &#123;</span><br><span class=\"line\">        // ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    public Calendar getBirthday() &#123;</span><br><span class=\"line\">        return birthday;</span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\"></span><br><span class=\"line\">    public static int compareByAge(Person a, Person b) &#123;</span><br><span class=\"line\">        return a.birthday.compareTo(b.birthday);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>静态方法引用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person::compareByAge</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>特定对象的方法引用</p>\n</li>\n</ul>\n<p>跟着一个例子来解释特定对象的方法引用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Student &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public int compareByAge(String a, String b) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        return a.compareTo(b);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Student stu = new Student();</span><br><span class=\"line\"></span><br><span class=\"line\">        String[] arr = &#123;&quot;ABC&quot;,&quot;abc&quot;,&quot;sdf&quot;,&quot;ddddd&quot;,&quot;rrrttt&quot;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        Arrays.sort(arr,(a, b) -&gt; stu.compareByAge(a,b));</span><br><span class=\"line\"></span><br><span class=\"line\">        Arrays.stream(arr).forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>方法接收的是一个String对象</p>\n<ul>\n<li>特定类型的任意对象方法引用</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String[] stringArray = &#123; &quot;Barbara&quot;, &quot;James&quot;, &quot;Mary&quot;, &quot;John&quot;,</span><br><span class=\"line\">&quot;Patricia&quot;, &quot;Robert&quot;, &quot;Michael&quot;, &quot;Linda&quot; &#125;;</span><br><span class=\"line\">Arrays.sort(stringArray, String::compareToIgnoreCase);</span><br></pre></td></tr></table></figure>\n<p>这个方法引用将调用a.compareToIgnoreCase(b)方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 构造引用</span><br><span class=\"line\">使用Lambda 表达式 （） -\\&gt; &#123;return new HashMap\\&lt;\\&gt;();&#125;</span><br></pre></td></tr></table></figure></p>\n<p>使用构造引用 HashSet::new 让Lambda 表达式有了一种快捷的写法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 特定对象的方法引用 和特定类型的任意对象方法引用的区别</span><br><span class=\"line\">String::compareToIgnoreCase 中，当你引用对象的方法时，这个对象本身就是一个Lambda表达式的参数Lambda表达式(String s) -\\&gt; s. compareToIgnoreCase ()可以写作String:: compareToIgnoreCase。而特定对象的方法引用则是(a, b) -\\&gt; stu.compareByAge(a,b),等价stu::compareByAge</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"/2019/02/22/JAVA-8的新特性-1/1550828240.jpg\" alt=\"\"></p>\n<h1 id=\"3-接口的默认方法和静态方法\"><a href=\"#3-接口的默认方法和静态方法\" class=\"headerlink\" title=\"3. 接口的默认方法和静态方法\"></a>3. 接口的默认方法和静态方法</h1><p>Java 8 允许在接口中添加默认方法，这个默认方法和之前的抽象方法不一样，主要在于抽象方法实现者必要实现，默认方法实现者都包含，如果需要可以重写这个方法。具体我们通过例子来解释：</p>\n<p>创建一个car 接口，声明一个默认方法和一个静态方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface Car &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    default void print() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(&quot;default------------&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    static Car create( Supplier&lt;Car&gt; supplier ) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        return supplier.get();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实现newCar类<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class NewCar implements Car &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Car newCar = Car.create(NewCar::new);</span><br><span class=\"line\"></span><br><span class=\"line\">        newCar.print();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>覆盖默认方法 OverriddenCar</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class OverriddenCar implements Car &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\"></span><br><span class=\"line\">    public void print() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(&quot;OverriddenCar------------------&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Car overriddenCar = Car.create(OverriddenCar::new);</span><br><span class=\"line\"></span><br><span class=\"line\">        overriddenCar.print();</span><br><span class=\"line\"></span><br><span class=\"line\">        Car newCar = Car.create(NewCar::new);</span><br><span class=\"line\"></span><br><span class=\"line\">        newCar.print();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>打印结果<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OverriddenCar------------------</span><br><span class=\"line\">default------------</span><br></pre></td></tr></table></figure></p>\n<p>在JVM中，默认方法的实现是非常高效的，并且通过字节码指令为方法调用提供了支持。默认方法允许继续使用现有的Java接口，而同时能够保障正常的编译过程。这方面好的例子是大量的方法被添加到java.util.Collection接口中去：stream()，parallelStream()，forEach()，removeIf()，……</p>\n<p>尽管默认方法非常强大，但是在使用默认方法时我们需要小心注意一个地方：在声明一个默认方法前，请仔细思考是不是真的有必要使用默认方法，因为默认方法会带给程序歧义，并且在复杂的继承体系中容易产生编译错误。</p>\n<p>参考文档：</p>\n<p>  <a href=\"http://www.importnew.com/11908.html\" target=\"_blank\" rel=\"noopener\">Java 8新特性终极指南</a></p>\n<p>  Java+8 实战书籍</p>\n<p>  <a href=\"https://docs.oracle.com/javase/tutorial/\" target=\"_blank\" rel=\"noopener\">Java tutorial </a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Java 8 相比之前主要变化？</p>\n<h1 id=\"1-Lambda-表达式\"><a href=\"#1-Lambda-表达式\" class=\"headerlink\" title=\"1. Lambda 表达式\"></a>1. Lambda 表达式</h1><p>可传递的一种匿名函数的方式：它没有名称，但是它有参数列表、函数体、返回类型，可能还有一个可抛出的异常列表。下面我们用例子来解释:</p>\n<ul>\n<li><p>匿名——我们说匿名，是因为它不像普通的方法那样有一个明确的名称：写得少而想<br>得多！</p>\n</li>\n<li><p>函数——我们说它是函数，是因为Lambda函数不像方法那样属于某个特定的类。但和方法一样， Lambda有参数列表、函数主体、返回类型，还可能有可以抛出的异常列表。</p>\n</li>\n<li><p>传递——Lambda表达式可以作为参数传递给方法或存储在变量中。</p>\n</li>\n<li><p>简洁——无需像匿名类那样写很多模板代码。</p>\n</li>\n</ul>\n<p>我们通过一段代码来发现Lambda 表达式的简洁之处：</p>\n<p>1：找出Person列表中 比传入age 更老的Person 列表，不通过Lambda表达式，写法如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void printPersonsOlderThan(List\\&lt;Person\\&gt; roster, int age)&#123;</span><br><span class=\"line\">    for (Person p : roster) &#123;</span><br><span class=\"line\">        if (p.getAge() \\&gt;= age) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">             p.printPerson();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>2：接下来如果我们使用Lambda 表达式重写上段代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">roster</span><br><span class=\"line\">    .stream()</span><br><span class=\"line\">    .filter(p -&gt; &#123;p.getAge() &gt; age&#125;).forEach(p -&gt; p. p.printPerson());</span><br></pre></td></tr></table></figure>\n<p>使用Lambda 表达式之后让代码更整洁，读起来更清晰</p>\n<p>Lambda 表达式词法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* 在括号中参数列表用逗号分隔</span><br><span class=\"line\">* 使用 -&gt;</span><br><span class=\"line\">* 如果有return声明，在Lambda 表达式中， 就必要用花括号来括起语句</span><br></pre></td></tr></table></figure></p>\n<p>p -&gt; {<br>    return p. p.printPerson()<br>}</p>\n<p>然而如果是一个void方法就不必使用{}</p>\n<p>email -&gt; System.out.println(email)</p>\n<h1 id=\"2-方法的引用\"><a href=\"#2-方法的引用\" class=\"headerlink\" title=\"2. 方法的引用\"></a>2. 方法的引用</h1><p>重复使用现有的方法定义，并像Lambda一样传递它们函数式数据处理。下面就是四种方法的引用：</p>\n<pre><code>| **Kind**      | **Example**                          |\n| 静态方法引用        | ContainingClass::staticMethodName    |\n| 特定对象的方法引用     | containingObject::instanceMethodName |\n| 特定类型的任意对象方法引用 | ContainingType::methodName           |\n| 构造引用          | ClassName::new                       |\n</code></pre><p>下面我们通过代码来解释一下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Person &#123;</span><br><span class=\"line\">    public enum Sex &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        MALE, FEMALE</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    String name;</span><br><span class=\"line\">    LocalDate birthday;</span><br><span class=\"line\">    Sex gender;</span><br><span class=\"line\">    String emailAddress;</span><br><span class=\"line\">    public int getAge() &#123;</span><br><span class=\"line\">        // ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    public Calendar getBirthday() &#123;</span><br><span class=\"line\">        return birthday;</span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\"></span><br><span class=\"line\">    public static int compareByAge(Person a, Person b) &#123;</span><br><span class=\"line\">        return a.birthday.compareTo(b.birthday);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>静态方法引用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person::compareByAge</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>特定对象的方法引用</p>\n</li>\n</ul>\n<p>跟着一个例子来解释特定对象的方法引用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Student &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public int compareByAge(String a, String b) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        return a.compareTo(b);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Student stu = new Student();</span><br><span class=\"line\"></span><br><span class=\"line\">        String[] arr = &#123;&quot;ABC&quot;,&quot;abc&quot;,&quot;sdf&quot;,&quot;ddddd&quot;,&quot;rrrttt&quot;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        Arrays.sort(arr,(a, b) -&gt; stu.compareByAge(a,b));</span><br><span class=\"line\"></span><br><span class=\"line\">        Arrays.stream(arr).forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>方法接收的是一个String对象</p>\n<ul>\n<li>特定类型的任意对象方法引用</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String[] stringArray = &#123; &quot;Barbara&quot;, &quot;James&quot;, &quot;Mary&quot;, &quot;John&quot;,</span><br><span class=\"line\">&quot;Patricia&quot;, &quot;Robert&quot;, &quot;Michael&quot;, &quot;Linda&quot; &#125;;</span><br><span class=\"line\">Arrays.sort(stringArray, String::compareToIgnoreCase);</span><br></pre></td></tr></table></figure>\n<p>这个方法引用将调用a.compareToIgnoreCase(b)方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 构造引用</span><br><span class=\"line\">使用Lambda 表达式 （） -\\&gt; &#123;return new HashMap\\&lt;\\&gt;();&#125;</span><br></pre></td></tr></table></figure></p>\n<p>使用构造引用 HashSet::new 让Lambda 表达式有了一种快捷的写法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 特定对象的方法引用 和特定类型的任意对象方法引用的区别</span><br><span class=\"line\">String::compareToIgnoreCase 中，当你引用对象的方法时，这个对象本身就是一个Lambda表达式的参数Lambda表达式(String s) -\\&gt; s. compareToIgnoreCase ()可以写作String:: compareToIgnoreCase。而特定对象的方法引用则是(a, b) -\\&gt; stu.compareByAge(a,b),等价stu::compareByAge</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"/2019/02/22/JAVA-8的新特性-1/1550828240.jpg\" alt=\"\"></p>\n<h1 id=\"3-接口的默认方法和静态方法\"><a href=\"#3-接口的默认方法和静态方法\" class=\"headerlink\" title=\"3. 接口的默认方法和静态方法\"></a>3. 接口的默认方法和静态方法</h1><p>Java 8 允许在接口中添加默认方法，这个默认方法和之前的抽象方法不一样，主要在于抽象方法实现者必要实现，默认方法实现者都包含，如果需要可以重写这个方法。具体我们通过例子来解释：</p>\n<p>创建一个car 接口，声明一个默认方法和一个静态方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface Car &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    default void print() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(&quot;default------------&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    static Car create( Supplier&lt;Car&gt; supplier ) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        return supplier.get();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实现newCar类<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class NewCar implements Car &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Car newCar = Car.create(NewCar::new);</span><br><span class=\"line\"></span><br><span class=\"line\">        newCar.print();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>覆盖默认方法 OverriddenCar</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class OverriddenCar implements Car &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\"></span><br><span class=\"line\">    public void print() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(&quot;OverriddenCar------------------&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Car overriddenCar = Car.create(OverriddenCar::new);</span><br><span class=\"line\"></span><br><span class=\"line\">        overriddenCar.print();</span><br><span class=\"line\"></span><br><span class=\"line\">        Car newCar = Car.create(NewCar::new);</span><br><span class=\"line\"></span><br><span class=\"line\">        newCar.print();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>打印结果<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OverriddenCar------------------</span><br><span class=\"line\">default------------</span><br></pre></td></tr></table></figure></p>\n<p>在JVM中，默认方法的实现是非常高效的，并且通过字节码指令为方法调用提供了支持。默认方法允许继续使用现有的Java接口，而同时能够保障正常的编译过程。这方面好的例子是大量的方法被添加到java.util.Collection接口中去：stream()，parallelStream()，forEach()，removeIf()，……</p>\n<p>尽管默认方法非常强大，但是在使用默认方法时我们需要小心注意一个地方：在声明一个默认方法前，请仔细思考是不是真的有必要使用默认方法，因为默认方法会带给程序歧义，并且在复杂的继承体系中容易产生编译错误。</p>\n<p>参考文档：</p>\n<p>  <a href=\"http://www.importnew.com/11908.html\" target=\"_blank\" rel=\"noopener\">Java 8新特性终极指南</a></p>\n<p>  Java+8 实战书籍</p>\n<p>  <a href=\"https://docs.oracle.com/javase/tutorial/\" target=\"_blank\" rel=\"noopener\">Java tutorial </a></p>\n"},{"title":"@ModelAttribute 对象没有无参的构造函数出错详解","date":"2019-02-18T09:15:47.000Z","_content":"如果对象没有无参的构造函数 @ModelAttribute 获取参数会报异常\n\n![ModelAttribute-对象没有无参的构造函数出错详解](https://img.mupaie.com/20180627151839209.png)\n\n \n\n通过反射出来的对象的参数类型（无参构造函数）和 类中构造函数（只有有参构造函数，没有无参构造函数 注释：当类中没有有参构造函数，会默认有一个无参构造函数，没有则无无参构造函数）的参数类型对比，\n\n![ModelAttribute-对象没有无参的构造函数出错详解](https://img.mupaie.com/20180628105206677.png)\n\n参数对比 ，两者不一致 返回false\n\n![ModelAttribute-对象没有无参的构造函数出错详解](https://img.mupaie.com/20180628105954917.png)\n\n最后抛出没有方法的异常信息\n\n","source":"_posts/ModelAttribute-对象没有无参的构造函数出错详解-1.md","raw":"---\ntitle: '@ModelAttribute 对象没有无参的构造函数出错详解'\ndate: 2019-02-18 17:15:47\ntags:\n---\n如果对象没有无参的构造函数 @ModelAttribute 获取参数会报异常\n\n![ModelAttribute-对象没有无参的构造函数出错详解](https://img.mupaie.com/20180627151839209.png)\n\n \n\n通过反射出来的对象的参数类型（无参构造函数）和 类中构造函数（只有有参构造函数，没有无参构造函数 注释：当类中没有有参构造函数，会默认有一个无参构造函数，没有则无无参构造函数）的参数类型对比，\n\n![ModelAttribute-对象没有无参的构造函数出错详解](https://img.mupaie.com/20180628105206677.png)\n\n参数对比 ，两者不一致 返回false\n\n![ModelAttribute-对象没有无参的构造函数出错详解](https://img.mupaie.com/20180628105954917.png)\n\n最后抛出没有方法的异常信息\n\n","slug":"ModelAttribute-对象没有无参的构造函数出错详解-1","published":1,"updated":"2019-07-14T04:16:44.469Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8mkctu100064osxuibo31fk","content":"<p>如果对象没有无参的构造函数 @ModelAttribute 获取参数会报异常</p>\n<p><img src=\"https://img.mupaie.com/20180627151839209.png\" alt=\"ModelAttribute-对象没有无参的构造函数出错详解\"></p>\n<p>通过反射出来的对象的参数类型（无参构造函数）和 类中构造函数（只有有参构造函数，没有无参构造函数 注释：当类中没有有参构造函数，会默认有一个无参构造函数，没有则无无参构造函数）的参数类型对比，</p>\n<p><img src=\"https://img.mupaie.com/20180628105206677.png\" alt=\"ModelAttribute-对象没有无参的构造函数出错详解\"></p>\n<p>参数对比 ，两者不一致 返回false</p>\n<p><img src=\"https://img.mupaie.com/20180628105954917.png\" alt=\"ModelAttribute-对象没有无参的构造函数出错详解\"></p>\n<p>最后抛出没有方法的异常信息</p>\n","site":{"data":{}},"excerpt":"","more":"<p>如果对象没有无参的构造函数 @ModelAttribute 获取参数会报异常</p>\n<p><img src=\"https://img.mupaie.com/20180627151839209.png\" alt=\"ModelAttribute-对象没有无参的构造函数出错详解\"></p>\n<p>通过反射出来的对象的参数类型（无参构造函数）和 类中构造函数（只有有参构造函数，没有无参构造函数 注释：当类中没有有参构造函数，会默认有一个无参构造函数，没有则无无参构造函数）的参数类型对比，</p>\n<p><img src=\"https://img.mupaie.com/20180628105206677.png\" alt=\"ModelAttribute-对象没有无参的构造函数出错详解\"></p>\n<p>参数对比 ，两者不一致 返回false</p>\n<p><img src=\"https://img.mupaie.com/20180628105954917.png\" alt=\"ModelAttribute-对象没有无参的构造函数出错详解\"></p>\n<p>最后抛出没有方法的异常信息</p>\n"},{"title":"Linux下项目自动部署脚本","date":"2019-02-18T09:06:43.000Z","_content":"这是本人第一次写shell 脚本，如果有一点错误的地方请谅解\n\n因为平时上线部署项目都是手动进行的，大概分四步:\n\n1：备份正在运行的项目文件\n\n2：关闭Tomcat\n\n3：复制需要部署的项目文件到Tomcat的weapps路径下\n\n4：启动Tomcat，并打印启动日志信息\n\n因为我们公司需要上线的项目版本，测试统一放在测试服务器的ftp下。线上项目部署在线上服务器，所以没有做从测试ftp拉取项目到线上服务器。这步操作需要自己手动将文件放置到线上服务器的某个路径，本人在线上服务器上创建了一个目录用于存放部署文件，并取名 online_delopy_project。\n\n说了这么多了，接下里开始写第一个shell 脚本用于部署项目\n\n\n    #!/bin/bash\n    TOMCAT_HOME=/home/xxxx/apache-tomcat-7.0.84 #服务器路径\n    BACKUP_HOME=/home/xxxx/yuelinghui-manage #备份文件的路径\n    ONLINE_PROJECT_HOME=/home/xxxx/online_delopy_project#需要上线部署的文件路径\n    PROJECT_VERSION=1.2.2 #项目的版本号\n    cd $BACKUP_HOME\n    new_file=yuelinghui_v${PROJECT_VERSION}_date +%Y%m%d #创建备份文件\n    mkdir $new_file\n    cp -rf $TOMCAT_HOME/webapps/ROOT/ $BACKUP_HOME/$new_file\n    ${TOMCAT_HOME}/bin/catalina.sh stop || true\n    sleep 1s #睡眠一秒 防止服务器没有关闭，就执行删除项目的操作\n    echo ‘删除服务器中的项目，重新部署’\n    rm -rf $TOMCAT_HOME/webapps/ROOT/\n    echo ‘部署开始。。。。’\n    cp -rf $ONLINE_PROJECT_HOME/* $TOMCAT_HOME/webapps/ROOT/\n    echo ‘启动tomcat。。。。’\n    ${TOMCAT_HOME}/bin/catalina.sh start || true\n    sleep 1s\n    echo ‘打印启用日志信息。。。。。。’\n    tail -10f ${TOMCAT_HOME}/logs/catalina.out\n    \n    date +%Y%m%d 获取当前时间\n","source":"_posts/Linux下项目自动部署脚本.md","raw":"---\ntitle: Linux下项目自动部署脚本\ndate: 2019-02-18 17:06:43\n---\n这是本人第一次写shell 脚本，如果有一点错误的地方请谅解\n\n因为平时上线部署项目都是手动进行的，大概分四步:\n\n1：备份正在运行的项目文件\n\n2：关闭Tomcat\n\n3：复制需要部署的项目文件到Tomcat的weapps路径下\n\n4：启动Tomcat，并打印启动日志信息\n\n因为我们公司需要上线的项目版本，测试统一放在测试服务器的ftp下。线上项目部署在线上服务器，所以没有做从测试ftp拉取项目到线上服务器。这步操作需要自己手动将文件放置到线上服务器的某个路径，本人在线上服务器上创建了一个目录用于存放部署文件，并取名 online_delopy_project。\n\n说了这么多了，接下里开始写第一个shell 脚本用于部署项目\n\n\n    #!/bin/bash\n    TOMCAT_HOME=/home/xxxx/apache-tomcat-7.0.84 #服务器路径\n    BACKUP_HOME=/home/xxxx/yuelinghui-manage #备份文件的路径\n    ONLINE_PROJECT_HOME=/home/xxxx/online_delopy_project#需要上线部署的文件路径\n    PROJECT_VERSION=1.2.2 #项目的版本号\n    cd $BACKUP_HOME\n    new_file=yuelinghui_v${PROJECT_VERSION}_date +%Y%m%d #创建备份文件\n    mkdir $new_file\n    cp -rf $TOMCAT_HOME/webapps/ROOT/ $BACKUP_HOME/$new_file\n    ${TOMCAT_HOME}/bin/catalina.sh stop || true\n    sleep 1s #睡眠一秒 防止服务器没有关闭，就执行删除项目的操作\n    echo ‘删除服务器中的项目，重新部署’\n    rm -rf $TOMCAT_HOME/webapps/ROOT/\n    echo ‘部署开始。。。。’\n    cp -rf $ONLINE_PROJECT_HOME/* $TOMCAT_HOME/webapps/ROOT/\n    echo ‘启动tomcat。。。。’\n    ${TOMCAT_HOME}/bin/catalina.sh start || true\n    sleep 1s\n    echo ‘打印启用日志信息。。。。。。’\n    tail -10f ${TOMCAT_HOME}/logs/catalina.out\n    \n    date +%Y%m%d 获取当前时间\n","slug":"Linux下项目自动部署脚本","published":1,"updated":"2019-07-14T03:11:26.954Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8mkctu400094osx471vu2mx","content":"<p>这是本人第一次写shell 脚本，如果有一点错误的地方请谅解</p>\n<p>因为平时上线部署项目都是手动进行的，大概分四步:</p>\n<p>1：备份正在运行的项目文件</p>\n<p>2：关闭Tomcat</p>\n<p>3：复制需要部署的项目文件到Tomcat的weapps路径下</p>\n<p>4：启动Tomcat，并打印启动日志信息</p>\n<p>因为我们公司需要上线的项目版本，测试统一放在测试服务器的ftp下。线上项目部署在线上服务器，所以没有做从测试ftp拉取项目到线上服务器。这步操作需要自己手动将文件放置到线上服务器的某个路径，本人在线上服务器上创建了一个目录用于存放部署文件，并取名 online_delopy_project。</p>\n<p>说了这么多了，接下里开始写第一个shell 脚本用于部署项目</p>\n<pre><code>#!/bin/bash\nTOMCAT_HOME=/home/xxxx/apache-tomcat-7.0.84 #服务器路径\nBACKUP_HOME=/home/xxxx/yuelinghui-manage #备份文件的路径\nONLINE_PROJECT_HOME=/home/xxxx/online_delopy_project#需要上线部署的文件路径\nPROJECT_VERSION=1.2.2 #项目的版本号\ncd $BACKUP_HOME\nnew_file=yuelinghui_v${PROJECT_VERSION}_date +%Y%m%d #创建备份文件\nmkdir $new_file\ncp -rf $TOMCAT_HOME/webapps/ROOT/ $BACKUP_HOME/$new_file\n${TOMCAT_HOME}/bin/catalina.sh stop || true\nsleep 1s #睡眠一秒 防止服务器没有关闭，就执行删除项目的操作\necho ‘删除服务器中的项目，重新部署’\nrm -rf $TOMCAT_HOME/webapps/ROOT/\necho ‘部署开始。。。。’\ncp -rf $ONLINE_PROJECT_HOME/* $TOMCAT_HOME/webapps/ROOT/\necho ‘启动tomcat。。。。’\n${TOMCAT_HOME}/bin/catalina.sh start || true\nsleep 1s\necho ‘打印启用日志信息。。。。。。’\ntail -10f ${TOMCAT_HOME}/logs/catalina.out\n\ndate +%Y%m%d 获取当前时间\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>这是本人第一次写shell 脚本，如果有一点错误的地方请谅解</p>\n<p>因为平时上线部署项目都是手动进行的，大概分四步:</p>\n<p>1：备份正在运行的项目文件</p>\n<p>2：关闭Tomcat</p>\n<p>3：复制需要部署的项目文件到Tomcat的weapps路径下</p>\n<p>4：启动Tomcat，并打印启动日志信息</p>\n<p>因为我们公司需要上线的项目版本，测试统一放在测试服务器的ftp下。线上项目部署在线上服务器，所以没有做从测试ftp拉取项目到线上服务器。这步操作需要自己手动将文件放置到线上服务器的某个路径，本人在线上服务器上创建了一个目录用于存放部署文件，并取名 online_delopy_project。</p>\n<p>说了这么多了，接下里开始写第一个shell 脚本用于部署项目</p>\n<pre><code>#!/bin/bash\nTOMCAT_HOME=/home/xxxx/apache-tomcat-7.0.84 #服务器路径\nBACKUP_HOME=/home/xxxx/yuelinghui-manage #备份文件的路径\nONLINE_PROJECT_HOME=/home/xxxx/online_delopy_project#需要上线部署的文件路径\nPROJECT_VERSION=1.2.2 #项目的版本号\ncd $BACKUP_HOME\nnew_file=yuelinghui_v${PROJECT_VERSION}_date +%Y%m%d #创建备份文件\nmkdir $new_file\ncp -rf $TOMCAT_HOME/webapps/ROOT/ $BACKUP_HOME/$new_file\n${TOMCAT_HOME}/bin/catalina.sh stop || true\nsleep 1s #睡眠一秒 防止服务器没有关闭，就执行删除项目的操作\necho ‘删除服务器中的项目，重新部署’\nrm -rf $TOMCAT_HOME/webapps/ROOT/\necho ‘部署开始。。。。’\ncp -rf $ONLINE_PROJECT_HOME/* $TOMCAT_HOME/webapps/ROOT/\necho ‘启动tomcat。。。。’\n${TOMCAT_HOME}/bin/catalina.sh start || true\nsleep 1s\necho ‘打印启用日志信息。。。。。。’\ntail -10f ${TOMCAT_HOME}/logs/catalina.out\n\ndate +%Y%m%d 获取当前时间\n</code></pre>"},{"title":"cookie 和 session 的区别","date":"2019-02-26T01:42:48.000Z","_content":"今天我们来讲一下 cookie和 session的一些区别，下面通过几个方面来说明它们之间的差异？\n# 1. 为啥需要session和cookie?\n由于http是无状态的，如果需要追踪用户的记录主要引入session 追踪用户，一般我们常用session 记录用户的登录态，存放用户的一些信息 主要用于用户浏览其他页面时对用户登录态的判断。\n# 2. 存在位置\ncookie 是基于client端 而 session 基于 server端\n# 3.系统安全性\n   由于基于client，存在浏览器上所以可能会导致cookie被窃取导致密码别泄露，出现这种原因主要是在公用网络下操作或者一些不安全的网络。其实这种情况下cookie被窃取也会导致session不安全，因为一般情况下，session key（session ID 用于标识用户，一般情况下 session 有效时间是30分钟和关闭浏览器失去登录态，session 失效主要原因在于session id 失效，重新打开浏览器会重新获取新的session ID） 存储在cookie中，会导致session不安全，还有一种情况就是存放在URL中，这种方式session ID 直接暴露在URL 更不安全，其实安全这问题都是相对的，下面我们讲一下如何使系统变的安全\n\n  1. 保护好自己的cookie，在非安全的网络下，禁止将账号密码存在cookie中\n  2. 通过程序来保障安全，session 记录用户登录的浏览器的 UA 头和ip地址等信息，在一些敏感操作下验证登录时浏览器的 UA 头和ip地址等信息，判断是否一致来确定安全。\n  3. 程序中尽量使用一些框架来管理好session，对session做一个监控，定期清除session信息。\n  4. 确定的关闭方式，当用户退出登录时，清除cookie 中的session ID ，session 存储的内容等信息。\n  5. 尽量将网站从http变成https，这样传输中可以避免cookie被劫持。\n  6. cookie的过期时间不能设置过长，cookie和session 过期时间尽量设置一样，一旦cookie过期了 session ID 也跟着过期，但是有一种情况，session当用户刷新页面，session 会一直续期。虽然前面说的cookie过期了，其实 session ID 还没有过期这样也会导致问题出现。\n  小结：安全问题是相对的，主要你做到上面几点，安全问题自然对你影响不大。\n\n# 4. 存储内容大小\n\n1. 浏览器对cookie数量和cookie存储大小有限制，下面对不同浏览器cookie限制做一个介绍\n| |IE6.0  |IE7.0/8.0  | Opera | Chrome | Safari\n|cookie个数|每个域为20个|每个域为50个|每个域为30个|每个域为53个|没有个数限制|\n|cookie大小|4095个字节|\t4095个字节|4096个字节|4097个字节|4097个字节|\n总之对页面cookie 操作，尽量数量小于20总大小小于4kb，过期时间不能设置过长，避免内容过多导致浏览器自动清除内容把一些有用的字段如 session ID 导致登录态丢失，需要重新登录\n\n2. session 存在服务器中，对小于没有很严格的限制，但是也不能存放过多的内容，主要是服务器内存有限一旦创建过多的内容占据大量的内存，会导致内存不足等情况出现，影响其他操作。\n\n# 5. 总结\nsession和cookie在项目中需要结合使用，了解它们的区别进而能更好的利用它们\n\n参考文档：\n1. [Cookie个数限制及大小](https://my.oschina.net/gaollg/blog/71299)\n2. [正确理解 Session 的安全性](https://www.jianshu.com/p/c4b32eb24894)\n","source":"_posts/cookie-和-session-的区别.md","raw":"---\ntitle: cookie 和 session 的区别\ndate: 2019-02-26 09:42:48\ntags:\n- http\n- 网络安全\n---\n今天我们来讲一下 cookie和 session的一些区别，下面通过几个方面来说明它们之间的差异？\n# 1. 为啥需要session和cookie?\n由于http是无状态的，如果需要追踪用户的记录主要引入session 追踪用户，一般我们常用session 记录用户的登录态，存放用户的一些信息 主要用于用户浏览其他页面时对用户登录态的判断。\n# 2. 存在位置\ncookie 是基于client端 而 session 基于 server端\n# 3.系统安全性\n   由于基于client，存在浏览器上所以可能会导致cookie被窃取导致密码别泄露，出现这种原因主要是在公用网络下操作或者一些不安全的网络。其实这种情况下cookie被窃取也会导致session不安全，因为一般情况下，session key（session ID 用于标识用户，一般情况下 session 有效时间是30分钟和关闭浏览器失去登录态，session 失效主要原因在于session id 失效，重新打开浏览器会重新获取新的session ID） 存储在cookie中，会导致session不安全，还有一种情况就是存放在URL中，这种方式session ID 直接暴露在URL 更不安全，其实安全这问题都是相对的，下面我们讲一下如何使系统变的安全\n\n  1. 保护好自己的cookie，在非安全的网络下，禁止将账号密码存在cookie中\n  2. 通过程序来保障安全，session 记录用户登录的浏览器的 UA 头和ip地址等信息，在一些敏感操作下验证登录时浏览器的 UA 头和ip地址等信息，判断是否一致来确定安全。\n  3. 程序中尽量使用一些框架来管理好session，对session做一个监控，定期清除session信息。\n  4. 确定的关闭方式，当用户退出登录时，清除cookie 中的session ID ，session 存储的内容等信息。\n  5. 尽量将网站从http变成https，这样传输中可以避免cookie被劫持。\n  6. cookie的过期时间不能设置过长，cookie和session 过期时间尽量设置一样，一旦cookie过期了 session ID 也跟着过期，但是有一种情况，session当用户刷新页面，session 会一直续期。虽然前面说的cookie过期了，其实 session ID 还没有过期这样也会导致问题出现。\n  小结：安全问题是相对的，主要你做到上面几点，安全问题自然对你影响不大。\n\n# 4. 存储内容大小\n\n1. 浏览器对cookie数量和cookie存储大小有限制，下面对不同浏览器cookie限制做一个介绍\n| |IE6.0  |IE7.0/8.0  | Opera | Chrome | Safari\n|cookie个数|每个域为20个|每个域为50个|每个域为30个|每个域为53个|没有个数限制|\n|cookie大小|4095个字节|\t4095个字节|4096个字节|4097个字节|4097个字节|\n总之对页面cookie 操作，尽量数量小于20总大小小于4kb，过期时间不能设置过长，避免内容过多导致浏览器自动清除内容把一些有用的字段如 session ID 导致登录态丢失，需要重新登录\n\n2. session 存在服务器中，对小于没有很严格的限制，但是也不能存放过多的内容，主要是服务器内存有限一旦创建过多的内容占据大量的内存，会导致内存不足等情况出现，影响其他操作。\n\n# 5. 总结\nsession和cookie在项目中需要结合使用，了解它们的区别进而能更好的利用它们\n\n参考文档：\n1. [Cookie个数限制及大小](https://my.oschina.net/gaollg/blog/71299)\n2. [正确理解 Session 的安全性](https://www.jianshu.com/p/c4b32eb24894)\n","slug":"cookie-和-session-的区别","published":1,"updated":"2019-07-14T03:11:26.957Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8mkctu5000a4osxbkje9g54","content":"<p>今天我们来讲一下 cookie和 session的一些区别，下面通过几个方面来说明它们之间的差异？</p>\n<h1 id=\"1-为啥需要session和cookie\"><a href=\"#1-为啥需要session和cookie\" class=\"headerlink\" title=\"1. 为啥需要session和cookie?\"></a>1. 为啥需要session和cookie?</h1><p>由于http是无状态的，如果需要追踪用户的记录主要引入session 追踪用户，一般我们常用session 记录用户的登录态，存放用户的一些信息 主要用于用户浏览其他页面时对用户登录态的判断。</p>\n<h1 id=\"2-存在位置\"><a href=\"#2-存在位置\" class=\"headerlink\" title=\"2. 存在位置\"></a>2. 存在位置</h1><p>cookie 是基于client端 而 session 基于 server端</p>\n<h1 id=\"3-系统安全性\"><a href=\"#3-系统安全性\" class=\"headerlink\" title=\"3.系统安全性\"></a>3.系统安全性</h1><p>   由于基于client，存在浏览器上所以可能会导致cookie被窃取导致密码别泄露，出现这种原因主要是在公用网络下操作或者一些不安全的网络。其实这种情况下cookie被窃取也会导致session不安全，因为一般情况下，session key（session ID 用于标识用户，一般情况下 session 有效时间是30分钟和关闭浏览器失去登录态，session 失效主要原因在于session id 失效，重新打开浏览器会重新获取新的session ID） 存储在cookie中，会导致session不安全，还有一种情况就是存放在URL中，这种方式session ID 直接暴露在URL 更不安全，其实安全这问题都是相对的，下面我们讲一下如何使系统变的安全</p>\n<ol>\n<li>保护好自己的cookie，在非安全的网络下，禁止将账号密码存在cookie中</li>\n<li>通过程序来保障安全，session 记录用户登录的浏览器的 UA 头和ip地址等信息，在一些敏感操作下验证登录时浏览器的 UA 头和ip地址等信息，判断是否一致来确定安全。</li>\n<li>程序中尽量使用一些框架来管理好session，对session做一个监控，定期清除session信息。</li>\n<li>确定的关闭方式，当用户退出登录时，清除cookie 中的session ID ，session 存储的内容等信息。</li>\n<li>尽量将网站从http变成https，这样传输中可以避免cookie被劫持。</li>\n<li>cookie的过期时间不能设置过长，cookie和session 过期时间尽量设置一样，一旦cookie过期了 session ID 也跟着过期，但是有一种情况，session当用户刷新页面，session 会一直续期。虽然前面说的cookie过期了，其实 session ID 还没有过期这样也会导致问题出现。<br>小结：安全问题是相对的，主要你做到上面几点，安全问题自然对你影响不大。</li>\n</ol>\n<h1 id=\"4-存储内容大小\"><a href=\"#4-存储内容大小\" class=\"headerlink\" title=\"4. 存储内容大小\"></a>4. 存储内容大小</h1><ol>\n<li><p>浏览器对cookie数量和cookie存储大小有限制，下面对不同浏览器cookie限制做一个介绍<br>| |IE6.0  |IE7.0/8.0  | Opera | Chrome | Safari<br>|cookie个数|每个域为20个|每个域为50个|每个域为30个|每个域为53个|没有个数限制|<br>|cookie大小|4095个字节|    4095个字节|4096个字节|4097个字节|4097个字节|<br>总之对页面cookie 操作，尽量数量小于20总大小小于4kb，过期时间不能设置过长，避免内容过多导致浏览器自动清除内容把一些有用的字段如 session ID 导致登录态丢失，需要重新登录</p>\n</li>\n<li><p>session 存在服务器中，对小于没有很严格的限制，但是也不能存放过多的内容，主要是服务器内存有限一旦创建过多的内容占据大量的内存，会导致内存不足等情况出现，影响其他操作。</p>\n</li>\n</ol>\n<h1 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5. 总结\"></a>5. 总结</h1><p>session和cookie在项目中需要结合使用，了解它们的区别进而能更好的利用它们</p>\n<p>参考文档：</p>\n<ol>\n<li><a href=\"https://my.oschina.net/gaollg/blog/71299\" target=\"_blank\" rel=\"noopener\">Cookie个数限制及大小</a></li>\n<li><a href=\"https://www.jianshu.com/p/c4b32eb24894\" target=\"_blank\" rel=\"noopener\">正确理解 Session 的安全性</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>今天我们来讲一下 cookie和 session的一些区别，下面通过几个方面来说明它们之间的差异？</p>\n<h1 id=\"1-为啥需要session和cookie\"><a href=\"#1-为啥需要session和cookie\" class=\"headerlink\" title=\"1. 为啥需要session和cookie?\"></a>1. 为啥需要session和cookie?</h1><p>由于http是无状态的，如果需要追踪用户的记录主要引入session 追踪用户，一般我们常用session 记录用户的登录态，存放用户的一些信息 主要用于用户浏览其他页面时对用户登录态的判断。</p>\n<h1 id=\"2-存在位置\"><a href=\"#2-存在位置\" class=\"headerlink\" title=\"2. 存在位置\"></a>2. 存在位置</h1><p>cookie 是基于client端 而 session 基于 server端</p>\n<h1 id=\"3-系统安全性\"><a href=\"#3-系统安全性\" class=\"headerlink\" title=\"3.系统安全性\"></a>3.系统安全性</h1><p>   由于基于client，存在浏览器上所以可能会导致cookie被窃取导致密码别泄露，出现这种原因主要是在公用网络下操作或者一些不安全的网络。其实这种情况下cookie被窃取也会导致session不安全，因为一般情况下，session key（session ID 用于标识用户，一般情况下 session 有效时间是30分钟和关闭浏览器失去登录态，session 失效主要原因在于session id 失效，重新打开浏览器会重新获取新的session ID） 存储在cookie中，会导致session不安全，还有一种情况就是存放在URL中，这种方式session ID 直接暴露在URL 更不安全，其实安全这问题都是相对的，下面我们讲一下如何使系统变的安全</p>\n<ol>\n<li>保护好自己的cookie，在非安全的网络下，禁止将账号密码存在cookie中</li>\n<li>通过程序来保障安全，session 记录用户登录的浏览器的 UA 头和ip地址等信息，在一些敏感操作下验证登录时浏览器的 UA 头和ip地址等信息，判断是否一致来确定安全。</li>\n<li>程序中尽量使用一些框架来管理好session，对session做一个监控，定期清除session信息。</li>\n<li>确定的关闭方式，当用户退出登录时，清除cookie 中的session ID ，session 存储的内容等信息。</li>\n<li>尽量将网站从http变成https，这样传输中可以避免cookie被劫持。</li>\n<li>cookie的过期时间不能设置过长，cookie和session 过期时间尽量设置一样，一旦cookie过期了 session ID 也跟着过期，但是有一种情况，session当用户刷新页面，session 会一直续期。虽然前面说的cookie过期了，其实 session ID 还没有过期这样也会导致问题出现。<br>小结：安全问题是相对的，主要你做到上面几点，安全问题自然对你影响不大。</li>\n</ol>\n<h1 id=\"4-存储内容大小\"><a href=\"#4-存储内容大小\" class=\"headerlink\" title=\"4. 存储内容大小\"></a>4. 存储内容大小</h1><ol>\n<li><p>浏览器对cookie数量和cookie存储大小有限制，下面对不同浏览器cookie限制做一个介绍<br>| |IE6.0  |IE7.0/8.0  | Opera | Chrome | Safari<br>|cookie个数|每个域为20个|每个域为50个|每个域为30个|每个域为53个|没有个数限制|<br>|cookie大小|4095个字节|    4095个字节|4096个字节|4097个字节|4097个字节|<br>总之对页面cookie 操作，尽量数量小于20总大小小于4kb，过期时间不能设置过长，避免内容过多导致浏览器自动清除内容把一些有用的字段如 session ID 导致登录态丢失，需要重新登录</p>\n</li>\n<li><p>session 存在服务器中，对小于没有很严格的限制，但是也不能存放过多的内容，主要是服务器内存有限一旦创建过多的内容占据大量的内存，会导致内存不足等情况出现，影响其他操作。</p>\n</li>\n</ol>\n<h1 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5. 总结\"></a>5. 总结</h1><p>session和cookie在项目中需要结合使用，了解它们的区别进而能更好的利用它们</p>\n<p>参考文档：</p>\n<ol>\n<li><a href=\"https://my.oschina.net/gaollg/blog/71299\" target=\"_blank\" rel=\"noopener\">Cookie个数限制及大小</a></li>\n<li><a href=\"https://www.jianshu.com/p/c4b32eb24894\" target=\"_blank\" rel=\"noopener\">正确理解 Session 的安全性</a></li>\n</ol>\n"},{"title":"dubbo 学习笔记（一）","date":"2019-03-21T07:38:18.000Z","_content":"\n# 1. dubbo背景\n\n随着因特网的快速发展，web 应用的规模再不断的扩大，最后，我们发现传统的单机模式已经不能满足这种状况了，所以分布式服务架构和流量计算架构势在必行，迫切需要一个治理系统来确保架构的有序演进。\n\n![](https://img.mupaie.com/1553154620.jpg)\n\n* Monolithic architecture\n\n当流量比较少的时候，把所有的功能点都聚集到单个程序上减少部署的节点和成本。这个时候，数据访问框架（ORM）成了简化CRUD工作负载的关键。\n\n* Vertical architecture\n\n当流量开始增多的时候，上述的单机应用实例不能很好的加速访问量难题，有一种方法为了提高效率可以将单片分割成离散的应用。此时，web框架（mvc）成为了加速前端页面开发的关键。\n\n* Distributed service architecture\n\n当上述的垂直应用越来越多的时候，应用之间必然会有一些是相互联系的。一些核心业务代码拆成单独的服务，这些服务逐步形成稳定的服务中心，这种方法前端程序能够更快了应对需求的变化。此时，分布式服务框架（RPC）能够更好的解决业务的集成和重用\n\n* Flow computing architecture\n\n\n\n\n\n\n\n# 2. dubbo实现原理\n","source":"_posts/dubbo-学习笔记（一）.md","raw":"---\ntitle: dubbo 学习笔记（一）\ndate: 2019-03-21 15:38:18\ntags:\n  - dubbo\n---\n\n# 1. dubbo背景\n\n随着因特网的快速发展，web 应用的规模再不断的扩大，最后，我们发现传统的单机模式已经不能满足这种状况了，所以分布式服务架构和流量计算架构势在必行，迫切需要一个治理系统来确保架构的有序演进。\n\n![](https://img.mupaie.com/1553154620.jpg)\n\n* Monolithic architecture\n\n当流量比较少的时候，把所有的功能点都聚集到单个程序上减少部署的节点和成本。这个时候，数据访问框架（ORM）成了简化CRUD工作负载的关键。\n\n* Vertical architecture\n\n当流量开始增多的时候，上述的单机应用实例不能很好的加速访问量难题，有一种方法为了提高效率可以将单片分割成离散的应用。此时，web框架（mvc）成为了加速前端页面开发的关键。\n\n* Distributed service architecture\n\n当上述的垂直应用越来越多的时候，应用之间必然会有一些是相互联系的。一些核心业务代码拆成单独的服务，这些服务逐步形成稳定的服务中心，这种方法前端程序能够更快了应对需求的变化。此时，分布式服务框架（RPC）能够更好的解决业务的集成和重用\n\n* Flow computing architecture\n\n\n\n\n\n\n\n# 2. dubbo实现原理\n","slug":"dubbo-学习笔记（一）","published":1,"updated":"2019-07-14T04:16:44.408Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8mkctu7000d4osx99yl6bdt","content":"<h1 id=\"1-dubbo背景\"><a href=\"#1-dubbo背景\" class=\"headerlink\" title=\"1. dubbo背景\"></a>1. dubbo背景</h1><p>随着因特网的快速发展，web 应用的规模再不断的扩大，最后，我们发现传统的单机模式已经不能满足这种状况了，所以分布式服务架构和流量计算架构势在必行，迫切需要一个治理系统来确保架构的有序演进。</p>\n<p><img src=\"https://img.mupaie.com/1553154620.jpg\" alt=\"\"></p>\n<ul>\n<li>Monolithic architecture</li>\n</ul>\n<p>当流量比较少的时候，把所有的功能点都聚集到单个程序上减少部署的节点和成本。这个时候，数据访问框架（ORM）成了简化CRUD工作负载的关键。</p>\n<ul>\n<li>Vertical architecture</li>\n</ul>\n<p>当流量开始增多的时候，上述的单机应用实例不能很好的加速访问量难题，有一种方法为了提高效率可以将单片分割成离散的应用。此时，web框架（mvc）成为了加速前端页面开发的关键。</p>\n<ul>\n<li>Distributed service architecture</li>\n</ul>\n<p>当上述的垂直应用越来越多的时候，应用之间必然会有一些是相互联系的。一些核心业务代码拆成单独的服务，这些服务逐步形成稳定的服务中心，这种方法前端程序能够更快了应对需求的变化。此时，分布式服务框架（RPC）能够更好的解决业务的集成和重用</p>\n<ul>\n<li>Flow computing architecture</li>\n</ul>\n<h1 id=\"2-dubbo实现原理\"><a href=\"#2-dubbo实现原理\" class=\"headerlink\" title=\"2. dubbo实现原理\"></a>2. dubbo实现原理</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-dubbo背景\"><a href=\"#1-dubbo背景\" class=\"headerlink\" title=\"1. dubbo背景\"></a>1. dubbo背景</h1><p>随着因特网的快速发展，web 应用的规模再不断的扩大，最后，我们发现传统的单机模式已经不能满足这种状况了，所以分布式服务架构和流量计算架构势在必行，迫切需要一个治理系统来确保架构的有序演进。</p>\n<p><img src=\"https://img.mupaie.com/1553154620.jpg\" alt=\"\"></p>\n<ul>\n<li>Monolithic architecture</li>\n</ul>\n<p>当流量比较少的时候，把所有的功能点都聚集到单个程序上减少部署的节点和成本。这个时候，数据访问框架（ORM）成了简化CRUD工作负载的关键。</p>\n<ul>\n<li>Vertical architecture</li>\n</ul>\n<p>当流量开始增多的时候，上述的单机应用实例不能很好的加速访问量难题，有一种方法为了提高效率可以将单片分割成离散的应用。此时，web框架（mvc）成为了加速前端页面开发的关键。</p>\n<ul>\n<li>Distributed service architecture</li>\n</ul>\n<p>当上述的垂直应用越来越多的时候，应用之间必然会有一些是相互联系的。一些核心业务代码拆成单独的服务，这些服务逐步形成稳定的服务中心，这种方法前端程序能够更快了应对需求的变化。此时，分布式服务框架（RPC）能够更好的解决业务的集成和重用</p>\n<ul>\n<li>Flow computing architecture</li>\n</ul>\n<h1 id=\"2-dubbo实现原理\"><a href=\"#2-dubbo实现原理\" class=\"headerlink\" title=\"2. dubbo实现原理\"></a>2. dubbo实现原理</h1>"},{"title":"markdown的使用笔记","date":"2019-02-26T03:28:10.000Z","_content":"由于最近写博客需要，了解到一种轻量级标记语言-markdown。下面来说一下关于一些markdown的知识：\n# 1. markdown是什么？\nMarkdown是一种轻量级标记语言，创始人为约翰·格鲁伯（英语：John Gruber）。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档”。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。\n# 2. markdown的历史发展？\nJohn Gruber 在 2004 年创造了 Markdown 语言，在语法上有很大一部分是跟亚伦·斯沃茨（Aaron Swartz）共同合作的。这个语言的目的是希望大家使用“易于阅读、易于撰写的纯文字格式，并选择性的转换成有效的XHTML（或是HTML）”。 其中最重要的设计是可读性，也就是说这个语言应该要能直接在字面上的被阅读，而不用被一些格式化指令标记（像是RTF与HTML）。 因此，它是现行电子邮件标记格式的惯例，虽然它也借鉴了很多早期的标记语言，如：Setext、Texile、reStructuredText。Gruber也编写了的Perl脚本：Markdown.pl，用于把markdown语法编写的内容转换成有效的、结构良好的XHTML或HTML内容，并将左尖括号<和&号替换成它们各自的字符实体引用。它可以用作单独的脚本，Blosxom和Movable Type的插件又或者BBEdit的文本过滤器。Markdown也已经被其他人用Perl和别的编程语言重新实现，其中一个Perl模块放在了CPAN(Text::Markdown)上。它基于一个BSD风格的许可证分发并可以作为几个内容管理系统的插件。\n# 3. markdown能用来做什么？\n由于Markdown的轻量化、易读易写特性，并且对于图片，图表、数学式都有支持，当前许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge等。甚至Markdown能被使用来撰写电子书。\n# 4. markdown的一些语法和平时书写的注意点？\n# 4.1. 标题\n书写标题的时候，我们只需要在文本前面加上『# 』即可创建一级标题，如果想创建二级，三级，或者更多只需要增加『# 』的个数即可。下面展示一下效果：\n\t\t# 一级标题\n\t\t## 二级标题\n\t\t### 三级标题\n\t\t#### 四级标题\n\t\t##### 五级标题\n\t\t###### 六级标题\n效果如下图：\n![](https://img.mupaie.com/20190226100452277.png)\n# 4.2. 引用\n\n在需要的整个段落第一行最前面加上『>』即可：\n\t>在这里插入图片描述 双通道（英语：Dual-channel）是一种能够让计算机性能增加的技术\n\t效果如下图：\n\t![在这里插入图片描述](https://img.mupaie.com/20190226101026545.png)\n区块引用还可以嵌套使用\n\t>  在这里插入图片描述 双通道（英语：Dual-channel）是一种能够让计算机性能增加的技术\n\t>  > 在这里插入图片描述 双通道（英语：Dual-channel）是一种能够让计算机性能增加的技术\n\t>  > > 在这里插入图片描述 双通道（英语：Dual-channel）是一种能够让计算机性能增加的技术\n\t![在这里插入图片描述](https://img.mupaie.com/20190226101213185.png)\n\t不仅可以嵌套使用，还可以再引用中加入标题，列表等元素：\n\t>  ## 在这里插入图片描述 双通道（英语：Dual-channel）是一种能够让计算机性能增加的技术\n\t>  > 1. 在这里插入图片描述 双通道（英语：Dual-channel）是一种能够让计算机性能增加的技术\n\t>  > 2.  在这里插入图片描述 双通道（英语：Dual-channel）是一种能够让计算机性能增加的技术\n\t效果如下图：\n\t![在这里插入图片描述](https://img.mupaie.com/20190226101413977.png)\n# 4.3. 列表\n列表在http中有无序和有序列表，markdown也有如下：\n __无序列表__ :使用星号 、加号或是减号来作为标记\n\t- test\n\t- test\n\t- test\n效果如下图：\n![在这里插入图片描述](https://img.mupaie.com/20190226102026437.png)\n有序列表则是在文本前面加上数字和小数点\n\t1. test\n\t2. test\n\t3. test\n效果如下图：\n![在这里插入图片描述](https://img.mupaie.com/20190226102236789.png)\n在列表中如何使用引用？\n\t*  在这里插入图片描述 双通道（英语：Dual-channel）是一种能够让计算机性能增加的技术\n\t\t> 在这里插入图片描述 双通道（英语：Dual-channel）是一种能够让计算机性能增加的技术\n\t\t> 在这里插入图片描述 双通道（英语：Dual-channel）是一种能够让计算机性能增加的技术\n在列表栏下，引用的文本需要缩进\n效果如下图：\n![在这里插入图片描述](https://img.mupaie.com/20190226102633553.png)\n代办列表：表示列表数据是否被勾选\n\t- [ ] 不勾选\n\t- [x] 勾选\n效果如下图：\n![在这里插入图片描述](https://img.mupaie.com/20190226102826784.png)\n# 4.4. 代码块\n只要把代码块包裹在“` 之间，在围栏式代码块中，你可以指定一个可选的语言标识符，然后我们就可以为它启用语法着色了：\n\n\t```ruby\n\t\trequire 'redcarpet'\n\t\tmarkdown = Redcarpet.new(\"Hello World!\")\n\t\tputs markdown.to_html\n\t```\n\n效果如下图：\n\t![在这里插入图片描述](https://img.mupaie.com/20190226103542307.png)\n# 4.5. 强调\n在Markdown中，可以使用 * 和  _  来表示斜体和加粗。\n单个 * 和 _ 修饰，表示斜体，双个 * 和 _ 修饰表示粗体\n\n\t*Markdown*\n\t_Markdown_\n\t**Markdown**\n\t__Markdown__\n效果如下：\n![在这里插入图片描述](https://img.mupaie.com/20190226104023173.png)\n# 4.6. 链接\n\n\t文字链接 [文字描述](地址)\n\t图片链接 ![文字描述](地址)\n效果如下：\n![在这里插入图片描述](https://img.mupaie.com/20190226104232855.png)\n还有一些表格，一些工程图（流程图，时序图等）都可以使用markdown表现出来，我这里就不一一介绍了，具体参考[Markdown 语法介绍](https://coding.net/help/doc/project/markdown.html#i-6)\n# 4.7. 换行：\n&emsp;&emsp;1.使用两个以上的空格加回车\n&emsp;&emsp;2.使用http标签 \\<br>\n# 4.8. 首行缩进\n\t&emsp;&emsp;1. 半角空格 “\\&ensp;”\n\t&emsp;&emsp;2. 全角空格 “\\&emsp;”\n\t&emsp;&emsp;3. 不换行空格 “\\&nbsp;”\n# 4.9. 文本加颜色\nmarkdown 可以通过像html一样，可以通过标签样式让文本有一定的格式。\n\n\t<font color=\"red\">test</font>\n\n效果如下：\n![在这里插入图片描述](https://img.mupaie.com/20190226111339130.png)\n具体需要实现什么样式，参考[css文档](http://www.runoob.com/css/css-text.html)\n\n# 5. 总结\n今天简单介绍了markdown，并通过几个例子来展示具体用法。其实markdown还有很多内容，所以需要大家在以后使用中多积累多完善，这样才能更好的使用和掌markdown。\n\n参考文档：\n[Markdown 语法介绍](https://coding.net/help/doc/project/markdown.html#i-6)\n[Markdown使用技巧总结——字体，颜色，字号，背景，首行缩进等](https://blog.csdn.net/u010177286/article/details/50358720)\n[全角半角 && 6种空白空格的区别](https://blog.csdn.net/bao19901210/article/details/54625703)\n[维基百科 markdown介绍](https://zh.wikipedia.org/wiki/Markdown)\n\n\n\n","source":"_posts/markdown的使用笔记.md","raw":"---\ntitle: markdown的使用笔记\ndate: 2019-02-26 11:28:10\ntags:\n- markdown\n- http\n---\n由于最近写博客需要，了解到一种轻量级标记语言-markdown。下面来说一下关于一些markdown的知识：\n# 1. markdown是什么？\nMarkdown是一种轻量级标记语言，创始人为约翰·格鲁伯（英语：John Gruber）。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档”。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。\n# 2. markdown的历史发展？\nJohn Gruber 在 2004 年创造了 Markdown 语言，在语法上有很大一部分是跟亚伦·斯沃茨（Aaron Swartz）共同合作的。这个语言的目的是希望大家使用“易于阅读、易于撰写的纯文字格式，并选择性的转换成有效的XHTML（或是HTML）”。 其中最重要的设计是可读性，也就是说这个语言应该要能直接在字面上的被阅读，而不用被一些格式化指令标记（像是RTF与HTML）。 因此，它是现行电子邮件标记格式的惯例，虽然它也借鉴了很多早期的标记语言，如：Setext、Texile、reStructuredText。Gruber也编写了的Perl脚本：Markdown.pl，用于把markdown语法编写的内容转换成有效的、结构良好的XHTML或HTML内容，并将左尖括号<和&号替换成它们各自的字符实体引用。它可以用作单独的脚本，Blosxom和Movable Type的插件又或者BBEdit的文本过滤器。Markdown也已经被其他人用Perl和别的编程语言重新实现，其中一个Perl模块放在了CPAN(Text::Markdown)上。它基于一个BSD风格的许可证分发并可以作为几个内容管理系统的插件。\n# 3. markdown能用来做什么？\n由于Markdown的轻量化、易读易写特性，并且对于图片，图表、数学式都有支持，当前许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge等。甚至Markdown能被使用来撰写电子书。\n# 4. markdown的一些语法和平时书写的注意点？\n# 4.1. 标题\n书写标题的时候，我们只需要在文本前面加上『# 』即可创建一级标题，如果想创建二级，三级，或者更多只需要增加『# 』的个数即可。下面展示一下效果：\n\t\t# 一级标题\n\t\t## 二级标题\n\t\t### 三级标题\n\t\t#### 四级标题\n\t\t##### 五级标题\n\t\t###### 六级标题\n效果如下图：\n![](https://img.mupaie.com/20190226100452277.png)\n# 4.2. 引用\n\n在需要的整个段落第一行最前面加上『>』即可：\n\t>在这里插入图片描述 双通道（英语：Dual-channel）是一种能够让计算机性能增加的技术\n\t效果如下图：\n\t![在这里插入图片描述](https://img.mupaie.com/20190226101026545.png)\n区块引用还可以嵌套使用\n\t>  在这里插入图片描述 双通道（英语：Dual-channel）是一种能够让计算机性能增加的技术\n\t>  > 在这里插入图片描述 双通道（英语：Dual-channel）是一种能够让计算机性能增加的技术\n\t>  > > 在这里插入图片描述 双通道（英语：Dual-channel）是一种能够让计算机性能增加的技术\n\t![在这里插入图片描述](https://img.mupaie.com/20190226101213185.png)\n\t不仅可以嵌套使用，还可以再引用中加入标题，列表等元素：\n\t>  ## 在这里插入图片描述 双通道（英语：Dual-channel）是一种能够让计算机性能增加的技术\n\t>  > 1. 在这里插入图片描述 双通道（英语：Dual-channel）是一种能够让计算机性能增加的技术\n\t>  > 2.  在这里插入图片描述 双通道（英语：Dual-channel）是一种能够让计算机性能增加的技术\n\t效果如下图：\n\t![在这里插入图片描述](https://img.mupaie.com/20190226101413977.png)\n# 4.3. 列表\n列表在http中有无序和有序列表，markdown也有如下：\n __无序列表__ :使用星号 、加号或是减号来作为标记\n\t- test\n\t- test\n\t- test\n效果如下图：\n![在这里插入图片描述](https://img.mupaie.com/20190226102026437.png)\n有序列表则是在文本前面加上数字和小数点\n\t1. test\n\t2. test\n\t3. test\n效果如下图：\n![在这里插入图片描述](https://img.mupaie.com/20190226102236789.png)\n在列表中如何使用引用？\n\t*  在这里插入图片描述 双通道（英语：Dual-channel）是一种能够让计算机性能增加的技术\n\t\t> 在这里插入图片描述 双通道（英语：Dual-channel）是一种能够让计算机性能增加的技术\n\t\t> 在这里插入图片描述 双通道（英语：Dual-channel）是一种能够让计算机性能增加的技术\n在列表栏下，引用的文本需要缩进\n效果如下图：\n![在这里插入图片描述](https://img.mupaie.com/20190226102633553.png)\n代办列表：表示列表数据是否被勾选\n\t- [ ] 不勾选\n\t- [x] 勾选\n效果如下图：\n![在这里插入图片描述](https://img.mupaie.com/20190226102826784.png)\n# 4.4. 代码块\n只要把代码块包裹在“` 之间，在围栏式代码块中，你可以指定一个可选的语言标识符，然后我们就可以为它启用语法着色了：\n\n\t```ruby\n\t\trequire 'redcarpet'\n\t\tmarkdown = Redcarpet.new(\"Hello World!\")\n\t\tputs markdown.to_html\n\t```\n\n效果如下图：\n\t![在这里插入图片描述](https://img.mupaie.com/20190226103542307.png)\n# 4.5. 强调\n在Markdown中，可以使用 * 和  _  来表示斜体和加粗。\n单个 * 和 _ 修饰，表示斜体，双个 * 和 _ 修饰表示粗体\n\n\t*Markdown*\n\t_Markdown_\n\t**Markdown**\n\t__Markdown__\n效果如下：\n![在这里插入图片描述](https://img.mupaie.com/20190226104023173.png)\n# 4.6. 链接\n\n\t文字链接 [文字描述](地址)\n\t图片链接 ![文字描述](地址)\n效果如下：\n![在这里插入图片描述](https://img.mupaie.com/20190226104232855.png)\n还有一些表格，一些工程图（流程图，时序图等）都可以使用markdown表现出来，我这里就不一一介绍了，具体参考[Markdown 语法介绍](https://coding.net/help/doc/project/markdown.html#i-6)\n# 4.7. 换行：\n&emsp;&emsp;1.使用两个以上的空格加回车\n&emsp;&emsp;2.使用http标签 \\<br>\n# 4.8. 首行缩进\n\t&emsp;&emsp;1. 半角空格 “\\&ensp;”\n\t&emsp;&emsp;2. 全角空格 “\\&emsp;”\n\t&emsp;&emsp;3. 不换行空格 “\\&nbsp;”\n# 4.9. 文本加颜色\nmarkdown 可以通过像html一样，可以通过标签样式让文本有一定的格式。\n\n\t<font color=\"red\">test</font>\n\n效果如下：\n![在这里插入图片描述](https://img.mupaie.com/20190226111339130.png)\n具体需要实现什么样式，参考[css文档](http://www.runoob.com/css/css-text.html)\n\n# 5. 总结\n今天简单介绍了markdown，并通过几个例子来展示具体用法。其实markdown还有很多内容，所以需要大家在以后使用中多积累多完善，这样才能更好的使用和掌markdown。\n\n参考文档：\n[Markdown 语法介绍](https://coding.net/help/doc/project/markdown.html#i-6)\n[Markdown使用技巧总结——字体，颜色，字号，背景，首行缩进等](https://blog.csdn.net/u010177286/article/details/50358720)\n[全角半角 && 6种空白空格的区别](https://blog.csdn.net/bao19901210/article/details/54625703)\n[维基百科 markdown介绍](https://zh.wikipedia.org/wiki/Markdown)\n\n\n\n","slug":"markdown的使用笔记","published":1,"updated":"2019-07-14T05:09:35.732Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8mkctu8000e4osx72vr3jfp","content":"<p>由于最近写博客需要，了解到一种轻量级标记语言-markdown。下面来说一下关于一些markdown的知识：</p>\n<h1 id=\"1-markdown是什么？\"><a href=\"#1-markdown是什么？\" class=\"headerlink\" title=\"1. markdown是什么？\"></a>1. markdown是什么？</h1><p>Markdown是一种轻量级标记语言，创始人为约翰·格鲁伯（英语：John Gruber）。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档”。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。</p>\n<h1 id=\"2-markdown的历史发展？\"><a href=\"#2-markdown的历史发展？\" class=\"headerlink\" title=\"2. markdown的历史发展？\"></a>2. markdown的历史发展？</h1><p>John Gruber 在 2004 年创造了 Markdown 语言，在语法上有很大一部分是跟亚伦·斯沃茨（Aaron Swartz）共同合作的。这个语言的目的是希望大家使用“易于阅读、易于撰写的纯文字格式，并选择性的转换成有效的XHTML（或是HTML）”。 其中最重要的设计是可读性，也就是说这个语言应该要能直接在字面上的被阅读，而不用被一些格式化指令标记（像是RTF与HTML）。 因此，它是现行电子邮件标记格式的惯例，虽然它也借鉴了很多早期的标记语言，如：Setext、Texile、reStructuredText。Gruber也编写了的Perl脚本：Markdown.pl，用于把markdown语法编写的内容转换成有效的、结构良好的XHTML或HTML内容，并将左尖括号&lt;和&amp;号替换成它们各自的字符实体引用。它可以用作单独的脚本，Blosxom和Movable Type的插件又或者BBEdit的文本过滤器。Markdown也已经被其他人用Perl和别的编程语言重新实现，其中一个Perl模块放在了CPAN(Text::Markdown)上。它基于一个BSD风格的许可证分发并可以作为几个内容管理系统的插件。</p>\n<h1 id=\"3-markdown能用来做什么？\"><a href=\"#3-markdown能用来做什么？\" class=\"headerlink\" title=\"3. markdown能用来做什么？\"></a>3. markdown能用来做什么？</h1><p>由于Markdown的轻量化、易读易写特性，并且对于图片，图表、数学式都有支持，当前许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge等。甚至Markdown能被使用来撰写电子书。</p>\n<h1 id=\"4-markdown的一些语法和平时书写的注意点？\"><a href=\"#4-markdown的一些语法和平时书写的注意点？\" class=\"headerlink\" title=\"4. markdown的一些语法和平时书写的注意点？\"></a>4. markdown的一些语法和平时书写的注意点？</h1><h1 id=\"4-1-标题\"><a href=\"#4-1-标题\" class=\"headerlink\" title=\"4.1. 标题\"></a>4.1. 标题</h1><p>书写标题的时候，我们只需要在文本前面加上『# 』即可创建一级标题，如果想创建二级，三级，或者更多只需要增加『# 』的个数即可。下面展示一下效果：</p>\n<pre><code># 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n</code></pre><p>效果如下图：<br><img src=\"https://img.mupaie.com/20190226100452277.png\" alt=\"\"></p>\n<h1 id=\"4-2-引用\"><a href=\"#4-2-引用\" class=\"headerlink\" title=\"4.2. 引用\"></a>4.2. 引用</h1><p>在需要的整个段落第一行最前面加上『&gt;』即可：<br>    &gt;在这里插入图片描述 双通道（英语：Dual-channel）是一种能够让计算机性能增加的技术<br>    效果如下图：<br>    <img src=\"https://img.mupaie.com/20190226101026545.png\" alt=\"在这里插入图片描述\"><br>区块引用还可以嵌套使用<br>    &gt;  在这里插入图片描述 双通道（英语：Dual-channel）是一种能够让计算机性能增加的技术<br>    &gt;  &gt; 在这里插入图片描述 双通道（英语：Dual-channel）是一种能够让计算机性能增加的技术<br>    &gt;  &gt; &gt; 在这里插入图片描述 双通道（英语：Dual-channel）是一种能够让计算机性能增加的技术<br>    <img src=\"https://img.mupaie.com/20190226101213185.png\" alt=\"在这里插入图片描述\"><br>    不仅可以嵌套使用，还可以再引用中加入标题，列表等元素：<br>    &gt;  ## 在这里插入图片描述 双通道（英语：Dual-channel）是一种能够让计算机性能增加的技术<br>    &gt;  &gt; 1. 在这里插入图片描述 双通道（英语：Dual-channel）是一种能够让计算机性能增加的技术<br>    &gt;  &gt; 2.  在这里插入图片描述 双通道（英语：Dual-channel）是一种能够让计算机性能增加的技术<br>    效果如下图：<br>    <img src=\"https://img.mupaie.com/20190226101413977.png\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"4-3-列表\"><a href=\"#4-3-列表\" class=\"headerlink\" title=\"4.3. 列表\"></a>4.3. 列表</h1><p>列表在http中有无序和有序列表，markdown也有如下：<br> <strong>无序列表</strong> :使用星号 、加号或是减号来作为标记</p>\n<pre><code>- test\n- test\n- test\n</code></pre><p>效果如下图：<br><img src=\"https://img.mupaie.com/20190226102026437.png\" alt=\"在这里插入图片描述\"><br>有序列表则是在文本前面加上数字和小数点</p>\n<pre><code>1. test\n2. test\n3. test\n</code></pre><p>效果如下图：<br><img src=\"https://img.mupaie.com/20190226102236789.png\" alt=\"在这里插入图片描述\"><br>在列表中如何使用引用？</p>\n<pre><code>*  在这里插入图片描述 双通道（英语：Dual-channel）是一种能够让计算机性能增加的技术\n    &gt; 在这里插入图片描述 双通道（英语：Dual-channel）是一种能够让计算机性能增加的技术\n    &gt; 在这里插入图片描述 双通道（英语：Dual-channel）是一种能够让计算机性能增加的技术\n</code></pre><p>在列表栏下，引用的文本需要缩进<br>效果如下图：<br><img src=\"https://img.mupaie.com/20190226102633553.png\" alt=\"在这里插入图片描述\"><br>代办列表：表示列表数据是否被勾选</p>\n<pre><code>- [ ] 不勾选\n- [x] 勾选\n</code></pre><p>效果如下图：<br><img src=\"https://img.mupaie.com/20190226102826784.png\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"4-4-代码块\"><a href=\"#4-4-代码块\" class=\"headerlink\" title=\"4.4. 代码块\"></a>4.4. 代码块</h1><p>只要把代码块包裹在“` 之间，在围栏式代码块中，你可以指定一个可选的语言标识符，然后我们就可以为它启用语法着色了：</p>\n<pre><code><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">require</span> <span class=\"string\">'redcarpet'</span></span><br><span class=\"line\">markdown = Redcarpet.new(<span class=\"string\">\"Hello World!\"</span>)</span><br><span class=\"line\">puts markdown.to_html</span><br></pre></td></tr></table></figure>\n</code></pre><p>效果如下图：<br>    <img src=\"https://img.mupaie.com/20190226103542307.png\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"4-5-强调\"><a href=\"#4-5-强调\" class=\"headerlink\" title=\"4.5. 强调\"></a>4.5. 强调</h1><p>在Markdown中，可以使用 <em> 和  _  来表示斜体和加粗。<br>单个 </em> 和 _ 修饰，表示斜体，双个 * 和 _ 修饰表示粗体</p>\n<pre><code>*Markdown*\n_Markdown_\n**Markdown**\n__Markdown__\n</code></pre><p>效果如下：<br><img src=\"https://img.mupaie.com/20190226104023173.png\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"4-6-链接\"><a href=\"#4-6-链接\" class=\"headerlink\" title=\"4.6. 链接\"></a>4.6. 链接</h1><pre><code>文字链接 [文字描述](地址)\n图片链接 ![文字描述](地址)\n</code></pre><p>效果如下：<br><img src=\"https://img.mupaie.com/20190226104232855.png\" alt=\"在这里插入图片描述\"><br>还有一些表格，一些工程图（流程图，时序图等）都可以使用markdown表现出来，我这里就不一一介绍了，具体参考<a href=\"https://coding.net/help/doc/project/markdown.html#i-6\" target=\"_blank\" rel=\"noopener\">Markdown 语法介绍</a></p>\n<h1 id=\"4-7-换行：\"><a href=\"#4-7-换行：\" class=\"headerlink\" title=\"4.7. 换行：\"></a>4.7. 换行：</h1><p>&emsp;&emsp;1.使用两个以上的空格加回车<br>&emsp;&emsp;2.使用http标签 \\<br></p>\n<h1 id=\"4-8-首行缩进\"><a href=\"#4-8-首行缩进\" class=\"headerlink\" title=\"4.8. 首行缩进\"></a>4.8. 首行缩进</h1><pre><code>&amp;emsp;&amp;emsp;1. 半角空格 “\\&amp;ensp;”\n&amp;emsp;&amp;emsp;2. 全角空格 “\\&amp;emsp;”\n&amp;emsp;&amp;emsp;3. 不换行空格 “\\&amp;nbsp;”\n</code></pre><h1 id=\"4-9-文本加颜色\"><a href=\"#4-9-文本加颜色\" class=\"headerlink\" title=\"4.9. 文本加颜色\"></a>4.9. 文本加颜色</h1><p>markdown 可以通过像html一样，可以通过标签样式让文本有一定的格式。</p>\n<pre><code>&lt;font color=&quot;red&quot;&gt;test&lt;/font&gt;\n</code></pre><p>效果如下：<br><img src=\"https://img.mupaie.com/20190226111339130.png\" alt=\"在这里插入图片描述\"><br>具体需要实现什么样式，参考<a href=\"http://www.runoob.com/css/css-text.html\" target=\"_blank\" rel=\"noopener\">css文档</a></p>\n<h1 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5. 总结\"></a>5. 总结</h1><p>今天简单介绍了markdown，并通过几个例子来展示具体用法。其实markdown还有很多内容，所以需要大家在以后使用中多积累多完善，这样才能更好的使用和掌markdown。</p>\n<p>参考文档：<br><a href=\"https://coding.net/help/doc/project/markdown.html#i-6\" target=\"_blank\" rel=\"noopener\">Markdown 语法介绍</a><br><a href=\"https://blog.csdn.net/u010177286/article/details/50358720\" target=\"_blank\" rel=\"noopener\">Markdown使用技巧总结——字体，颜色，字号，背景，首行缩进等</a><br><a href=\"https://blog.csdn.net/bao19901210/article/details/54625703\" target=\"_blank\" rel=\"noopener\">全角半角 &amp;&amp; 6种空白空格的区别</a><br><a href=\"https://zh.wikipedia.org/wiki/Markdown\" target=\"_blank\" rel=\"noopener\">维基百科 markdown介绍</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>由于最近写博客需要，了解到一种轻量级标记语言-markdown。下面来说一下关于一些markdown的知识：</p>\n<h1 id=\"1-markdown是什么？\"><a href=\"#1-markdown是什么？\" class=\"headerlink\" title=\"1. markdown是什么？\"></a>1. markdown是什么？</h1><p>Markdown是一种轻量级标记语言，创始人为约翰·格鲁伯（英语：John Gruber）。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档”。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。</p>\n<h1 id=\"2-markdown的历史发展？\"><a href=\"#2-markdown的历史发展？\" class=\"headerlink\" title=\"2. markdown的历史发展？\"></a>2. markdown的历史发展？</h1><p>John Gruber 在 2004 年创造了 Markdown 语言，在语法上有很大一部分是跟亚伦·斯沃茨（Aaron Swartz）共同合作的。这个语言的目的是希望大家使用“易于阅读、易于撰写的纯文字格式，并选择性的转换成有效的XHTML（或是HTML）”。 其中最重要的设计是可读性，也就是说这个语言应该要能直接在字面上的被阅读，而不用被一些格式化指令标记（像是RTF与HTML）。 因此，它是现行电子邮件标记格式的惯例，虽然它也借鉴了很多早期的标记语言，如：Setext、Texile、reStructuredText。Gruber也编写了的Perl脚本：Markdown.pl，用于把markdown语法编写的内容转换成有效的、结构良好的XHTML或HTML内容，并将左尖括号&lt;和&amp;号替换成它们各自的字符实体引用。它可以用作单独的脚本，Blosxom和Movable Type的插件又或者BBEdit的文本过滤器。Markdown也已经被其他人用Perl和别的编程语言重新实现，其中一个Perl模块放在了CPAN(Text::Markdown)上。它基于一个BSD风格的许可证分发并可以作为几个内容管理系统的插件。</p>\n<h1 id=\"3-markdown能用来做什么？\"><a href=\"#3-markdown能用来做什么？\" class=\"headerlink\" title=\"3. markdown能用来做什么？\"></a>3. markdown能用来做什么？</h1><p>由于Markdown的轻量化、易读易写特性，并且对于图片，图表、数学式都有支持，当前许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge等。甚至Markdown能被使用来撰写电子书。</p>\n<h1 id=\"4-markdown的一些语法和平时书写的注意点？\"><a href=\"#4-markdown的一些语法和平时书写的注意点？\" class=\"headerlink\" title=\"4. markdown的一些语法和平时书写的注意点？\"></a>4. markdown的一些语法和平时书写的注意点？</h1><h1 id=\"4-1-标题\"><a href=\"#4-1-标题\" class=\"headerlink\" title=\"4.1. 标题\"></a>4.1. 标题</h1><p>书写标题的时候，我们只需要在文本前面加上『# 』即可创建一级标题，如果想创建二级，三级，或者更多只需要增加『# 』的个数即可。下面展示一下效果：</p>\n<pre><code># 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n</code></pre><p>效果如下图：<br><img src=\"https://img.mupaie.com/20190226100452277.png\" alt=\"\"></p>\n<h1 id=\"4-2-引用\"><a href=\"#4-2-引用\" class=\"headerlink\" title=\"4.2. 引用\"></a>4.2. 引用</h1><p>在需要的整个段落第一行最前面加上『&gt;』即可：<br>    &gt;在这里插入图片描述 双通道（英语：Dual-channel）是一种能够让计算机性能增加的技术<br>    效果如下图：<br>    <img src=\"https://img.mupaie.com/20190226101026545.png\" alt=\"在这里插入图片描述\"><br>区块引用还可以嵌套使用<br>    &gt;  在这里插入图片描述 双通道（英语：Dual-channel）是一种能够让计算机性能增加的技术<br>    &gt;  &gt; 在这里插入图片描述 双通道（英语：Dual-channel）是一种能够让计算机性能增加的技术<br>    &gt;  &gt; &gt; 在这里插入图片描述 双通道（英语：Dual-channel）是一种能够让计算机性能增加的技术<br>    <img src=\"https://img.mupaie.com/20190226101213185.png\" alt=\"在这里插入图片描述\"><br>    不仅可以嵌套使用，还可以再引用中加入标题，列表等元素：<br>    &gt;  ## 在这里插入图片描述 双通道（英语：Dual-channel）是一种能够让计算机性能增加的技术<br>    &gt;  &gt; 1. 在这里插入图片描述 双通道（英语：Dual-channel）是一种能够让计算机性能增加的技术<br>    &gt;  &gt; 2.  在这里插入图片描述 双通道（英语：Dual-channel）是一种能够让计算机性能增加的技术<br>    效果如下图：<br>    <img src=\"https://img.mupaie.com/20190226101413977.png\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"4-3-列表\"><a href=\"#4-3-列表\" class=\"headerlink\" title=\"4.3. 列表\"></a>4.3. 列表</h1><p>列表在http中有无序和有序列表，markdown也有如下：<br> <strong>无序列表</strong> :使用星号 、加号或是减号来作为标记</p>\n<pre><code>- test\n- test\n- test\n</code></pre><p>效果如下图：<br><img src=\"https://img.mupaie.com/20190226102026437.png\" alt=\"在这里插入图片描述\"><br>有序列表则是在文本前面加上数字和小数点</p>\n<pre><code>1. test\n2. test\n3. test\n</code></pre><p>效果如下图：<br><img src=\"https://img.mupaie.com/20190226102236789.png\" alt=\"在这里插入图片描述\"><br>在列表中如何使用引用？</p>\n<pre><code>*  在这里插入图片描述 双通道（英语：Dual-channel）是一种能够让计算机性能增加的技术\n    &gt; 在这里插入图片描述 双通道（英语：Dual-channel）是一种能够让计算机性能增加的技术\n    &gt; 在这里插入图片描述 双通道（英语：Dual-channel）是一种能够让计算机性能增加的技术\n</code></pre><p>在列表栏下，引用的文本需要缩进<br>效果如下图：<br><img src=\"https://img.mupaie.com/20190226102633553.png\" alt=\"在这里插入图片描述\"><br>代办列表：表示列表数据是否被勾选</p>\n<pre><code>- [ ] 不勾选\n- [x] 勾选\n</code></pre><p>效果如下图：<br><img src=\"https://img.mupaie.com/20190226102826784.png\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"4-4-代码块\"><a href=\"#4-4-代码块\" class=\"headerlink\" title=\"4.4. 代码块\"></a>4.4. 代码块</h1><p>只要把代码块包裹在“` 之间，在围栏式代码块中，你可以指定一个可选的语言标识符，然后我们就可以为它启用语法着色了：</p>\n<pre><code><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">require</span> <span class=\"string\">'redcarpet'</span></span><br><span class=\"line\">markdown = Redcarpet.new(<span class=\"string\">\"Hello World!\"</span>)</span><br><span class=\"line\">puts markdown.to_html</span><br></pre></td></tr></table></figure>\n</code></pre><p>效果如下图：<br>    <img src=\"https://img.mupaie.com/20190226103542307.png\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"4-5-强调\"><a href=\"#4-5-强调\" class=\"headerlink\" title=\"4.5. 强调\"></a>4.5. 强调</h1><p>在Markdown中，可以使用 <em> 和  _  来表示斜体和加粗。<br>单个 </em> 和 _ 修饰，表示斜体，双个 * 和 _ 修饰表示粗体</p>\n<pre><code>*Markdown*\n_Markdown_\n**Markdown**\n__Markdown__\n</code></pre><p>效果如下：<br><img src=\"https://img.mupaie.com/20190226104023173.png\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"4-6-链接\"><a href=\"#4-6-链接\" class=\"headerlink\" title=\"4.6. 链接\"></a>4.6. 链接</h1><pre><code>文字链接 [文字描述](地址)\n图片链接 ![文字描述](地址)\n</code></pre><p>效果如下：<br><img src=\"https://img.mupaie.com/20190226104232855.png\" alt=\"在这里插入图片描述\"><br>还有一些表格，一些工程图（流程图，时序图等）都可以使用markdown表现出来，我这里就不一一介绍了，具体参考<a href=\"https://coding.net/help/doc/project/markdown.html#i-6\" target=\"_blank\" rel=\"noopener\">Markdown 语法介绍</a></p>\n<h1 id=\"4-7-换行：\"><a href=\"#4-7-换行：\" class=\"headerlink\" title=\"4.7. 换行：\"></a>4.7. 换行：</h1><p>&emsp;&emsp;1.使用两个以上的空格加回车<br>&emsp;&emsp;2.使用http标签 \\<br></p>\n<h1 id=\"4-8-首行缩进\"><a href=\"#4-8-首行缩进\" class=\"headerlink\" title=\"4.8. 首行缩进\"></a>4.8. 首行缩进</h1><pre><code>&amp;emsp;&amp;emsp;1. 半角空格 “\\&amp;ensp;”\n&amp;emsp;&amp;emsp;2. 全角空格 “\\&amp;emsp;”\n&amp;emsp;&amp;emsp;3. 不换行空格 “\\&amp;nbsp;”\n</code></pre><h1 id=\"4-9-文本加颜色\"><a href=\"#4-9-文本加颜色\" class=\"headerlink\" title=\"4.9. 文本加颜色\"></a>4.9. 文本加颜色</h1><p>markdown 可以通过像html一样，可以通过标签样式让文本有一定的格式。</p>\n<pre><code>&lt;font color=&quot;red&quot;&gt;test&lt;/font&gt;\n</code></pre><p>效果如下：<br><img src=\"https://img.mupaie.com/20190226111339130.png\" alt=\"在这里插入图片描述\"><br>具体需要实现什么样式，参考<a href=\"http://www.runoob.com/css/css-text.html\" target=\"_blank\" rel=\"noopener\">css文档</a></p>\n<h1 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5. 总结\"></a>5. 总结</h1><p>今天简单介绍了markdown，并通过几个例子来展示具体用法。其实markdown还有很多内容，所以需要大家在以后使用中多积累多完善，这样才能更好的使用和掌markdown。</p>\n<p>参考文档：<br><a href=\"https://coding.net/help/doc/project/markdown.html#i-6\" target=\"_blank\" rel=\"noopener\">Markdown 语法介绍</a><br><a href=\"https://blog.csdn.net/u010177286/article/details/50358720\" target=\"_blank\" rel=\"noopener\">Markdown使用技巧总结——字体，颜色，字号，背景，首行缩进等</a><br><a href=\"https://blog.csdn.net/bao19901210/article/details/54625703\" target=\"_blank\" rel=\"noopener\">全角半角 &amp;&amp; 6种空白空格的区别</a><br><a href=\"https://zh.wikipedia.org/wiki/Markdown\" target=\"_blank\" rel=\"noopener\">维基百科 markdown介绍</a></p>\n"},{"title":"get 请求中文乱码问题","date":"2019-02-22T01:49:52.000Z","_content":"对于浏览器发出的HTTP请求： tomcat 默认是ISO-8859-1 解码\n\n   URI： xxxxx.action?key=\"+encodeURIComponent(“中文”)\n\n   在服务器获取 到key的值是tomcat使用 ISO-8859-1编码进行解码的字符，会出现乱码的问题。目前有两种方式可以解决该问题。\n\n    1：通过转成编码为ISO-8859-1字节数组，然后再转成UTF-8的字符串\n\n String value= new String(request.getParameter(\"key\").getBytes(\"ISO-8859-1\"), \"UTF-8\"); \n\n    2：在页面上进行两次编码\n\n        xxxxx.action?key=\"+encodeURIComponent（encodeURIComponent(“中文”)）\n\n后台获取数据： String value= URLDecoder.decode( request.getParameter(\"key\"),\"UTF-8\")\n\n实现原理：\n\n.encodeURL函数主要是来对URI来做转码，它默认是采用的UTF-8的编码.\n\n. UTF-8编码的格式:一个汉字来三个字节构成，每一个字节会转换成16进制的编码，同时添加上%号.\n\n假设页面端输入的中文是一个“中”，按照下面步骤进行解码\n\n    1.第一次encodeURI，按照utf-8方式获取字节数组变成[-28,-72-83]，对字节码数组进行遍历，把每个字节转化成对应的16进制数，这样就变成了[E4,B8,AD],最后变成[%E4,%B8,%AD]  此时已经没有了多字节字符，全部是单字节字符。\n\n    2、第二次encodeURI，进行编码，会把%看成一个转义字符，并不编码%以后字符，会把%编码成%25.把数组最后变成[%25E4,%25B8,%25AD]然后就把处理后的数据[%25E4,%25B8,%25AD]发往服务器端，\n\n    当应用服务器调用getParameter方法，getParameter方法会去向应用服务器请求参数应用服务器最初获得的就是发送来的[%25E4,%25B8,%25AD]，应用服务器会对这个数据进行URLdecode操作，应用服务器进行解码的这一次，不管是按照UTF-8，还是GBK，还是ISO-8859，,都能得到[%E4,%B8,%AD]，因为都会把%25解析成%.并把这个值返回给getParameter方法\n\n    3、再用UTF-8解码一次，就得到\"中\"了。\n\n","source":"_posts/get-请求中文乱码问题.md","raw":"---\ntitle: get 请求中文乱码问题\ndate: 2019-02-22 09:49:52\ntags:\n- springMvc\n- 字符编码\n---\n对于浏览器发出的HTTP请求： tomcat 默认是ISO-8859-1 解码\n\n   URI： xxxxx.action?key=\"+encodeURIComponent(“中文”)\n\n   在服务器获取 到key的值是tomcat使用 ISO-8859-1编码进行解码的字符，会出现乱码的问题。目前有两种方式可以解决该问题。\n\n    1：通过转成编码为ISO-8859-1字节数组，然后再转成UTF-8的字符串\n\n String value= new String(request.getParameter(\"key\").getBytes(\"ISO-8859-1\"), \"UTF-8\"); \n\n    2：在页面上进行两次编码\n\n        xxxxx.action?key=\"+encodeURIComponent（encodeURIComponent(“中文”)）\n\n后台获取数据： String value= URLDecoder.decode( request.getParameter(\"key\"),\"UTF-8\")\n\n实现原理：\n\n.encodeURL函数主要是来对URI来做转码，它默认是采用的UTF-8的编码.\n\n. UTF-8编码的格式:一个汉字来三个字节构成，每一个字节会转换成16进制的编码，同时添加上%号.\n\n假设页面端输入的中文是一个“中”，按照下面步骤进行解码\n\n    1.第一次encodeURI，按照utf-8方式获取字节数组变成[-28,-72-83]，对字节码数组进行遍历，把每个字节转化成对应的16进制数，这样就变成了[E4,B8,AD],最后变成[%E4,%B8,%AD]  此时已经没有了多字节字符，全部是单字节字符。\n\n    2、第二次encodeURI，进行编码，会把%看成一个转义字符，并不编码%以后字符，会把%编码成%25.把数组最后变成[%25E4,%25B8,%25AD]然后就把处理后的数据[%25E4,%25B8,%25AD]发往服务器端，\n\n    当应用服务器调用getParameter方法，getParameter方法会去向应用服务器请求参数应用服务器最初获得的就是发送来的[%25E4,%25B8,%25AD]，应用服务器会对这个数据进行URLdecode操作，应用服务器进行解码的这一次，不管是按照UTF-8，还是GBK，还是ISO-8859，,都能得到[%E4,%B8,%AD]，因为都会把%25解析成%.并把这个值返回给getParameter方法\n\n    3、再用UTF-8解码一次，就得到\"中\"了。\n\n","slug":"get-请求中文乱码问题","published":1,"updated":"2019-07-14T03:11:26.961Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8mkctub000g4osxogiqqu65","content":"<p>对于浏览器发出的HTTP请求： tomcat 默认是ISO-8859-1 解码</p>\n<p>   URI： xxxxx.action?key=”+encodeURIComponent(“中文”)</p>\n<p>   在服务器获取 到key的值是tomcat使用 ISO-8859-1编码进行解码的字符，会出现乱码的问题。目前有两种方式可以解决该问题。</p>\n<pre><code>1：通过转成编码为ISO-8859-1字节数组，然后再转成UTF-8的字符串\n</code></pre><p> String value= new String(request.getParameter(“key”).getBytes(“ISO-8859-1”), “UTF-8”); </p>\n<pre><code>2：在页面上进行两次编码\n\n    xxxxx.action?key=&quot;+encodeURIComponent（encodeURIComponent(“中文”)）\n</code></pre><p>后台获取数据： String value= URLDecoder.decode( request.getParameter(“key”),”UTF-8”)</p>\n<p>实现原理：</p>\n<p>.encodeURL函数主要是来对URI来做转码，它默认是采用的UTF-8的编码.</p>\n<p>. UTF-8编码的格式:一个汉字来三个字节构成，每一个字节会转换成16进制的编码，同时添加上%号.</p>\n<p>假设页面端输入的中文是一个“中”，按照下面步骤进行解码</p>\n<pre><code>1.第一次encodeURI，按照utf-8方式获取字节数组变成[-28,-72-83]，对字节码数组进行遍历，把每个字节转化成对应的16进制数，这样就变成了[E4,B8,AD],最后变成[%E4,%B8,%AD]  此时已经没有了多字节字符，全部是单字节字符。\n\n2、第二次encodeURI，进行编码，会把%看成一个转义字符，并不编码%以后字符，会把%编码成%25.把数组最后变成[%25E4,%25B8,%25AD]然后就把处理后的数据[%25E4,%25B8,%25AD]发往服务器端，\n\n当应用服务器调用getParameter方法，getParameter方法会去向应用服务器请求参数应用服务器最初获得的就是发送来的[%25E4,%25B8,%25AD]，应用服务器会对这个数据进行URLdecode操作，应用服务器进行解码的这一次，不管是按照UTF-8，还是GBK，还是ISO-8859，,都能得到[%E4,%B8,%AD]，因为都会把%25解析成%.并把这个值返回给getParameter方法\n\n3、再用UTF-8解码一次，就得到&quot;中&quot;了。\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>对于浏览器发出的HTTP请求： tomcat 默认是ISO-8859-1 解码</p>\n<p>   URI： xxxxx.action?key=”+encodeURIComponent(“中文”)</p>\n<p>   在服务器获取 到key的值是tomcat使用 ISO-8859-1编码进行解码的字符，会出现乱码的问题。目前有两种方式可以解决该问题。</p>\n<pre><code>1：通过转成编码为ISO-8859-1字节数组，然后再转成UTF-8的字符串\n</code></pre><p> String value= new String(request.getParameter(“key”).getBytes(“ISO-8859-1”), “UTF-8”); </p>\n<pre><code>2：在页面上进行两次编码\n\n    xxxxx.action?key=&quot;+encodeURIComponent（encodeURIComponent(“中文”)）\n</code></pre><p>后台获取数据： String value= URLDecoder.decode( request.getParameter(“key”),”UTF-8”)</p>\n<p>实现原理：</p>\n<p>.encodeURL函数主要是来对URI来做转码，它默认是采用的UTF-8的编码.</p>\n<p>. UTF-8编码的格式:一个汉字来三个字节构成，每一个字节会转换成16进制的编码，同时添加上%号.</p>\n<p>假设页面端输入的中文是一个“中”，按照下面步骤进行解码</p>\n<pre><code>1.第一次encodeURI，按照utf-8方式获取字节数组变成[-28,-72-83]，对字节码数组进行遍历，把每个字节转化成对应的16进制数，这样就变成了[E4,B8,AD],最后变成[%E4,%B8,%AD]  此时已经没有了多字节字符，全部是单字节字符。\n\n2、第二次encodeURI，进行编码，会把%看成一个转义字符，并不编码%以后字符，会把%编码成%25.把数组最后变成[%25E4,%25B8,%25AD]然后就把处理后的数据[%25E4,%25B8,%25AD]发往服务器端，\n\n当应用服务器调用getParameter方法，getParameter方法会去向应用服务器请求参数应用服务器最初获得的就是发送来的[%25E4,%25B8,%25AD]，应用服务器会对这个数据进行URLdecode操作，应用服务器进行解码的这一次，不管是按照UTF-8，还是GBK，还是ISO-8859，,都能得到[%E4,%B8,%AD]，因为都会把%25解析成%.并把这个值返回给getParameter方法\n\n3、再用UTF-8解码一次，就得到&quot;中&quot;了。\n</code></pre>"},{"title":"js实现粘贴板功能","date":"2019-02-22T02:28:47.000Z","_content":"js实现粘贴板方式有document.exeCommad，window.clipboardData的setData方法，还有使用ZeroClipboard插件\n\n# 1. 通过document提供的exeCommad方法实现粘贴板功能 \n    <!DOCTYPE html>\n    <html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\">\n        <title>Title</title>\n    </head>\n    <body>\n    <input type=\"button\" onClick='copyUrls(this)' value=\"方式二\">\n    \n    <script language=\"javascript\">\n        function copyUrls(that) {\n            let textArea = document.createElement(\"textarea\")\n            textArea.style.position = 'fixed'\n            textArea.style.top = 0\n            textArea.style.left = 0\n            textArea.style.width = '2em'\n            textArea.style.height = '2em'\n            textArea.style.padding = 0\n            textArea.style.border = 'none'\n            textArea.style.outline = 'none'\n            textArea.style.boxShadow = 'none'\n            textArea.style.background = 'transparent'\n            textArea.value = that.value\n            document.body.appendChild(textArea)\n            textArea.select()\n            try {\n                document.execCommand('copy')\n            } catch (err) {\n                this.throwError('不能使用这种方法复制内容'+err.toString())\n            }\n            document.body.removeChild(textArea)\n        }\n    </script>\n    </body>\n    </html>\n\n优点不需要引用外部插件\n\n* google浏览器（兼容）\n* IE浏览器（兼容）\n* 火狐（兼容） ！\n\nexeCommad 还有很多方法，待续\n\n# 2. window.clipboardData的setData方法\n\n* google浏览器（不兼容）\n* IE浏览器（兼容）\n* 火狐（不兼容）\n    <!DOCTYPE html>\n        <html lang=\"en\">\n        <head>\n            <meta charset=\"UTF-8\">\n            <title>Title</title>\n        </head>\n        <body>\n    \n        <input type=\"button\" onClick='copyUrl()' value=\"方式一\">\n        <script language=\"javascript\">\n            function copyUrl() {\n                var clipBoardContent=\"test\";\n                window.clipboardData.setData(\"Text\",clipBoardContent);\n                alert(\"复制成功!\");\n            }\n        </script>\n        </body>\n        </html>\n\n# 3. 通过插件clipboard方式实现 https://github.com/zenorocha/clipboard.js\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\">\n        <title>Title</title>\n        <script src=\"clipboard.min.js\"></script>\n    </head>\n    <body>\n    \n    <input type=\"button\" onClick='copyUrls3(this)' value=\"方式三\" class=\"btn\">\n    \n    <script language=\"javascript\">\n        function copyUrls3(that) {\n            var clipboard = new ClipboardJS('.btn', {\n                text: function() {\n                    return that.value;\n                }\n            });\n    \n            clipboard.on('success', function(e) {\n                console.log(e);\n            });\n    \n            clipboard.on('error', function(e) {\n                console.log(e);\n            });\n        }\n    \n    </script>\n    </body>\n    </html>\n\n* google浏览器（不兼容）\n* IE浏览器（兼容）\n* 火狐（不兼容）\n\n后续加上各个版本的优缺点\n\n","source":"_posts/js实现粘贴板功能.md","raw":"---\ntitle: js实现粘贴板功能\ndate: 2019-02-22 10:28:47\ntags:\n- JavaScript\n- 浏览器兼容性\n---\njs实现粘贴板方式有document.exeCommad，window.clipboardData的setData方法，还有使用ZeroClipboard插件\n\n# 1. 通过document提供的exeCommad方法实现粘贴板功能 \n    <!DOCTYPE html>\n    <html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\">\n        <title>Title</title>\n    </head>\n    <body>\n    <input type=\"button\" onClick='copyUrls(this)' value=\"方式二\">\n    \n    <script language=\"javascript\">\n        function copyUrls(that) {\n            let textArea = document.createElement(\"textarea\")\n            textArea.style.position = 'fixed'\n            textArea.style.top = 0\n            textArea.style.left = 0\n            textArea.style.width = '2em'\n            textArea.style.height = '2em'\n            textArea.style.padding = 0\n            textArea.style.border = 'none'\n            textArea.style.outline = 'none'\n            textArea.style.boxShadow = 'none'\n            textArea.style.background = 'transparent'\n            textArea.value = that.value\n            document.body.appendChild(textArea)\n            textArea.select()\n            try {\n                document.execCommand('copy')\n            } catch (err) {\n                this.throwError('不能使用这种方法复制内容'+err.toString())\n            }\n            document.body.removeChild(textArea)\n        }\n    </script>\n    </body>\n    </html>\n\n优点不需要引用外部插件\n\n* google浏览器（兼容）\n* IE浏览器（兼容）\n* 火狐（兼容） ！\n\nexeCommad 还有很多方法，待续\n\n# 2. window.clipboardData的setData方法\n\n* google浏览器（不兼容）\n* IE浏览器（兼容）\n* 火狐（不兼容）\n    <!DOCTYPE html>\n        <html lang=\"en\">\n        <head>\n            <meta charset=\"UTF-8\">\n            <title>Title</title>\n        </head>\n        <body>\n    \n        <input type=\"button\" onClick='copyUrl()' value=\"方式一\">\n        <script language=\"javascript\">\n            function copyUrl() {\n                var clipBoardContent=\"test\";\n                window.clipboardData.setData(\"Text\",clipBoardContent);\n                alert(\"复制成功!\");\n            }\n        </script>\n        </body>\n        </html>\n\n# 3. 通过插件clipboard方式实现 https://github.com/zenorocha/clipboard.js\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\">\n        <title>Title</title>\n        <script src=\"clipboard.min.js\"></script>\n    </head>\n    <body>\n    \n    <input type=\"button\" onClick='copyUrls3(this)' value=\"方式三\" class=\"btn\">\n    \n    <script language=\"javascript\">\n        function copyUrls3(that) {\n            var clipboard = new ClipboardJS('.btn', {\n                text: function() {\n                    return that.value;\n                }\n            });\n    \n            clipboard.on('success', function(e) {\n                console.log(e);\n            });\n    \n            clipboard.on('error', function(e) {\n                console.log(e);\n            });\n        }\n    \n    </script>\n    </body>\n    </html>\n\n* google浏览器（不兼容）\n* IE浏览器（兼容）\n* 火狐（不兼容）\n\n后续加上各个版本的优缺点\n\n","slug":"js实现粘贴板功能","published":1,"updated":"2019-07-14T03:11:26.962Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8mkctuc000h4osx0jq5j09i","content":"<p>js实现粘贴板方式有document.exeCommad，window.clipboardData的setData方法，还有使用ZeroClipboard插件</p>\n<h1 id=\"1-通过document提供的exeCommad方法实现粘贴板功能\"><a href=\"#1-通过document提供的exeCommad方法实现粘贴板功能\" class=\"headerlink\" title=\"1. 通过document提供的exeCommad方法实现粘贴板功能\"></a>1. 通过document提供的exeCommad方法实现粘贴板功能</h1><pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;input type=&quot;button&quot; onClick=&apos;copyUrls(this)&apos; value=&quot;方式二&quot;&gt;\n\n&lt;script language=&quot;javascript&quot;&gt;\n    function copyUrls(that) {\n        let textArea = document.createElement(&quot;textarea&quot;)\n        textArea.style.position = &apos;fixed&apos;\n        textArea.style.top = 0\n        textArea.style.left = 0\n        textArea.style.width = &apos;2em&apos;\n        textArea.style.height = &apos;2em&apos;\n        textArea.style.padding = 0\n        textArea.style.border = &apos;none&apos;\n        textArea.style.outline = &apos;none&apos;\n        textArea.style.boxShadow = &apos;none&apos;\n        textArea.style.background = &apos;transparent&apos;\n        textArea.value = that.value\n        document.body.appendChild(textArea)\n        textArea.select()\n        try {\n            document.execCommand(&apos;copy&apos;)\n        } catch (err) {\n            this.throwError(&apos;不能使用这种方法复制内容&apos;+err.toString())\n        }\n        document.body.removeChild(textArea)\n    }\n&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>优点不需要引用外部插件</p>\n<ul>\n<li>google浏览器（兼容）</li>\n<li>IE浏览器（兼容）</li>\n<li>火狐（兼容） ！</li>\n</ul>\n<p>exeCommad 还有很多方法，待续</p>\n<h1 id=\"2-window-clipboardData的setData方法\"><a href=\"#2-window-clipboardData的setData方法\" class=\"headerlink\" title=\"2. window.clipboardData的setData方法\"></a>2. window.clipboardData的setData方法</h1><ul>\n<li>google浏览器（不兼容）</li>\n<li>IE浏览器（兼容）</li>\n<li><p>火狐（不兼容）<br>  &lt;!DOCTYPE html&gt;</p>\n<pre><code>&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n\n&lt;input type=&quot;button&quot; onClick=&apos;copyUrl()&apos; value=&quot;方式一&quot;&gt;\n&lt;script language=&quot;javascript&quot;&gt;\n    function copyUrl() {\n        var clipBoardContent=&quot;test&quot;;\n        window.clipboardData.setData(&quot;Text&quot;,clipBoardContent);\n        alert(&quot;复制成功!&quot;);\n    }\n&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre></li>\n</ul>\n<h1 id=\"3-通过插件clipboard方式实现-https-github-com-zenorocha-clipboard-js\"><a href=\"#3-通过插件clipboard方式实现-https-github-com-zenorocha-clipboard-js\" class=\"headerlink\" title=\"3. 通过插件clipboard方式实现 https://github.com/zenorocha/clipboard.js\"></a>3. 通过插件clipboard方式实现 <a href=\"https://github.com/zenorocha/clipboard.js\" target=\"_blank\" rel=\"noopener\">https://github.com/zenorocha/clipboard.js</a></h1><pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n    &lt;script src=&quot;clipboard.min.js&quot;&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n\n&lt;input type=&quot;button&quot; onClick=&apos;copyUrls3(this)&apos; value=&quot;方式三&quot; class=&quot;btn&quot;&gt;\n\n&lt;script language=&quot;javascript&quot;&gt;\n    function copyUrls3(that) {\n        var clipboard = new ClipboardJS(&apos;.btn&apos;, {\n            text: function() {\n                return that.value;\n            }\n        });\n\n        clipboard.on(&apos;success&apos;, function(e) {\n            console.log(e);\n        });\n\n        clipboard.on(&apos;error&apos;, function(e) {\n            console.log(e);\n        });\n    }\n\n&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><ul>\n<li>google浏览器（不兼容）</li>\n<li>IE浏览器（兼容）</li>\n<li>火狐（不兼容）</li>\n</ul>\n<p>后续加上各个版本的优缺点</p>\n","site":{"data":{}},"excerpt":"","more":"<p>js实现粘贴板方式有document.exeCommad，window.clipboardData的setData方法，还有使用ZeroClipboard插件</p>\n<h1 id=\"1-通过document提供的exeCommad方法实现粘贴板功能\"><a href=\"#1-通过document提供的exeCommad方法实现粘贴板功能\" class=\"headerlink\" title=\"1. 通过document提供的exeCommad方法实现粘贴板功能\"></a>1. 通过document提供的exeCommad方法实现粘贴板功能</h1><pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;input type=&quot;button&quot; onClick=&apos;copyUrls(this)&apos; value=&quot;方式二&quot;&gt;\n\n&lt;script language=&quot;javascript&quot;&gt;\n    function copyUrls(that) {\n        let textArea = document.createElement(&quot;textarea&quot;)\n        textArea.style.position = &apos;fixed&apos;\n        textArea.style.top = 0\n        textArea.style.left = 0\n        textArea.style.width = &apos;2em&apos;\n        textArea.style.height = &apos;2em&apos;\n        textArea.style.padding = 0\n        textArea.style.border = &apos;none&apos;\n        textArea.style.outline = &apos;none&apos;\n        textArea.style.boxShadow = &apos;none&apos;\n        textArea.style.background = &apos;transparent&apos;\n        textArea.value = that.value\n        document.body.appendChild(textArea)\n        textArea.select()\n        try {\n            document.execCommand(&apos;copy&apos;)\n        } catch (err) {\n            this.throwError(&apos;不能使用这种方法复制内容&apos;+err.toString())\n        }\n        document.body.removeChild(textArea)\n    }\n&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>优点不需要引用外部插件</p>\n<ul>\n<li>google浏览器（兼容）</li>\n<li>IE浏览器（兼容）</li>\n<li>火狐（兼容） ！</li>\n</ul>\n<p>exeCommad 还有很多方法，待续</p>\n<h1 id=\"2-window-clipboardData的setData方法\"><a href=\"#2-window-clipboardData的setData方法\" class=\"headerlink\" title=\"2. window.clipboardData的setData方法\"></a>2. window.clipboardData的setData方法</h1><ul>\n<li>google浏览器（不兼容）</li>\n<li>IE浏览器（兼容）</li>\n<li><p>火狐（不兼容）<br>  &lt;!DOCTYPE html&gt;</p>\n<pre><code>&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n\n&lt;input type=&quot;button&quot; onClick=&apos;copyUrl()&apos; value=&quot;方式一&quot;&gt;\n&lt;script language=&quot;javascript&quot;&gt;\n    function copyUrl() {\n        var clipBoardContent=&quot;test&quot;;\n        window.clipboardData.setData(&quot;Text&quot;,clipBoardContent);\n        alert(&quot;复制成功!&quot;);\n    }\n&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre></li>\n</ul>\n<h1 id=\"3-通过插件clipboard方式实现-https-github-com-zenorocha-clipboard-js\"><a href=\"#3-通过插件clipboard方式实现-https-github-com-zenorocha-clipboard-js\" class=\"headerlink\" title=\"3. 通过插件clipboard方式实现 https://github.com/zenorocha/clipboard.js\"></a>3. 通过插件clipboard方式实现 <a href=\"https://github.com/zenorocha/clipboard.js\" target=\"_blank\" rel=\"noopener\">https://github.com/zenorocha/clipboard.js</a></h1><pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n    &lt;script src=&quot;clipboard.min.js&quot;&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n\n&lt;input type=&quot;button&quot; onClick=&apos;copyUrls3(this)&apos; value=&quot;方式三&quot; class=&quot;btn&quot;&gt;\n\n&lt;script language=&quot;javascript&quot;&gt;\n    function copyUrls3(that) {\n        var clipboard = new ClipboardJS(&apos;.btn&apos;, {\n            text: function() {\n                return that.value;\n            }\n        });\n\n        clipboard.on(&apos;success&apos;, function(e) {\n            console.log(e);\n        });\n\n        clipboard.on(&apos;error&apos;, function(e) {\n            console.log(e);\n        });\n    }\n\n&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><ul>\n<li>google浏览器（不兼容）</li>\n<li>IE浏览器（兼容）</li>\n<li>火狐（不兼容）</li>\n</ul>\n<p>后续加上各个版本的优缺点</p>\n"},{"title":"java 反射笔记","date":"2019-02-20T10:39:41.000Z","_content":"\n\n# 1. 什么叫反射？\n\n反射机制，在Java程序运行过程中动态获取类信息（变量，方法等），以及动态调用对象方法的功能，重点是在**程序运行中**\n\n官方对反射的解释：\n\n通过反射，我们可以在运行时获得程序或程序集中每一个类型的成员和成员的信息。程序中一般的对象的类型都是在编译期就确定下来的，而 Java 反射机制可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。所以我们可以通过反射机制直接创建对象，即使这个对象的类型在编译期是未知的。\n\n# 2. 反射机制的用途\n\n* l在运行时分析类的能力。\n\n* l在运行时查看对象。\n\n* l实现通用的数组操作代码。\n\n* l利用 Method 对象， 这个对象很像中的函数指针。\n\n很多框架中使用了反射机制，最经常用的Spring IOC 创建bean的过程就是通过反射实现的。\n\n# 3. 反射的运用\n\nJava反射主要是获取一个Class 对象（在程序运行期间，Java 运行时系统始终为所有的对象维护一个被称为运行时的类型标识）获取Class 有三种方式\n\n1：使用Class的类方法 forName\n\nClass.forName(\"类路径\")\n\n平时我们在加载jdbc中使用Class.forName(driver)，加载数据库驱动\n\n2：直接对象的class\n\nClass cl = String.class;\n\n3：调用对象的getClass()方法\n\nString s = \"uuu\";  \nClass cl = s.getClass()\n\n获取到Class对象后，我们就可以获取方法信息，成员变量\n\n获取成员变量：\n\n* getFiled：访问公有的成员变量，包括父类的公有成员变量\n\n* getDeclaredField：所有已声明的成员变量，但不能得到其父类的成员变量\n\n获取方法集，主要有以下几个方法：\n\n* getDeclaredMethods 方法返回类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。\n\n* getMethods 方法返回某个类的所有公用（public）方法，包括其继承类的公用方法。\n\n* getMethod 方法返回一个特定的方法，其中第一个参数为方法名称，后面的参数为方法的参数对应Class的对象。\n\n创建实例\n\n* 使用 Class 的 newInstance 方法，使用这个方法会抛出两个异常IllegalAccessException（非法访问异常） 和 InstantiationException（实例化异常）\n\n* 先使用Class对象获取指定的Constructor对象, 再调用Constructor对象的newInstance()方法来创建该Class对象对应类的实例(通过这种方式可以选择指定的构造器来创建实例).\n\n方法调用\n\n通过 Method 的invoke（）方法实现方法调用。\n\n```\nClass cl = null;\n\ntry {\n\n    cl = Class.forName(\"cn.assist.easydao.util.Student\");\n\n    Object o = cl.newInstance();\n\n    Method setAge = cl.getDeclaredMethod(\"setAge\", Integer.class);\n\n    Method getAge = cl.getDeclaredMethod(\"getAge\");\n\n    setAge.invoke(o,3);\n\n    System.out.println(getAge.invoke(o));\n\n\n\n} catch (ClassNotFoundException e) {\n\n    e.printStackTrace();\n\n} catch (IllegalAccessException e) {\n\n    e.printStackTrace();\n\n} catch (InstantiationException e) {\n\n    e.printStackTrace();\n\n} catch (NoSuchMethodException e) {\n\n    e.printStackTrace();\n\n} catch (InvocationTargetException e) {\n\n    e.printStackTrace();\n\n}\n```\n\n实现通用的数组操作\n\n// 创建数组\n\nObject array = Array.newInstance(String.class,4);\n\n// 设值\n\nArray.set(array,0,\"test\");\n\n# 4. 总结\n\nJava反射会消耗大量资源？\n\n* 由于反射创建对象是间接创建，需要做一些步骤操作，会导致执行时间长，消耗大量资源的。\n\n如何提高反射效率？\n\n* 使用缓存机制，避免重复创建对象\n\n* 获取方法尽量使用getMethod(methodName)，不建议使用getMethods()后再遍历筛选\n\n* 使用现成的反射框架\n\n* 使用reflectasm框架，该框架通过字节码，访问类信息\n\n反射可以在运行时操作，可能导致系统变的不安全\n\n参考文档：\n\n[深入解析Java反射（1） - 基础](https://www.sczyh30.com/posts/Java/java-reflection-1/)\n\nJava 核心技术 卷一\n","source":"_posts/java-反射笔记.md","raw":"---\ntitle: java 反射笔记\ndate: 2019-02-20 18:39:41\ntags:\n- JAVA\n- 反射机制\n---\n\n\n# 1. 什么叫反射？\n\n反射机制，在Java程序运行过程中动态获取类信息（变量，方法等），以及动态调用对象方法的功能，重点是在**程序运行中**\n\n官方对反射的解释：\n\n通过反射，我们可以在运行时获得程序或程序集中每一个类型的成员和成员的信息。程序中一般的对象的类型都是在编译期就确定下来的，而 Java 反射机制可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。所以我们可以通过反射机制直接创建对象，即使这个对象的类型在编译期是未知的。\n\n# 2. 反射机制的用途\n\n* l在运行时分析类的能力。\n\n* l在运行时查看对象。\n\n* l实现通用的数组操作代码。\n\n* l利用 Method 对象， 这个对象很像中的函数指针。\n\n很多框架中使用了反射机制，最经常用的Spring IOC 创建bean的过程就是通过反射实现的。\n\n# 3. 反射的运用\n\nJava反射主要是获取一个Class 对象（在程序运行期间，Java 运行时系统始终为所有的对象维护一个被称为运行时的类型标识）获取Class 有三种方式\n\n1：使用Class的类方法 forName\n\nClass.forName(\"类路径\")\n\n平时我们在加载jdbc中使用Class.forName(driver)，加载数据库驱动\n\n2：直接对象的class\n\nClass cl = String.class;\n\n3：调用对象的getClass()方法\n\nString s = \"uuu\";  \nClass cl = s.getClass()\n\n获取到Class对象后，我们就可以获取方法信息，成员变量\n\n获取成员变量：\n\n* getFiled：访问公有的成员变量，包括父类的公有成员变量\n\n* getDeclaredField：所有已声明的成员变量，但不能得到其父类的成员变量\n\n获取方法集，主要有以下几个方法：\n\n* getDeclaredMethods 方法返回类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。\n\n* getMethods 方法返回某个类的所有公用（public）方法，包括其继承类的公用方法。\n\n* getMethod 方法返回一个特定的方法，其中第一个参数为方法名称，后面的参数为方法的参数对应Class的对象。\n\n创建实例\n\n* 使用 Class 的 newInstance 方法，使用这个方法会抛出两个异常IllegalAccessException（非法访问异常） 和 InstantiationException（实例化异常）\n\n* 先使用Class对象获取指定的Constructor对象, 再调用Constructor对象的newInstance()方法来创建该Class对象对应类的实例(通过这种方式可以选择指定的构造器来创建实例).\n\n方法调用\n\n通过 Method 的invoke（）方法实现方法调用。\n\n```\nClass cl = null;\n\ntry {\n\n    cl = Class.forName(\"cn.assist.easydao.util.Student\");\n\n    Object o = cl.newInstance();\n\n    Method setAge = cl.getDeclaredMethod(\"setAge\", Integer.class);\n\n    Method getAge = cl.getDeclaredMethod(\"getAge\");\n\n    setAge.invoke(o,3);\n\n    System.out.println(getAge.invoke(o));\n\n\n\n} catch (ClassNotFoundException e) {\n\n    e.printStackTrace();\n\n} catch (IllegalAccessException e) {\n\n    e.printStackTrace();\n\n} catch (InstantiationException e) {\n\n    e.printStackTrace();\n\n} catch (NoSuchMethodException e) {\n\n    e.printStackTrace();\n\n} catch (InvocationTargetException e) {\n\n    e.printStackTrace();\n\n}\n```\n\n实现通用的数组操作\n\n// 创建数组\n\nObject array = Array.newInstance(String.class,4);\n\n// 设值\n\nArray.set(array,0,\"test\");\n\n# 4. 总结\n\nJava反射会消耗大量资源？\n\n* 由于反射创建对象是间接创建，需要做一些步骤操作，会导致执行时间长，消耗大量资源的。\n\n如何提高反射效率？\n\n* 使用缓存机制，避免重复创建对象\n\n* 获取方法尽量使用getMethod(methodName)，不建议使用getMethods()后再遍历筛选\n\n* 使用现成的反射框架\n\n* 使用reflectasm框架，该框架通过字节码，访问类信息\n\n反射可以在运行时操作，可能导致系统变的不安全\n\n参考文档：\n\n[深入解析Java反射（1） - 基础](https://www.sczyh30.com/posts/Java/java-reflection-1/)\n\nJava 核心技术 卷一\n","slug":"java-反射笔记","published":1,"updated":"2019-07-14T03:11:26.962Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8mkctuf000j4osxx6otzbl8","content":"<h1 id=\"1-什么叫反射？\"><a href=\"#1-什么叫反射？\" class=\"headerlink\" title=\"1. 什么叫反射？\"></a>1. 什么叫反射？</h1><p>反射机制，在Java程序运行过程中动态获取类信息（变量，方法等），以及动态调用对象方法的功能，重点是在<strong>程序运行中</strong></p>\n<p>官方对反射的解释：</p>\n<p>通过反射，我们可以在运行时获得程序或程序集中每一个类型的成员和成员的信息。程序中一般的对象的类型都是在编译期就确定下来的，而 Java 反射机制可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。所以我们可以通过反射机制直接创建对象，即使这个对象的类型在编译期是未知的。</p>\n<h1 id=\"2-反射机制的用途\"><a href=\"#2-反射机制的用途\" class=\"headerlink\" title=\"2. 反射机制的用途\"></a>2. 反射机制的用途</h1><ul>\n<li><p>l在运行时分析类的能力。</p>\n</li>\n<li><p>l在运行时查看对象。</p>\n</li>\n<li><p>l实现通用的数组操作代码。</p>\n</li>\n<li><p>l利用 Method 对象， 这个对象很像中的函数指针。</p>\n</li>\n</ul>\n<p>很多框架中使用了反射机制，最经常用的Spring IOC 创建bean的过程就是通过反射实现的。</p>\n<h1 id=\"3-反射的运用\"><a href=\"#3-反射的运用\" class=\"headerlink\" title=\"3. 反射的运用\"></a>3. 反射的运用</h1><p>Java反射主要是获取一个Class 对象（在程序运行期间，Java 运行时系统始终为所有的对象维护一个被称为运行时的类型标识）获取Class 有三种方式</p>\n<p>1：使用Class的类方法 forName</p>\n<p>Class.forName(“类路径”)</p>\n<p>平时我们在加载jdbc中使用Class.forName(driver)，加载数据库驱动</p>\n<p>2：直接对象的class</p>\n<p>Class cl = String.class;</p>\n<p>3：调用对象的getClass()方法</p>\n<p>String s = “uuu”;<br>Class cl = s.getClass()</p>\n<p>获取到Class对象后，我们就可以获取方法信息，成员变量</p>\n<p>获取成员变量：</p>\n<ul>\n<li><p>getFiled：访问公有的成员变量，包括父类的公有成员变量</p>\n</li>\n<li><p>getDeclaredField：所有已声明的成员变量，但不能得到其父类的成员变量</p>\n</li>\n</ul>\n<p>获取方法集，主要有以下几个方法：</p>\n<ul>\n<li><p>getDeclaredMethods 方法返回类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。</p>\n</li>\n<li><p>getMethods 方法返回某个类的所有公用（public）方法，包括其继承类的公用方法。</p>\n</li>\n<li><p>getMethod 方法返回一个特定的方法，其中第一个参数为方法名称，后面的参数为方法的参数对应Class的对象。</p>\n</li>\n</ul>\n<p>创建实例</p>\n<ul>\n<li><p>使用 Class 的 newInstance 方法，使用这个方法会抛出两个异常IllegalAccessException（非法访问异常） 和 InstantiationException（实例化异常）</p>\n</li>\n<li><p>先使用Class对象获取指定的Constructor对象, 再调用Constructor对象的newInstance()方法来创建该Class对象对应类的实例(通过这种方式可以选择指定的构造器来创建实例).</p>\n</li>\n</ul>\n<p>方法调用</p>\n<p>通过 Method 的invoke（）方法实现方法调用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class cl = null;</span><br><span class=\"line\"></span><br><span class=\"line\">try &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    cl = Class.forName(&quot;cn.assist.easydao.util.Student&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    Object o = cl.newInstance();</span><br><span class=\"line\"></span><br><span class=\"line\">    Method setAge = cl.getDeclaredMethod(&quot;setAge&quot;, Integer.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    Method getAge = cl.getDeclaredMethod(&quot;getAge&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    setAge.invoke(o,3);</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(getAge.invoke(o));</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125; catch (ClassNotFoundException e) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; catch (IllegalAccessException e) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; catch (InstantiationException e) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; catch (NoSuchMethodException e) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; catch (InvocationTargetException e) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实现通用的数组操作</p>\n<p>// 创建数组</p>\n<p>Object array = Array.newInstance(String.class,4);</p>\n<p>// 设值</p>\n<p>Array.set(array,0,”test”);</p>\n<h1 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4. 总结\"></a>4. 总结</h1><p>Java反射会消耗大量资源？</p>\n<ul>\n<li>由于反射创建对象是间接创建，需要做一些步骤操作，会导致执行时间长，消耗大量资源的。</li>\n</ul>\n<p>如何提高反射效率？</p>\n<ul>\n<li><p>使用缓存机制，避免重复创建对象</p>\n</li>\n<li><p>获取方法尽量使用getMethod(methodName)，不建议使用getMethods()后再遍历筛选</p>\n</li>\n<li><p>使用现成的反射框架</p>\n</li>\n<li><p>使用reflectasm框架，该框架通过字节码，访问类信息</p>\n</li>\n</ul>\n<p>反射可以在运行时操作，可能导致系统变的不安全</p>\n<p>参考文档：</p>\n<p><a href=\"https://www.sczyh30.com/posts/Java/java-reflection-1/\" target=\"_blank\" rel=\"noopener\">深入解析Java反射（1） - 基础</a></p>\n<p>Java 核心技术 卷一</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-什么叫反射？\"><a href=\"#1-什么叫反射？\" class=\"headerlink\" title=\"1. 什么叫反射？\"></a>1. 什么叫反射？</h1><p>反射机制，在Java程序运行过程中动态获取类信息（变量，方法等），以及动态调用对象方法的功能，重点是在<strong>程序运行中</strong></p>\n<p>官方对反射的解释：</p>\n<p>通过反射，我们可以在运行时获得程序或程序集中每一个类型的成员和成员的信息。程序中一般的对象的类型都是在编译期就确定下来的，而 Java 反射机制可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。所以我们可以通过反射机制直接创建对象，即使这个对象的类型在编译期是未知的。</p>\n<h1 id=\"2-反射机制的用途\"><a href=\"#2-反射机制的用途\" class=\"headerlink\" title=\"2. 反射机制的用途\"></a>2. 反射机制的用途</h1><ul>\n<li><p>l在运行时分析类的能力。</p>\n</li>\n<li><p>l在运行时查看对象。</p>\n</li>\n<li><p>l实现通用的数组操作代码。</p>\n</li>\n<li><p>l利用 Method 对象， 这个对象很像中的函数指针。</p>\n</li>\n</ul>\n<p>很多框架中使用了反射机制，最经常用的Spring IOC 创建bean的过程就是通过反射实现的。</p>\n<h1 id=\"3-反射的运用\"><a href=\"#3-反射的运用\" class=\"headerlink\" title=\"3. 反射的运用\"></a>3. 反射的运用</h1><p>Java反射主要是获取一个Class 对象（在程序运行期间，Java 运行时系统始终为所有的对象维护一个被称为运行时的类型标识）获取Class 有三种方式</p>\n<p>1：使用Class的类方法 forName</p>\n<p>Class.forName(“类路径”)</p>\n<p>平时我们在加载jdbc中使用Class.forName(driver)，加载数据库驱动</p>\n<p>2：直接对象的class</p>\n<p>Class cl = String.class;</p>\n<p>3：调用对象的getClass()方法</p>\n<p>String s = “uuu”;<br>Class cl = s.getClass()</p>\n<p>获取到Class对象后，我们就可以获取方法信息，成员变量</p>\n<p>获取成员变量：</p>\n<ul>\n<li><p>getFiled：访问公有的成员变量，包括父类的公有成员变量</p>\n</li>\n<li><p>getDeclaredField：所有已声明的成员变量，但不能得到其父类的成员变量</p>\n</li>\n</ul>\n<p>获取方法集，主要有以下几个方法：</p>\n<ul>\n<li><p>getDeclaredMethods 方法返回类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。</p>\n</li>\n<li><p>getMethods 方法返回某个类的所有公用（public）方法，包括其继承类的公用方法。</p>\n</li>\n<li><p>getMethod 方法返回一个特定的方法，其中第一个参数为方法名称，后面的参数为方法的参数对应Class的对象。</p>\n</li>\n</ul>\n<p>创建实例</p>\n<ul>\n<li><p>使用 Class 的 newInstance 方法，使用这个方法会抛出两个异常IllegalAccessException（非法访问异常） 和 InstantiationException（实例化异常）</p>\n</li>\n<li><p>先使用Class对象获取指定的Constructor对象, 再调用Constructor对象的newInstance()方法来创建该Class对象对应类的实例(通过这种方式可以选择指定的构造器来创建实例).</p>\n</li>\n</ul>\n<p>方法调用</p>\n<p>通过 Method 的invoke（）方法实现方法调用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class cl = null;</span><br><span class=\"line\"></span><br><span class=\"line\">try &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    cl = Class.forName(&quot;cn.assist.easydao.util.Student&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    Object o = cl.newInstance();</span><br><span class=\"line\"></span><br><span class=\"line\">    Method setAge = cl.getDeclaredMethod(&quot;setAge&quot;, Integer.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    Method getAge = cl.getDeclaredMethod(&quot;getAge&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    setAge.invoke(o,3);</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(getAge.invoke(o));</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125; catch (ClassNotFoundException e) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; catch (IllegalAccessException e) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; catch (InstantiationException e) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; catch (NoSuchMethodException e) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; catch (InvocationTargetException e) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实现通用的数组操作</p>\n<p>// 创建数组</p>\n<p>Object array = Array.newInstance(String.class,4);</p>\n<p>// 设值</p>\n<p>Array.set(array,0,”test”);</p>\n<h1 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4. 总结\"></a>4. 总结</h1><p>Java反射会消耗大量资源？</p>\n<ul>\n<li>由于反射创建对象是间接创建，需要做一些步骤操作，会导致执行时间长，消耗大量资源的。</li>\n</ul>\n<p>如何提高反射效率？</p>\n<ul>\n<li><p>使用缓存机制，避免重复创建对象</p>\n</li>\n<li><p>获取方法尽量使用getMethod(methodName)，不建议使用getMethods()后再遍历筛选</p>\n</li>\n<li><p>使用现成的反射框架</p>\n</li>\n<li><p>使用reflectasm框架，该框架通过字节码，访问类信息</p>\n</li>\n</ul>\n<p>反射可以在运行时操作，可能导致系统变的不安全</p>\n<p>参考文档：</p>\n<p><a href=\"https://www.sczyh30.com/posts/Java/java-reflection-1/\" target=\"_blank\" rel=\"noopener\">深入解析Java反射（1） - 基础</a></p>\n<p>Java 核心技术 卷一</p>\n"},{"title":"gitLab 搭建","date":"2019-02-22T02:42:28.000Z","_content":"今天我们说一下怎么在Linux搭建gitLab，具体步骤如下：\n\n打开该地址 [https://about.gitlab.com/installation/](https://about.gitlab.com/installation/#centos-7) 这个是官方提供安装文档，具体我们来操作一下\n\n1：根据操作系统版本寻找对应的文档\n\n2：安装和配置相应的依赖\n\nOn CentOS 7 (and RedHat/Oracle/Scientific Linux 7), 以下命令可以使http和ssh允许在防火墙下能被访问\n>\n> ```\n> sudo yum install -y curl policycoreutils-python openssh-server\n> sudo systemctl enable sshd\n> sudo systemctl start sshd\n> sudo firewall-cmd --permanent --add-service=http\n> sudo systemctl reload firewalld\n> ```\n\n接下来，安装 Postfix 用于发送邮件。如果你想用其他的方式发送邮件，请跳过该步骤并在gitLab 安装之后，配置其他的邮件服务器。\n>\n> ```\n> sudo yum install postfix\n> sudo systemctl enable postfix\n> sudo systemctl start postfix\n> ```\n\n3：添加GitLab软件包存储库并安装软件包\n\n添加GitLab软件包存储库\n>\n> ```\n> curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ee/script.rpm.sh | sudo bash\n> ```\n\n接下来，安装gitLab。安装过程是自动的，安装成功后通过URL 访问，如果你需要配置https，请参考 https://docs.gitlab.com/omnibus/settings/nginx.html#enable-https\n>\n> ```\n> sudo EXTERNAL_URL=\"http://gitlab.example.com\" yum install -y gitlab-ee\n> ```\n\n```\nEXTERNAL_URL 填写你要访问的地址，因为现在在测试环境我们用ip代替（192.168.1.6）\n```\n\n完成以上步骤，gitLab算是搭建完成了。\n\nGitLab常用命令\n>\n> ```none\n> sudo gitlab-ctl start    # 启动所有 gitlab 组件；\n> sudo gitlab-ctl stop        # 停止所有 gitlab 组件；\n> sudo gitlab-ctl restart        # 重启所有 gitlab 组件；\n> sudo gitlab-ctl status        # 查看服务状态；\n> sudo gitlab-ctl reconfigure        # 启动服务；\n> sudo vim /etc/gitlab/gitlab.rb        # 修改默认的配置文件；\n> gitlab-rake gitlab:check SANITIZE=true --trace    # 检查gitlab；\n> sudo gitlab-ctl tail        # 查看日志；\n> ```\n\ngitlab如何使用，登录gitLab后,慢慢玩吧！玩多了就会了\n\ngitLab一些小问题\n\n1:复制项目的url地址，发现port丢失\n\n解决：打开 /var/opt/gitlab/gitlab-rails/etc 目录\n\n修改 gitlab.yml 文件，将端口改成你想要的端口号 ! !\n![gitLab-搭建](gitLab-搭建/1550803434.jpg)","source":"_posts/gitLab-搭建.md","raw":"---\ntitle: gitLab 搭建\ndate: 2019-02-22 10:42:28\ntags:\n- github\n- linux\n- CentOS\n---\n今天我们说一下怎么在Linux搭建gitLab，具体步骤如下：\n\n打开该地址 [https://about.gitlab.com/installation/](https://about.gitlab.com/installation/#centos-7) 这个是官方提供安装文档，具体我们来操作一下\n\n1：根据操作系统版本寻找对应的文档\n\n2：安装和配置相应的依赖\n\nOn CentOS 7 (and RedHat/Oracle/Scientific Linux 7), 以下命令可以使http和ssh允许在防火墙下能被访问\n>\n> ```\n> sudo yum install -y curl policycoreutils-python openssh-server\n> sudo systemctl enable sshd\n> sudo systemctl start sshd\n> sudo firewall-cmd --permanent --add-service=http\n> sudo systemctl reload firewalld\n> ```\n\n接下来，安装 Postfix 用于发送邮件。如果你想用其他的方式发送邮件，请跳过该步骤并在gitLab 安装之后，配置其他的邮件服务器。\n>\n> ```\n> sudo yum install postfix\n> sudo systemctl enable postfix\n> sudo systemctl start postfix\n> ```\n\n3：添加GitLab软件包存储库并安装软件包\n\n添加GitLab软件包存储库\n>\n> ```\n> curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ee/script.rpm.sh | sudo bash\n> ```\n\n接下来，安装gitLab。安装过程是自动的，安装成功后通过URL 访问，如果你需要配置https，请参考 https://docs.gitlab.com/omnibus/settings/nginx.html#enable-https\n>\n> ```\n> sudo EXTERNAL_URL=\"http://gitlab.example.com\" yum install -y gitlab-ee\n> ```\n\n```\nEXTERNAL_URL 填写你要访问的地址，因为现在在测试环境我们用ip代替（192.168.1.6）\n```\n\n完成以上步骤，gitLab算是搭建完成了。\n\nGitLab常用命令\n>\n> ```none\n> sudo gitlab-ctl start    # 启动所有 gitlab 组件；\n> sudo gitlab-ctl stop        # 停止所有 gitlab 组件；\n> sudo gitlab-ctl restart        # 重启所有 gitlab 组件；\n> sudo gitlab-ctl status        # 查看服务状态；\n> sudo gitlab-ctl reconfigure        # 启动服务；\n> sudo vim /etc/gitlab/gitlab.rb        # 修改默认的配置文件；\n> gitlab-rake gitlab:check SANITIZE=true --trace    # 检查gitlab；\n> sudo gitlab-ctl tail        # 查看日志；\n> ```\n\ngitlab如何使用，登录gitLab后,慢慢玩吧！玩多了就会了\n\ngitLab一些小问题\n\n1:复制项目的url地址，发现port丢失\n\n解决：打开 /var/opt/gitlab/gitlab-rails/etc 目录\n\n修改 gitlab.yml 文件，将端口改成你想要的端口号 ! !\n![gitLab-搭建](gitLab-搭建/1550803434.jpg)","slug":"gitLab-搭建","published":1,"updated":"2019-07-14T03:11:26.961Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8mkctug000l4osx1ethd54x","content":"<p>今天我们说一下怎么在Linux搭建gitLab，具体步骤如下：</p>\n<p>打开该地址 <a href=\"https://about.gitlab.com/installation/#centos-7\" target=\"_blank\" rel=\"noopener\">https://about.gitlab.com/installation/</a> 这个是官方提供安装文档，具体我们来操作一下</p>\n<p>1：根据操作系统版本寻找对应的文档</p>\n<p>2：安装和配置相应的依赖</p>\n<p>On CentOS 7 (and RedHat/Oracle/Scientific Linux 7), 以下命令可以使http和ssh允许在防火墙下能被访问</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; sudo yum install -y curl policycoreutils-python openssh-server</span><br><span class=\"line\">&gt; sudo systemctl enable sshd</span><br><span class=\"line\">&gt; sudo systemctl start sshd</span><br><span class=\"line\">&gt; sudo firewall-cmd --permanent --add-service=http</span><br><span class=\"line\">&gt; sudo systemctl reload firewalld</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>接下来，安装 Postfix 用于发送邮件。如果你想用其他的方式发送邮件，请跳过该步骤并在gitLab 安装之后，配置其他的邮件服务器。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; sudo yum install postfix</span><br><span class=\"line\">&gt; sudo systemctl enable postfix</span><br><span class=\"line\">&gt; sudo systemctl start postfix</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>3：添加GitLab软件包存储库并安装软件包</p>\n<p>添加GitLab软件包存储库</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ee/script.rpm.sh | sudo bash</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>接下来，安装gitLab。安装过程是自动的，安装成功后通过URL 访问，如果你需要配置https，请参考 <a href=\"https://docs.gitlab.com/omnibus/settings/nginx.html#enable-https\" target=\"_blank\" rel=\"noopener\">https://docs.gitlab.com/omnibus/settings/nginx.html#enable-https</a></p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; sudo EXTERNAL_URL=&quot;http://gitlab.example.com&quot; yum install -y gitlab-ee</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EXTERNAL_URL 填写你要访问的地址，因为现在在测试环境我们用ip代替（192.168.1.6）</span><br></pre></td></tr></table></figure>\n<p>完成以上步骤，gitLab算是搭建完成了。</p>\n<p>GitLab常用命令</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; sudo gitlab-ctl start    # 启动所有 gitlab 组件；</span><br><span class=\"line\">&gt; sudo gitlab-ctl stop        # 停止所有 gitlab 组件；</span><br><span class=\"line\">&gt; sudo gitlab-ctl restart        # 重启所有 gitlab 组件；</span><br><span class=\"line\">&gt; sudo gitlab-ctl status        # 查看服务状态；</span><br><span class=\"line\">&gt; sudo gitlab-ctl reconfigure        # 启动服务；</span><br><span class=\"line\">&gt; sudo vim /etc/gitlab/gitlab.rb        # 修改默认的配置文件；</span><br><span class=\"line\">&gt; gitlab-rake gitlab:check SANITIZE=true --trace    # 检查gitlab；</span><br><span class=\"line\">&gt; sudo gitlab-ctl tail        # 查看日志；</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>gitlab如何使用，登录gitLab后,慢慢玩吧！玩多了就会了</p>\n<p>gitLab一些小问题</p>\n<p>1:复制项目的url地址，发现port丢失</p>\n<p>解决：打开 /var/opt/gitlab/gitlab-rails/etc 目录</p>\n<p>修改 gitlab.yml 文件，将端口改成你想要的端口号 ! !<br><img src=\"/2019/02/22/gitLab-搭建/1550803434.jpg\" alt=\"gitLab-搭建\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>今天我们说一下怎么在Linux搭建gitLab，具体步骤如下：</p>\n<p>打开该地址 <a href=\"https://about.gitlab.com/installation/#centos-7\" target=\"_blank\" rel=\"noopener\">https://about.gitlab.com/installation/</a> 这个是官方提供安装文档，具体我们来操作一下</p>\n<p>1：根据操作系统版本寻找对应的文档</p>\n<p>2：安装和配置相应的依赖</p>\n<p>On CentOS 7 (and RedHat/Oracle/Scientific Linux 7), 以下命令可以使http和ssh允许在防火墙下能被访问</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; sudo yum install -y curl policycoreutils-python openssh-server</span><br><span class=\"line\">&gt; sudo systemctl enable sshd</span><br><span class=\"line\">&gt; sudo systemctl start sshd</span><br><span class=\"line\">&gt; sudo firewall-cmd --permanent --add-service=http</span><br><span class=\"line\">&gt; sudo systemctl reload firewalld</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>接下来，安装 Postfix 用于发送邮件。如果你想用其他的方式发送邮件，请跳过该步骤并在gitLab 安装之后，配置其他的邮件服务器。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; sudo yum install postfix</span><br><span class=\"line\">&gt; sudo systemctl enable postfix</span><br><span class=\"line\">&gt; sudo systemctl start postfix</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>3：添加GitLab软件包存储库并安装软件包</p>\n<p>添加GitLab软件包存储库</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ee/script.rpm.sh | sudo bash</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>接下来，安装gitLab。安装过程是自动的，安装成功后通过URL 访问，如果你需要配置https，请参考 <a href=\"https://docs.gitlab.com/omnibus/settings/nginx.html#enable-https\" target=\"_blank\" rel=\"noopener\">https://docs.gitlab.com/omnibus/settings/nginx.html#enable-https</a></p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; sudo EXTERNAL_URL=&quot;http://gitlab.example.com&quot; yum install -y gitlab-ee</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EXTERNAL_URL 填写你要访问的地址，因为现在在测试环境我们用ip代替（192.168.1.6）</span><br></pre></td></tr></table></figure>\n<p>完成以上步骤，gitLab算是搭建完成了。</p>\n<p>GitLab常用命令</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; sudo gitlab-ctl start    # 启动所有 gitlab 组件；</span><br><span class=\"line\">&gt; sudo gitlab-ctl stop        # 停止所有 gitlab 组件；</span><br><span class=\"line\">&gt; sudo gitlab-ctl restart        # 重启所有 gitlab 组件；</span><br><span class=\"line\">&gt; sudo gitlab-ctl status        # 查看服务状态；</span><br><span class=\"line\">&gt; sudo gitlab-ctl reconfigure        # 启动服务；</span><br><span class=\"line\">&gt; sudo vim /etc/gitlab/gitlab.rb        # 修改默认的配置文件；</span><br><span class=\"line\">&gt; gitlab-rake gitlab:check SANITIZE=true --trace    # 检查gitlab；</span><br><span class=\"line\">&gt; sudo gitlab-ctl tail        # 查看日志；</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>gitlab如何使用，登录gitLab后,慢慢玩吧！玩多了就会了</p>\n<p>gitLab一些小问题</p>\n<p>1:复制项目的url地址，发现port丢失</p>\n<p>解决：打开 /var/opt/gitlab/gitlab-rails/etc 目录</p>\n<p>修改 gitlab.yml 文件，将端口改成你想要的端口号 ! !<br><img src=\"/2019/02/22/gitLab-搭建/1550803434.jpg\" alt=\"gitLab-搭建\"></p>\n"},{"layout":"w","title":"shiro 笔记（一）","date":"2019-03-15T01:42:32.000Z","_content":"","source":"_posts/shiro-笔记（一）.md","raw":"---\nlayout: w\ntitle: shiro 笔记（一）\ndate: 2019-03-15 09:42:32\ntags:\n---\n","slug":"shiro-笔记（一）","published":1,"updated":"2019-07-14T03:11:26.977Z","comments":1,"photos":[],"link":"","_id":"ck8mkctui000o4osx60q88j4u","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"spring boot 如何创建和使用freemaker自定义标签","date":"2019-02-19T10:06:11.000Z","_content":"\n由于spring boot 简化了配置文件的，所以之前在配置文件中实现自定义freemaker标签，统一通过Java类实现。\n\n之前spring MVC 的实现步骤：\n\n    <!-- =========================freemarker VIEW定义 ========================= -->\n    <bean id=\"freeMarkerConfig\" class=\"org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer\">\n       <property name=\"templateLoaderPaths\" value=\"/WEB-INF/view2.0/\"/>\n       <property name=\"freemarkerVariables\">\n          <map>\n             <!-- shiro freemarker标签  使用自定义标签-->\n             <entry key=\"shiro\">\n                <bean class=\"com.yuelinghui.shiro.freemarker.ShiroTags\"/>\n             </entry>\n          </map>\n       </property>\n    </bean>\n    那么spring boot 中如何实现，具体实现如下：\n    \n    创建 FreemarkerConfig ，\n    @Component\n    public class FreemarkerConfig {\n    \n      @Autowired\n      private Configuration configuration;\n    \n      @PostConstruct\n      public void setSharedVariable() {\n    // 创建自定义标签对象\n        configuration.setSharedVariable(\"shiro\", new ShiroTags());\n      }\n    \n    }\n    通过上述方法可以实现引入freemaker 自定义标签\n","source":"_posts/spring-boot-如何创建和使用freemaker自定义标签.md","raw":"---\ntitle: spring boot 如何创建和使用freemaker自定义标签\ndate: 2019-02-19 18:06:11\ntags:\n---\n\n由于spring boot 简化了配置文件的，所以之前在配置文件中实现自定义freemaker标签，统一通过Java类实现。\n\n之前spring MVC 的实现步骤：\n\n    <!-- =========================freemarker VIEW定义 ========================= -->\n    <bean id=\"freeMarkerConfig\" class=\"org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer\">\n       <property name=\"templateLoaderPaths\" value=\"/WEB-INF/view2.0/\"/>\n       <property name=\"freemarkerVariables\">\n          <map>\n             <!-- shiro freemarker标签  使用自定义标签-->\n             <entry key=\"shiro\">\n                <bean class=\"com.yuelinghui.shiro.freemarker.ShiroTags\"/>\n             </entry>\n          </map>\n       </property>\n    </bean>\n    那么spring boot 中如何实现，具体实现如下：\n    \n    创建 FreemarkerConfig ，\n    @Component\n    public class FreemarkerConfig {\n    \n      @Autowired\n      private Configuration configuration;\n    \n      @PostConstruct\n      public void setSharedVariable() {\n    // 创建自定义标签对象\n        configuration.setSharedVariable(\"shiro\", new ShiroTags());\n      }\n    \n    }\n    通过上述方法可以实现引入freemaker 自定义标签\n","slug":"spring-boot-如何创建和使用freemaker自定义标签","published":1,"updated":"2019-07-14T03:11:26.977Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8mkctuj000q4osxf8lzjl60","content":"<p>由于spring boot 简化了配置文件的，所以之前在配置文件中实现自定义freemaker标签，统一通过Java类实现。</p>\n<p>之前spring MVC 的实现步骤：</p>\n<pre><code>&lt;!-- =========================freemarker VIEW定义 ========================= --&gt;\n&lt;bean id=&quot;freeMarkerConfig&quot; class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer&quot;&gt;\n   &lt;property name=&quot;templateLoaderPaths&quot; value=&quot;/WEB-INF/view2.0/&quot;/&gt;\n   &lt;property name=&quot;freemarkerVariables&quot;&gt;\n      &lt;map&gt;\n         &lt;!-- shiro freemarker标签  使用自定义标签--&gt;\n         &lt;entry key=&quot;shiro&quot;&gt;\n            &lt;bean class=&quot;com.yuelinghui.shiro.freemarker.ShiroTags&quot;/&gt;\n         &lt;/entry&gt;\n      &lt;/map&gt;\n   &lt;/property&gt;\n&lt;/bean&gt;\n那么spring boot 中如何实现，具体实现如下：\n\n创建 FreemarkerConfig ，\n@Component\npublic class FreemarkerConfig {\n\n  @Autowired\n  private Configuration configuration;\n\n  @PostConstruct\n  public void setSharedVariable() {\n// 创建自定义标签对象\n    configuration.setSharedVariable(&quot;shiro&quot;, new ShiroTags());\n  }\n\n}\n通过上述方法可以实现引入freemaker 自定义标签\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>由于spring boot 简化了配置文件的，所以之前在配置文件中实现自定义freemaker标签，统一通过Java类实现。</p>\n<p>之前spring MVC 的实现步骤：</p>\n<pre><code>&lt;!-- =========================freemarker VIEW定义 ========================= --&gt;\n&lt;bean id=&quot;freeMarkerConfig&quot; class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer&quot;&gt;\n   &lt;property name=&quot;templateLoaderPaths&quot; value=&quot;/WEB-INF/view2.0/&quot;/&gt;\n   &lt;property name=&quot;freemarkerVariables&quot;&gt;\n      &lt;map&gt;\n         &lt;!-- shiro freemarker标签  使用自定义标签--&gt;\n         &lt;entry key=&quot;shiro&quot;&gt;\n            &lt;bean class=&quot;com.yuelinghui.shiro.freemarker.ShiroTags&quot;/&gt;\n         &lt;/entry&gt;\n      &lt;/map&gt;\n   &lt;/property&gt;\n&lt;/bean&gt;\n那么spring boot 中如何实现，具体实现如下：\n\n创建 FreemarkerConfig ，\n@Component\npublic class FreemarkerConfig {\n\n  @Autowired\n  private Configuration configuration;\n\n  @PostConstruct\n  public void setSharedVariable() {\n// 创建自定义标签对象\n    configuration.setSharedVariable(&quot;shiro&quot;, new ShiroTags());\n  }\n\n}\n通过上述方法可以实现引入freemaker 自定义标签\n</code></pre>"},{"title":"spring boot 学习笔记","date":"2019-02-18T09:06:43.000Z","_content":"1：Spring Boot 定制URL匹配规则的方法\n\n昨天使用spring boot 做了一个后台管理系统，再方法请求时由于带了后缀导致不能找到对应的controller。原因是spring boot 路由规则设置了真匹配，比如 请求你发起请求 /index ，它只能匹配 /home 路径的 带后缀的一律不匹配。那么如果想达到匹配需求以下步骤：\n\n1：启动类 extends WebMvcConfigurationSupport\n\n2：重写configurePathMatch方法\n\n    @SpringBootApplication\n    public class DreamAdminApplication extends WebMvcConfigurationSupport {\n    \n    /**\n     * 1、 extends WebMvcConfigurationSupport\n     * 2、重写下面方法;\n     * setUseSuffixPatternMatch : 设置是否是后缀模式匹配，如“/index ”是否匹配/index.*，默认真即匹配；\n     * setUseTrailingSlashMatch : 设置是否自动后缀路径模式匹配，如“/index ”是否匹配“/index /”，默认真即匹配；\n     */\n    @Override\n    public void configurePathMatch(PathMatchConfigurer configurer) {\n        configurer.setUseSuffixPatternMatch(true);\n    }\n    \n    \n    @Override\n    public void addResourceHandlers(ResourceHandlerRegistry registry) {\n        registry.addResourceHandler(\"/static/**\").addResourceLocations(\"classpath:/static/\");\n        super.addResourceHandlers(registry);\n    }\n    \n    public static void main(String[] args) {\n        SpringApplication.run(DreamAdminApplication.class, args);\n    }\n    }\n2：Spring Boot 自定义静态资源映射目录\n\n由于继承了WebMvcConfigurationSupport这个类，导致静态文件出现404的问题，所以需要我们自定义静态资源映射目录的，具体实现只需要重写（WebMvcConfigurationSupport ）的addResourceHandlers方法即可。\n\nregistry.addResourceHandler(“/static/**”).addResourceLocations(“classpath:/static/“);\n\n关于 WebMvcConfigurationSupport 提供的方法，后续再一一讲解。","source":"_posts/spring boot 学习笔记.md","raw":"---\ntitle: spring boot 学习笔记\ndate: 2019-02-18 17:06:43\n---\n1：Spring Boot 定制URL匹配规则的方法\n\n昨天使用spring boot 做了一个后台管理系统，再方法请求时由于带了后缀导致不能找到对应的controller。原因是spring boot 路由规则设置了真匹配，比如 请求你发起请求 /index ，它只能匹配 /home 路径的 带后缀的一律不匹配。那么如果想达到匹配需求以下步骤：\n\n1：启动类 extends WebMvcConfigurationSupport\n\n2：重写configurePathMatch方法\n\n    @SpringBootApplication\n    public class DreamAdminApplication extends WebMvcConfigurationSupport {\n    \n    /**\n     * 1、 extends WebMvcConfigurationSupport\n     * 2、重写下面方法;\n     * setUseSuffixPatternMatch : 设置是否是后缀模式匹配，如“/index ”是否匹配/index.*，默认真即匹配；\n     * setUseTrailingSlashMatch : 设置是否自动后缀路径模式匹配，如“/index ”是否匹配“/index /”，默认真即匹配；\n     */\n    @Override\n    public void configurePathMatch(PathMatchConfigurer configurer) {\n        configurer.setUseSuffixPatternMatch(true);\n    }\n    \n    \n    @Override\n    public void addResourceHandlers(ResourceHandlerRegistry registry) {\n        registry.addResourceHandler(\"/static/**\").addResourceLocations(\"classpath:/static/\");\n        super.addResourceHandlers(registry);\n    }\n    \n    public static void main(String[] args) {\n        SpringApplication.run(DreamAdminApplication.class, args);\n    }\n    }\n2：Spring Boot 自定义静态资源映射目录\n\n由于继承了WebMvcConfigurationSupport这个类，导致静态文件出现404的问题，所以需要我们自定义静态资源映射目录的，具体实现只需要重写（WebMvcConfigurationSupport ）的addResourceHandlers方法即可。\n\nregistry.addResourceHandler(“/static/**”).addResourceLocations(“classpath:/static/“);\n\n关于 WebMvcConfigurationSupport 提供的方法，后续再一一讲解。","slug":"spring boot 学习笔记","published":1,"updated":"2019-07-14T03:11:26.977Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8mkctul000s4osx4ynvlet1","content":"<p>1：Spring Boot 定制URL匹配规则的方法</p>\n<p>昨天使用spring boot 做了一个后台管理系统，再方法请求时由于带了后缀导致不能找到对应的controller。原因是spring boot 路由规则设置了真匹配，比如 请求你发起请求 /index ，它只能匹配 /home 路径的 带后缀的一律不匹配。那么如果想达到匹配需求以下步骤：</p>\n<p>1：启动类 extends WebMvcConfigurationSupport</p>\n<p>2：重写configurePathMatch方法</p>\n<pre><code>@SpringBootApplication\npublic class DreamAdminApplication extends WebMvcConfigurationSupport {\n\n/**\n * 1、 extends WebMvcConfigurationSupport\n * 2、重写下面方法;\n * setUseSuffixPatternMatch : 设置是否是后缀模式匹配，如“/index ”是否匹配/index.*，默认真即匹配；\n * setUseTrailingSlashMatch : 设置是否自动后缀路径模式匹配，如“/index ”是否匹配“/index /”，默认真即匹配；\n */\n@Override\npublic void configurePathMatch(PathMatchConfigurer configurer) {\n    configurer.setUseSuffixPatternMatch(true);\n}\n\n\n@Override\npublic void addResourceHandlers(ResourceHandlerRegistry registry) {\n    registry.addResourceHandler(&quot;/static/**&quot;).addResourceLocations(&quot;classpath:/static/&quot;);\n    super.addResourceHandlers(registry);\n}\n\npublic static void main(String[] args) {\n    SpringApplication.run(DreamAdminApplication.class, args);\n}\n}\n</code></pre><p>2：Spring Boot 自定义静态资源映射目录</p>\n<p>由于继承了WebMvcConfigurationSupport这个类，导致静态文件出现404的问题，所以需要我们自定义静态资源映射目录的，具体实现只需要重写（WebMvcConfigurationSupport ）的addResourceHandlers方法即可。</p>\n<p>registry.addResourceHandler(“/static/**”).addResourceLocations(“classpath:/static/“);</p>\n<p>关于 WebMvcConfigurationSupport 提供的方法，后续再一一讲解。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>1：Spring Boot 定制URL匹配规则的方法</p>\n<p>昨天使用spring boot 做了一个后台管理系统，再方法请求时由于带了后缀导致不能找到对应的controller。原因是spring boot 路由规则设置了真匹配，比如 请求你发起请求 /index ，它只能匹配 /home 路径的 带后缀的一律不匹配。那么如果想达到匹配需求以下步骤：</p>\n<p>1：启动类 extends WebMvcConfigurationSupport</p>\n<p>2：重写configurePathMatch方法</p>\n<pre><code>@SpringBootApplication\npublic class DreamAdminApplication extends WebMvcConfigurationSupport {\n\n/**\n * 1、 extends WebMvcConfigurationSupport\n * 2、重写下面方法;\n * setUseSuffixPatternMatch : 设置是否是后缀模式匹配，如“/index ”是否匹配/index.*，默认真即匹配；\n * setUseTrailingSlashMatch : 设置是否自动后缀路径模式匹配，如“/index ”是否匹配“/index /”，默认真即匹配；\n */\n@Override\npublic void configurePathMatch(PathMatchConfigurer configurer) {\n    configurer.setUseSuffixPatternMatch(true);\n}\n\n\n@Override\npublic void addResourceHandlers(ResourceHandlerRegistry registry) {\n    registry.addResourceHandler(&quot;/static/**&quot;).addResourceLocations(&quot;classpath:/static/&quot;);\n    super.addResourceHandlers(registry);\n}\n\npublic static void main(String[] args) {\n    SpringApplication.run(DreamAdminApplication.class, args);\n}\n}\n</code></pre><p>2：Spring Boot 自定义静态资源映射目录</p>\n<p>由于继承了WebMvcConfigurationSupport这个类，导致静态文件出现404的问题，所以需要我们自定义静态资源映射目录的，具体实现只需要重写（WebMvcConfigurationSupport ）的addResourceHandlers方法即可。</p>\n<p>registry.addResourceHandler(“/static/**”).addResourceLocations(“classpath:/static/“);</p>\n<p>关于 WebMvcConfigurationSupport 提供的方法，后续再一一讲解。</p>\n"},{"title":"了解Java中的代理","date":"2019-03-15T01:46:49.000Z","_content":"# 1. 什么是代理？\n代理能代替我们去做很多事情，就举一个买票的例子，我们如果去火车站买票，需要搭车去火车站，然后排队买票，买到票回家这一系列的操作都需要自己去完成，万一碰到每票的情况还需要明天继续跑一趟。这时你是不是想有一个人帮你去做，做成之后你给他一点报酬，那么你是不是不用去火车站买票了，可以做一些自己的事了。代替你去买票的过程其实就是代理的过程。\n# 2. 代理的实现？\n在没有使用代理之前，我们需要自己去实现很多功能，现在我通过工人工作和打卡两个功能进行说明\n* 工人接口 有一个默认方法打卡和一个工作的方法\n```\npublic interface Worker {\n\tpublic void work();\n    default void punch() {\n        System.out.println(\"上下班打卡。。。。。。。。。。。。。。。\");\n    }\n}\n```\n* 工人A 实现类 ，实现接口的工作方法，并在上下班前打卡\n```\n/**\n * 第一个工人\n * @author xla\n */\npublic class WorkFirst implements Worker {\n\n    @Override\n    public void work() {\n        punch();\n        System.out.println(\"doing First work\");\n        punch();\n    }\n\n}\n```\n* 工人B 实现类，实现接口的工作方法，并在上下班前打卡\n```\n/**\n * 第二个工人\n * @author xla\n */\npublic class WorkSecond implements Worker {\n\n    /**\n     * 他们在工作前后需要打卡\n     */\n    @Override\n    public void work() {\n        punch();\n        System.out.println(\"do second job\");\n        punch();\n    }\n}\n```\n上述代码在没有使用代理前是这么实现的，但是你有没有发现一个问题，上述工人在工作前后都调用了punch方法，显得有些重复。那我们通过什么可以解决这个问题呢？代理？？\n\n目前我们使用的Java 代理有两种，静态代理和动态代理下面我们通过例子来实现：\n* 静态代理\n我们创建一个代理类 WorkProxy\n```\npublic class WorkProxy implements Worker {\n    private Worker worker;\n\n    public WorkProxy(Worker worker) {\n        this.worker = worker;\n    }\n\n    @Override\n    public void work() {\n          punch();\n          worker.work();\n          punch();\n    }\n}\n```\n工人A 中的work 方法就不需要再前后调用打卡功能，只需要将自己的对象交给代理类让代理类去实现打卡功能代码如下：\n```\npublic static void main(String[] args) {\n        Worker worker = new WorkFirst();\n        WorkProxy workProxy = new WorkProxy(worker);\n        workProxy.work();\n }\n```\n结果如下：\n```\n上下班打卡。。。。。。。。。。。。。。。\ndoing First work\n上下班打卡。。。。。。。。。。。。。。。\n```\n* 动态代理\n\n动态代理，顾名思义就是代理类是在运行过程中动态创建的，实现动态的过程我们需要创建一个中介类，实现InvocationHandler 接口作为调用处理器”拦截“对代理类方法的调用。中介类实现如下：\n```\npublic class WorkDynamicProxy implements InvocationHandler {\n    private Worker worker;\n\n    public  WorkDynamicProxy(Worker worker) {\n        this.worker = worker;\n    }\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        worker.punch();\n        Object result = method.invoke(worker, args);\n        worker.punch();\n        return result;\n    }\n}\n```\n接下来我们来测试一下：\n```\npublic static void main(String[] args) {\n        WorkDynamicProxy workDynamicProxy = new WorkDynamicProxy(new WorkSecond());\n        //获取代理类实例worker\n        Worker worker = (Worker)(Proxy.newProxyInstance(Worker.class.getClassLoader(), new Class[] {Worker.class}, workDynamicProxy));\n        //通过代理类对象调用代理类方法，实际上会转到invoke方法调用\n        worker.work();\n    }\n```\n打印结果如下：\n```\n上下班打卡。。。。。。。。。。。。。。。\ndo second job\n上下班打卡。。。。。。。。。。。。。。。\n```\n现在我们需要考虑一几个问题？动态代理的过程？为啥动态代理需要使用接口？现在我们来解决第一个问题：\n* 动态代理的过程？\n从上述代码中我们可以看出，通过newProxyInstance方法获取一个代理类的，调用代理类的方法都会执行invoke(Object proxy, Method method, Object[] args)方法，解释三个参数\nproxy 委托类\nmethod 代理类的方法\nargs 调用代理类的方法参入的参数\n* 为啥动态代理需要使用接口？\n我们再次查看源码newProxyInstance方法的实现：\n```\npublic static Object newProxyInstance(ClassLoader loader,\n                                          Class<?>[] interfaces,\n                                          InvocationHandler h)\n        throws IllegalArgumentException\n    {\n        Objects.requireNonNull(h);\n\n        final Class<?>[] intfs = interfaces.clone();\n        final SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            checkProxyAccess(Reflection.getCallerClass(), loader, intfs);\n        }\n\n        /*\n         * Look up or generate the designated proxy class.\n         */\n        Class<?> cl = getProxyClass0(loader, intfs);\n\n        /*\n         * Invoke its constructor with the designated invocation handler.\n         */\n        try {\n            if (sm != null) {\n                checkNewProxyPermission(Reflection.getCallerClass(), cl);\n            }\n\n            final Constructor<?> cons = cl.getConstructor(constructorParams);\n            final InvocationHandler ih = h;\n            if (!Modifier.isPublic(cl.getModifiers())) {\n                AccessController.doPrivileged(new PrivilegedAction<Void>() {\n                    public Void run() {\n                        cons.setAccessible(true);\n                        return null;\n                    }\n                });\n            }\n            return cons.newInstance(new Object[]{h});\n        }\n        ....\n    }\n```\n从源码上，首先进行一系列的判断逻辑，然后到了\nClass<?> cl = getProxyClass0(loader, intfs);\n获取代理类的Class 对象，接下来执行\n final Constructor<?> cons = cl.getConstructor(constructorParams);\n 获取Class的构造对象，通过cons.newInstance(new Object[]{h}); 返回一个代理类实例对象，具体参考 [Java反射](http://www.xulian.net.cn/2019/02/20/java-%E5%8F%8D%E5%B0%84%E7%AC%94%E8%AE%B0/) 。\n 目前我们只知道代理类对象的创建过程，但是为啥只能传入接口还是得不到解决，那我们只能继续查看getProxyClass0源码：\n 具体实现步骤：\n 1. 验证，通过类加载对象和接口列表获取代理类的Class对象，如果缓存中存在则返回，没有就通过代理类工厂创建代理类\n 2. 创建代理类\n通过ProxyClassFactory工厂创建代理类，核心代码如下\n```\nString proxyName = proxyPkg + proxyClassNamePrefix + num;\nbyte[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags);\ndefineClass0(loader, proxyName, proxyClassFile, 0, proxyClassFile.length);\n```\n定义一个类的名称，通过传入的接口列表和访问标志生成一个代理类的字节码，最后调用defineClass0方法将字节码加载到类加载器中，创建一个代理类。\n现在我们来实现将代理类的字节码写入本地，查看具体代理类的信息：\n```\nbyte[] proxyClassFile = ProxyGenerator.generateProxyClass(\n                \"$proxy1\", new Class[] {Worker.class}, Modifier.PUBLIC);\n        FileOutputStream fos = null;\n        try {\n            fos = new FileOutputStream(\"D:/$proxy1.class\");\n            fos.write(proxyClassFile);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                fos.flush();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n```\n通过反编译启查看字节码：\n```\npublic class $proxy1 extends Proxy  implements Worker {\n....\npublic final void work()  throws  {\n    try  {\n      this.h.invoke(this, m3, null);\n      return;\n    }\n    ....\n  }\n....\n}\n```\n现在我们终于得到答案，this.h.invoke(this, m3, null); 很好得验证了之前执行work（）方法其实是调用了中介类的invoke方法结论，还有一个问题，为啥动态代理需要使用接口，主要原因是代理类已经继承了Proxy类，Java不支持多继承所以导致动态代理需要使用接口，接口支持多继承。终于可以说服自己为啥动态代理需要接口了。。。。。\n# 3. 总结\n我们大概讲了一下什么是代理，然后通过例子，代码实现了Java中的代理，最后通过源码解释了Java动态代理的过程。。。\n\n\n参考文档：\n\njdk 8\n[JDK动态代理为什么必须针对接口？其与CGLIB的对比](https://www.cnblogs.com/frankliiu-java/articles/1896443.html)\n","source":"_posts/了解Java中的代理.md","raw":"---\ntitle: 了解Java中的代理\ndate: 2019-03-15 09:46:49\ntags:\n- JAVA\n---\n# 1. 什么是代理？\n代理能代替我们去做很多事情，就举一个买票的例子，我们如果去火车站买票，需要搭车去火车站，然后排队买票，买到票回家这一系列的操作都需要自己去完成，万一碰到每票的情况还需要明天继续跑一趟。这时你是不是想有一个人帮你去做，做成之后你给他一点报酬，那么你是不是不用去火车站买票了，可以做一些自己的事了。代替你去买票的过程其实就是代理的过程。\n# 2. 代理的实现？\n在没有使用代理之前，我们需要自己去实现很多功能，现在我通过工人工作和打卡两个功能进行说明\n* 工人接口 有一个默认方法打卡和一个工作的方法\n```\npublic interface Worker {\n\tpublic void work();\n    default void punch() {\n        System.out.println(\"上下班打卡。。。。。。。。。。。。。。。\");\n    }\n}\n```\n* 工人A 实现类 ，实现接口的工作方法，并在上下班前打卡\n```\n/**\n * 第一个工人\n * @author xla\n */\npublic class WorkFirst implements Worker {\n\n    @Override\n    public void work() {\n        punch();\n        System.out.println(\"doing First work\");\n        punch();\n    }\n\n}\n```\n* 工人B 实现类，实现接口的工作方法，并在上下班前打卡\n```\n/**\n * 第二个工人\n * @author xla\n */\npublic class WorkSecond implements Worker {\n\n    /**\n     * 他们在工作前后需要打卡\n     */\n    @Override\n    public void work() {\n        punch();\n        System.out.println(\"do second job\");\n        punch();\n    }\n}\n```\n上述代码在没有使用代理前是这么实现的，但是你有没有发现一个问题，上述工人在工作前后都调用了punch方法，显得有些重复。那我们通过什么可以解决这个问题呢？代理？？\n\n目前我们使用的Java 代理有两种，静态代理和动态代理下面我们通过例子来实现：\n* 静态代理\n我们创建一个代理类 WorkProxy\n```\npublic class WorkProxy implements Worker {\n    private Worker worker;\n\n    public WorkProxy(Worker worker) {\n        this.worker = worker;\n    }\n\n    @Override\n    public void work() {\n          punch();\n          worker.work();\n          punch();\n    }\n}\n```\n工人A 中的work 方法就不需要再前后调用打卡功能，只需要将自己的对象交给代理类让代理类去实现打卡功能代码如下：\n```\npublic static void main(String[] args) {\n        Worker worker = new WorkFirst();\n        WorkProxy workProxy = new WorkProxy(worker);\n        workProxy.work();\n }\n```\n结果如下：\n```\n上下班打卡。。。。。。。。。。。。。。。\ndoing First work\n上下班打卡。。。。。。。。。。。。。。。\n```\n* 动态代理\n\n动态代理，顾名思义就是代理类是在运行过程中动态创建的，实现动态的过程我们需要创建一个中介类，实现InvocationHandler 接口作为调用处理器”拦截“对代理类方法的调用。中介类实现如下：\n```\npublic class WorkDynamicProxy implements InvocationHandler {\n    private Worker worker;\n\n    public  WorkDynamicProxy(Worker worker) {\n        this.worker = worker;\n    }\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        worker.punch();\n        Object result = method.invoke(worker, args);\n        worker.punch();\n        return result;\n    }\n}\n```\n接下来我们来测试一下：\n```\npublic static void main(String[] args) {\n        WorkDynamicProxy workDynamicProxy = new WorkDynamicProxy(new WorkSecond());\n        //获取代理类实例worker\n        Worker worker = (Worker)(Proxy.newProxyInstance(Worker.class.getClassLoader(), new Class[] {Worker.class}, workDynamicProxy));\n        //通过代理类对象调用代理类方法，实际上会转到invoke方法调用\n        worker.work();\n    }\n```\n打印结果如下：\n```\n上下班打卡。。。。。。。。。。。。。。。\ndo second job\n上下班打卡。。。。。。。。。。。。。。。\n```\n现在我们需要考虑一几个问题？动态代理的过程？为啥动态代理需要使用接口？现在我们来解决第一个问题：\n* 动态代理的过程？\n从上述代码中我们可以看出，通过newProxyInstance方法获取一个代理类的，调用代理类的方法都会执行invoke(Object proxy, Method method, Object[] args)方法，解释三个参数\nproxy 委托类\nmethod 代理类的方法\nargs 调用代理类的方法参入的参数\n* 为啥动态代理需要使用接口？\n我们再次查看源码newProxyInstance方法的实现：\n```\npublic static Object newProxyInstance(ClassLoader loader,\n                                          Class<?>[] interfaces,\n                                          InvocationHandler h)\n        throws IllegalArgumentException\n    {\n        Objects.requireNonNull(h);\n\n        final Class<?>[] intfs = interfaces.clone();\n        final SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            checkProxyAccess(Reflection.getCallerClass(), loader, intfs);\n        }\n\n        /*\n         * Look up or generate the designated proxy class.\n         */\n        Class<?> cl = getProxyClass0(loader, intfs);\n\n        /*\n         * Invoke its constructor with the designated invocation handler.\n         */\n        try {\n            if (sm != null) {\n                checkNewProxyPermission(Reflection.getCallerClass(), cl);\n            }\n\n            final Constructor<?> cons = cl.getConstructor(constructorParams);\n            final InvocationHandler ih = h;\n            if (!Modifier.isPublic(cl.getModifiers())) {\n                AccessController.doPrivileged(new PrivilegedAction<Void>() {\n                    public Void run() {\n                        cons.setAccessible(true);\n                        return null;\n                    }\n                });\n            }\n            return cons.newInstance(new Object[]{h});\n        }\n        ....\n    }\n```\n从源码上，首先进行一系列的判断逻辑，然后到了\nClass<?> cl = getProxyClass0(loader, intfs);\n获取代理类的Class 对象，接下来执行\n final Constructor<?> cons = cl.getConstructor(constructorParams);\n 获取Class的构造对象，通过cons.newInstance(new Object[]{h}); 返回一个代理类实例对象，具体参考 [Java反射](http://www.xulian.net.cn/2019/02/20/java-%E5%8F%8D%E5%B0%84%E7%AC%94%E8%AE%B0/) 。\n 目前我们只知道代理类对象的创建过程，但是为啥只能传入接口还是得不到解决，那我们只能继续查看getProxyClass0源码：\n 具体实现步骤：\n 1. 验证，通过类加载对象和接口列表获取代理类的Class对象，如果缓存中存在则返回，没有就通过代理类工厂创建代理类\n 2. 创建代理类\n通过ProxyClassFactory工厂创建代理类，核心代码如下\n```\nString proxyName = proxyPkg + proxyClassNamePrefix + num;\nbyte[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags);\ndefineClass0(loader, proxyName, proxyClassFile, 0, proxyClassFile.length);\n```\n定义一个类的名称，通过传入的接口列表和访问标志生成一个代理类的字节码，最后调用defineClass0方法将字节码加载到类加载器中，创建一个代理类。\n现在我们来实现将代理类的字节码写入本地，查看具体代理类的信息：\n```\nbyte[] proxyClassFile = ProxyGenerator.generateProxyClass(\n                \"$proxy1\", new Class[] {Worker.class}, Modifier.PUBLIC);\n        FileOutputStream fos = null;\n        try {\n            fos = new FileOutputStream(\"D:/$proxy1.class\");\n            fos.write(proxyClassFile);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                fos.flush();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n```\n通过反编译启查看字节码：\n```\npublic class $proxy1 extends Proxy  implements Worker {\n....\npublic final void work()  throws  {\n    try  {\n      this.h.invoke(this, m3, null);\n      return;\n    }\n    ....\n  }\n....\n}\n```\n现在我们终于得到答案，this.h.invoke(this, m3, null); 很好得验证了之前执行work（）方法其实是调用了中介类的invoke方法结论，还有一个问题，为啥动态代理需要使用接口，主要原因是代理类已经继承了Proxy类，Java不支持多继承所以导致动态代理需要使用接口，接口支持多继承。终于可以说服自己为啥动态代理需要接口了。。。。。\n# 3. 总结\n我们大概讲了一下什么是代理，然后通过例子，代码实现了Java中的代理，最后通过源码解释了Java动态代理的过程。。。\n\n\n参考文档：\n\njdk 8\n[JDK动态代理为什么必须针对接口？其与CGLIB的对比](https://www.cnblogs.com/frankliiu-java/articles/1896443.html)\n","slug":"了解Java中的代理","published":1,"updated":"2019-07-14T03:11:26.978Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8mkctum000u4osx7pi9g7by","content":"<h1 id=\"1-什么是代理？\"><a href=\"#1-什么是代理？\" class=\"headerlink\" title=\"1. 什么是代理？\"></a>1. 什么是代理？</h1><p>代理能代替我们去做很多事情，就举一个买票的例子，我们如果去火车站买票，需要搭车去火车站，然后排队买票，买到票回家这一系列的操作都需要自己去完成，万一碰到每票的情况还需要明天继续跑一趟。这时你是不是想有一个人帮你去做，做成之后你给他一点报酬，那么你是不是不用去火车站买票了，可以做一些自己的事了。代替你去买票的过程其实就是代理的过程。</p>\n<h1 id=\"2-代理的实现？\"><a href=\"#2-代理的实现？\" class=\"headerlink\" title=\"2. 代理的实现？\"></a>2. 代理的实现？</h1><p>在没有使用代理之前，我们需要自己去实现很多功能，现在我通过工人工作和打卡两个功能进行说明</p>\n<ul>\n<li><p>工人接口 有一个默认方法打卡和一个工作的方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface Worker &#123;</span><br><span class=\"line\">\tpublic void work();</span><br><span class=\"line\">    default void punch() &#123;</span><br><span class=\"line\">        System.out.println(&quot;上下班打卡。。。。。。。。。。。。。。。&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>工人A 实现类 ，实现接口的工作方法，并在上下班前打卡</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 第一个工人</span><br><span class=\"line\"> * @author xla</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class WorkFirst implements Worker &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void work() &#123;</span><br><span class=\"line\">        punch();</span><br><span class=\"line\">        System.out.println(&quot;doing First work&quot;);</span><br><span class=\"line\">        punch();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>工人B 实现类，实现接口的工作方法，并在上下班前打卡</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 第二个工人</span><br><span class=\"line\"> * @author xla</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class WorkSecond implements Worker &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 他们在工作前后需要打卡</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void work() &#123;</span><br><span class=\"line\">        punch();</span><br><span class=\"line\">        System.out.println(&quot;do second job&quot;);</span><br><span class=\"line\">        punch();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>上述代码在没有使用代理前是这么实现的，但是你有没有发现一个问题，上述工人在工作前后都调用了punch方法，显得有些重复。那我们通过什么可以解决这个问题呢？代理？？</p>\n<p>目前我们使用的Java 代理有两种，静态代理和动态代理下面我们通过例子来实现：</p>\n<ul>\n<li>静态代理<br>我们创建一个代理类 WorkProxy<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class WorkProxy implements Worker &#123;</span><br><span class=\"line\">    private Worker worker;</span><br><span class=\"line\"></span><br><span class=\"line\">    public WorkProxy(Worker worker) &#123;</span><br><span class=\"line\">        this.worker = worker;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void work() &#123;</span><br><span class=\"line\">          punch();</span><br><span class=\"line\">          worker.work();</span><br><span class=\"line\">          punch();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>工人A 中的work 方法就不需要再前后调用打卡功能，只需要将自己的对象交给代理类让代理类去实现打卡功能代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">        Worker worker = new WorkFirst();</span><br><span class=\"line\">        WorkProxy workProxy = new WorkProxy(worker);</span><br><span class=\"line\">        workProxy.work();</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure></p>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">上下班打卡。。。。。。。。。。。。。。。</span><br><span class=\"line\">doing First work</span><br><span class=\"line\">上下班打卡。。。。。。。。。。。。。。。</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>动态代理</li>\n</ul>\n<p>动态代理，顾名思义就是代理类是在运行过程中动态创建的，实现动态的过程我们需要创建一个中介类，实现InvocationHandler 接口作为调用处理器”拦截“对代理类方法的调用。中介类实现如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class WorkDynamicProxy implements InvocationHandler &#123;</span><br><span class=\"line\">    private Worker worker;</span><br><span class=\"line\"></span><br><span class=\"line\">    public  WorkDynamicProxy(Worker worker) &#123;</span><br><span class=\"line\">        this.worker = worker;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class=\"line\">        worker.punch();</span><br><span class=\"line\">        Object result = method.invoke(worker, args);</span><br><span class=\"line\">        worker.punch();</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>接下来我们来测试一下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">        WorkDynamicProxy workDynamicProxy = new WorkDynamicProxy(new WorkSecond());</span><br><span class=\"line\">        //获取代理类实例worker</span><br><span class=\"line\">        Worker worker = (Worker)(Proxy.newProxyInstance(Worker.class.getClassLoader(), new Class[] &#123;Worker.class&#125;, workDynamicProxy));</span><br><span class=\"line\">        //通过代理类对象调用代理类方法，实际上会转到invoke方法调用</span><br><span class=\"line\">        worker.work();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>打印结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">上下班打卡。。。。。。。。。。。。。。。</span><br><span class=\"line\">do second job</span><br><span class=\"line\">上下班打卡。。。。。。。。。。。。。。。</span><br></pre></td></tr></table></figure></p>\n<p>现在我们需要考虑一几个问题？动态代理的过程？为啥动态代理需要使用接口？现在我们来解决第一个问题：</p>\n<ul>\n<li>动态代理的过程？<br>从上述代码中我们可以看出，通过newProxyInstance方法获取一个代理类的，调用代理类的方法都会执行invoke(Object proxy, Method method, Object[] args)方法，解释三个参数<br>proxy 委托类<br>method 代理类的方法<br>args 调用代理类的方法参入的参数</li>\n<li>为啥动态代理需要使用接口？<br>我们再次查看源码newProxyInstance方法的实现：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static Object newProxyInstance(ClassLoader loader,</span><br><span class=\"line\">                                          Class&lt;?&gt;[] interfaces,</span><br><span class=\"line\">                                          InvocationHandler h)</span><br><span class=\"line\">        throws IllegalArgumentException</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Objects.requireNonNull(h);</span><br><span class=\"line\"></span><br><span class=\"line\">        final Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class=\"line\">        final SecurityManager sm = System.getSecurityManager();</span><br><span class=\"line\">        if (sm != null) &#123;</span><br><span class=\"line\">            checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        /*</span><br><span class=\"line\">         * Look up or generate the designated proxy class.</span><br><span class=\"line\">         */</span><br><span class=\"line\">        Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class=\"line\"></span><br><span class=\"line\">        /*</span><br><span class=\"line\">         * Invoke its constructor with the designated invocation handler.</span><br><span class=\"line\">         */</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            if (sm != null) &#123;</span><br><span class=\"line\">                checkNewProxyPermission(Reflection.getCallerClass(), cl);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class=\"line\">            final InvocationHandler ih = h;</span><br><span class=\"line\">            if (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class=\"line\">                AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class=\"line\">                    public Void run() &#123;</span><br><span class=\"line\">                        cons.setAccessible(true);</span><br><span class=\"line\">                        return null;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return cons.newInstance(new Object[]&#123;h&#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ....</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>从源码上，首先进行一系列的判断逻辑，然后到了<br>Class&lt;?&gt; cl = getProxyClass0(loader, intfs);<br>获取代理类的Class 对象，接下来执行<br> final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);<br> 获取Class的构造对象，通过cons.newInstance(new Object[]{h}); 返回一个代理类实例对象，具体参考 <a href=\"http://www.xulian.net.cn/2019/02/20/java-%E5%8F%8D%E5%B0%84%E7%AC%94%E8%AE%B0/\" target=\"_blank\" rel=\"noopener\">Java反射</a> 。<br> 目前我们只知道代理类对象的创建过程，但是为啥只能传入接口还是得不到解决，那我们只能继续查看getProxyClass0源码：<br> 具体实现步骤：</p>\n<ol>\n<li>验证，通过类加载对象和接口列表获取代理类的Class对象，如果缓存中存在则返回，没有就通过代理类工厂创建代理类</li>\n<li>创建代理类<br>通过ProxyClassFactory工厂创建代理类，核心代码如下<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String proxyName = proxyPkg + proxyClassNamePrefix + num;</span><br><span class=\"line\">byte[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags);</span><br><span class=\"line\">defineClass0(loader, proxyName, proxyClassFile, 0, proxyClassFile.length);</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>定义一个类的名称，通过传入的接口列表和访问标志生成一个代理类的字节码，最后调用defineClass0方法将字节码加载到类加载器中，创建一个代理类。<br>现在我们来实现将代理类的字节码写入本地，查看具体代理类的信息：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">byte[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class=\"line\">                &quot;$proxy1&quot;, new Class[] &#123;Worker.class&#125;, Modifier.PUBLIC);</span><br><span class=\"line\">        FileOutputStream fos = null;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            fos = new FileOutputStream(&quot;D:/$proxy1.class&quot;);</span><br><span class=\"line\">            fos.write(proxyClassFile);</span><br><span class=\"line\">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; catch (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; finally &#123;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                fos.flush();</span><br><span class=\"line\">            &#125; catch (IOException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></p>\n<p>通过反编译启查看字节码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class $proxy1 extends Proxy  implements Worker &#123;</span><br><span class=\"line\">....</span><br><span class=\"line\">public final void work()  throws  &#123;</span><br><span class=\"line\">    try  &#123;</span><br><span class=\"line\">      this.h.invoke(this, m3, null);</span><br><span class=\"line\">      return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ....</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">....</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>现在我们终于得到答案，this.h.invoke(this, m3, null); 很好得验证了之前执行work（）方法其实是调用了中介类的invoke方法结论，还有一个问题，为啥动态代理需要使用接口，主要原因是代理类已经继承了Proxy类，Java不支持多继承所以导致动态代理需要使用接口，接口支持多继承。终于可以说服自己为啥动态代理需要接口了。。。。。</p>\n<h1 id=\"3-总结\"><a href=\"#3-总结\" class=\"headerlink\" title=\"3. 总结\"></a>3. 总结</h1><p>我们大概讲了一下什么是代理，然后通过例子，代码实现了Java中的代理，最后通过源码解释了Java动态代理的过程。。。</p>\n<p>参考文档：</p>\n<p>jdk 8<br><a href=\"https://www.cnblogs.com/frankliiu-java/articles/1896443.html\" target=\"_blank\" rel=\"noopener\">JDK动态代理为什么必须针对接口？其与CGLIB的对比</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-什么是代理？\"><a href=\"#1-什么是代理？\" class=\"headerlink\" title=\"1. 什么是代理？\"></a>1. 什么是代理？</h1><p>代理能代替我们去做很多事情，就举一个买票的例子，我们如果去火车站买票，需要搭车去火车站，然后排队买票，买到票回家这一系列的操作都需要自己去完成，万一碰到每票的情况还需要明天继续跑一趟。这时你是不是想有一个人帮你去做，做成之后你给他一点报酬，那么你是不是不用去火车站买票了，可以做一些自己的事了。代替你去买票的过程其实就是代理的过程。</p>\n<h1 id=\"2-代理的实现？\"><a href=\"#2-代理的实现？\" class=\"headerlink\" title=\"2. 代理的实现？\"></a>2. 代理的实现？</h1><p>在没有使用代理之前，我们需要自己去实现很多功能，现在我通过工人工作和打卡两个功能进行说明</p>\n<ul>\n<li><p>工人接口 有一个默认方法打卡和一个工作的方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface Worker &#123;</span><br><span class=\"line\">\tpublic void work();</span><br><span class=\"line\">    default void punch() &#123;</span><br><span class=\"line\">        System.out.println(&quot;上下班打卡。。。。。。。。。。。。。。。&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>工人A 实现类 ，实现接口的工作方法，并在上下班前打卡</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 第一个工人</span><br><span class=\"line\"> * @author xla</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class WorkFirst implements Worker &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void work() &#123;</span><br><span class=\"line\">        punch();</span><br><span class=\"line\">        System.out.println(&quot;doing First work&quot;);</span><br><span class=\"line\">        punch();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>工人B 实现类，实现接口的工作方法，并在上下班前打卡</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 第二个工人</span><br><span class=\"line\"> * @author xla</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class WorkSecond implements Worker &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 他们在工作前后需要打卡</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void work() &#123;</span><br><span class=\"line\">        punch();</span><br><span class=\"line\">        System.out.println(&quot;do second job&quot;);</span><br><span class=\"line\">        punch();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>上述代码在没有使用代理前是这么实现的，但是你有没有发现一个问题，上述工人在工作前后都调用了punch方法，显得有些重复。那我们通过什么可以解决这个问题呢？代理？？</p>\n<p>目前我们使用的Java 代理有两种，静态代理和动态代理下面我们通过例子来实现：</p>\n<ul>\n<li>静态代理<br>我们创建一个代理类 WorkProxy<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class WorkProxy implements Worker &#123;</span><br><span class=\"line\">    private Worker worker;</span><br><span class=\"line\"></span><br><span class=\"line\">    public WorkProxy(Worker worker) &#123;</span><br><span class=\"line\">        this.worker = worker;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void work() &#123;</span><br><span class=\"line\">          punch();</span><br><span class=\"line\">          worker.work();</span><br><span class=\"line\">          punch();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>工人A 中的work 方法就不需要再前后调用打卡功能，只需要将自己的对象交给代理类让代理类去实现打卡功能代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">        Worker worker = new WorkFirst();</span><br><span class=\"line\">        WorkProxy workProxy = new WorkProxy(worker);</span><br><span class=\"line\">        workProxy.work();</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure></p>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">上下班打卡。。。。。。。。。。。。。。。</span><br><span class=\"line\">doing First work</span><br><span class=\"line\">上下班打卡。。。。。。。。。。。。。。。</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>动态代理</li>\n</ul>\n<p>动态代理，顾名思义就是代理类是在运行过程中动态创建的，实现动态的过程我们需要创建一个中介类，实现InvocationHandler 接口作为调用处理器”拦截“对代理类方法的调用。中介类实现如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class WorkDynamicProxy implements InvocationHandler &#123;</span><br><span class=\"line\">    private Worker worker;</span><br><span class=\"line\"></span><br><span class=\"line\">    public  WorkDynamicProxy(Worker worker) &#123;</span><br><span class=\"line\">        this.worker = worker;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class=\"line\">        worker.punch();</span><br><span class=\"line\">        Object result = method.invoke(worker, args);</span><br><span class=\"line\">        worker.punch();</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>接下来我们来测试一下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">        WorkDynamicProxy workDynamicProxy = new WorkDynamicProxy(new WorkSecond());</span><br><span class=\"line\">        //获取代理类实例worker</span><br><span class=\"line\">        Worker worker = (Worker)(Proxy.newProxyInstance(Worker.class.getClassLoader(), new Class[] &#123;Worker.class&#125;, workDynamicProxy));</span><br><span class=\"line\">        //通过代理类对象调用代理类方法，实际上会转到invoke方法调用</span><br><span class=\"line\">        worker.work();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>打印结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">上下班打卡。。。。。。。。。。。。。。。</span><br><span class=\"line\">do second job</span><br><span class=\"line\">上下班打卡。。。。。。。。。。。。。。。</span><br></pre></td></tr></table></figure></p>\n<p>现在我们需要考虑一几个问题？动态代理的过程？为啥动态代理需要使用接口？现在我们来解决第一个问题：</p>\n<ul>\n<li>动态代理的过程？<br>从上述代码中我们可以看出，通过newProxyInstance方法获取一个代理类的，调用代理类的方法都会执行invoke(Object proxy, Method method, Object[] args)方法，解释三个参数<br>proxy 委托类<br>method 代理类的方法<br>args 调用代理类的方法参入的参数</li>\n<li>为啥动态代理需要使用接口？<br>我们再次查看源码newProxyInstance方法的实现：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static Object newProxyInstance(ClassLoader loader,</span><br><span class=\"line\">                                          Class&lt;?&gt;[] interfaces,</span><br><span class=\"line\">                                          InvocationHandler h)</span><br><span class=\"line\">        throws IllegalArgumentException</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Objects.requireNonNull(h);</span><br><span class=\"line\"></span><br><span class=\"line\">        final Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class=\"line\">        final SecurityManager sm = System.getSecurityManager();</span><br><span class=\"line\">        if (sm != null) &#123;</span><br><span class=\"line\">            checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        /*</span><br><span class=\"line\">         * Look up or generate the designated proxy class.</span><br><span class=\"line\">         */</span><br><span class=\"line\">        Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class=\"line\"></span><br><span class=\"line\">        /*</span><br><span class=\"line\">         * Invoke its constructor with the designated invocation handler.</span><br><span class=\"line\">         */</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            if (sm != null) &#123;</span><br><span class=\"line\">                checkNewProxyPermission(Reflection.getCallerClass(), cl);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class=\"line\">            final InvocationHandler ih = h;</span><br><span class=\"line\">            if (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class=\"line\">                AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class=\"line\">                    public Void run() &#123;</span><br><span class=\"line\">                        cons.setAccessible(true);</span><br><span class=\"line\">                        return null;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return cons.newInstance(new Object[]&#123;h&#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ....</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>从源码上，首先进行一系列的判断逻辑，然后到了<br>Class&lt;?&gt; cl = getProxyClass0(loader, intfs);<br>获取代理类的Class 对象，接下来执行<br> final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);<br> 获取Class的构造对象，通过cons.newInstance(new Object[]{h}); 返回一个代理类实例对象，具体参考 <a href=\"http://www.xulian.net.cn/2019/02/20/java-%E5%8F%8D%E5%B0%84%E7%AC%94%E8%AE%B0/\" target=\"_blank\" rel=\"noopener\">Java反射</a> 。<br> 目前我们只知道代理类对象的创建过程，但是为啥只能传入接口还是得不到解决，那我们只能继续查看getProxyClass0源码：<br> 具体实现步骤：</p>\n<ol>\n<li>验证，通过类加载对象和接口列表获取代理类的Class对象，如果缓存中存在则返回，没有就通过代理类工厂创建代理类</li>\n<li>创建代理类<br>通过ProxyClassFactory工厂创建代理类，核心代码如下<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String proxyName = proxyPkg + proxyClassNamePrefix + num;</span><br><span class=\"line\">byte[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags);</span><br><span class=\"line\">defineClass0(loader, proxyName, proxyClassFile, 0, proxyClassFile.length);</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>定义一个类的名称，通过传入的接口列表和访问标志生成一个代理类的字节码，最后调用defineClass0方法将字节码加载到类加载器中，创建一个代理类。<br>现在我们来实现将代理类的字节码写入本地，查看具体代理类的信息：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">byte[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class=\"line\">                &quot;$proxy1&quot;, new Class[] &#123;Worker.class&#125;, Modifier.PUBLIC);</span><br><span class=\"line\">        FileOutputStream fos = null;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            fos = new FileOutputStream(&quot;D:/$proxy1.class&quot;);</span><br><span class=\"line\">            fos.write(proxyClassFile);</span><br><span class=\"line\">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; catch (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; finally &#123;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                fos.flush();</span><br><span class=\"line\">            &#125; catch (IOException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></p>\n<p>通过反编译启查看字节码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class $proxy1 extends Proxy  implements Worker &#123;</span><br><span class=\"line\">....</span><br><span class=\"line\">public final void work()  throws  &#123;</span><br><span class=\"line\">    try  &#123;</span><br><span class=\"line\">      this.h.invoke(this, m3, null);</span><br><span class=\"line\">      return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ....</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">....</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>现在我们终于得到答案，this.h.invoke(this, m3, null); 很好得验证了之前执行work（）方法其实是调用了中介类的invoke方法结论，还有一个问题，为啥动态代理需要使用接口，主要原因是代理类已经继承了Proxy类，Java不支持多继承所以导致动态代理需要使用接口，接口支持多继承。终于可以说服自己为啥动态代理需要接口了。。。。。</p>\n<h1 id=\"3-总结\"><a href=\"#3-总结\" class=\"headerlink\" title=\"3. 总结\"></a>3. 总结</h1><p>我们大概讲了一下什么是代理，然后通过例子，代码实现了Java中的代理，最后通过源码解释了Java动态代理的过程。。。</p>\n<p>参考文档：</p>\n<p>jdk 8<br><a href=\"https://www.cnblogs.com/frankliiu-java/articles/1896443.html\" target=\"_blank\" rel=\"noopener\">JDK动态代理为什么必须针对接口？其与CGLIB的对比</a></p>\n"},{"title":"mybatis 学习","date":"2019-03-22T01:54:00.000Z","_content":"\n# 1. 介绍\nMyBatis 源于 apache 下的一个开源项目iBatis，由于历史原因到了2010年，该项目从apache软件基金组织迁移到 google code，从那之后MyBatis就诞生了。它主要是基于数据库层的一套持久层框架，可以实现自定义的SQL语句，数据库的存储过程以及高级映射。MyBatis 改善了之前通过 JDBC 编写数据库操作代码需要手动设置参数信息和对结果集的数据封装等问题。它不仅对原生的JDBC 操作进行封装，还加入了自己特有的一些功能点，例如\n通过使用xml或者Java 5 推出的注解方式来支持以下几大模块，\n\n* 一：数据库表和普通的Java对象做对一层映射关系，解决数据转换的问题\n* 二：在xml配置文件中编写增删改查操作配置，其配置的id与接口方法名一致或者是在接口方法名上加上注解方式，实现接口式编程，不必需要编写实现类\n\nMyBatis还支持声明式的数据缓存，如果我们将sql语句标记成 “可缓存”，当它首次执行数据操作时会将数据存放在一个高速缓存中，这样下次查询就可以从缓存中读取不必在执行数据库操作了，进而可以减轻数据库的负载。这种缓存方式是基于JAVA JVM 实现的，它内部提供了API 接口，因此可以通过一些开源的缓存框架实现缓存，开源缓存框架主要有 Ehcache，Memcached，redis等。\nMybatis与市场上一些开源框架实现融合，例如：通过与spring框架集成，参与spring事务，创建会话和对应的映射关系，通过spring ioc 实现 依赖注入。与Velocity模板框架做集成，实现动态生成SQL查询语句，从而减少开发的时间，提高开发效率。\n\n\n# 2. 如何使用mybatis\n\n# 3. 底层实现原理\n\n# 4. 总结","source":"_posts/mybatis-学习.md","raw":"---\ntitle: mybatis 学习\ndate: 2019-03-22 09:54:00\ntags:\n- mybatis\n---\n\n# 1. 介绍\nMyBatis 源于 apache 下的一个开源项目iBatis，由于历史原因到了2010年，该项目从apache软件基金组织迁移到 google code，从那之后MyBatis就诞生了。它主要是基于数据库层的一套持久层框架，可以实现自定义的SQL语句，数据库的存储过程以及高级映射。MyBatis 改善了之前通过 JDBC 编写数据库操作代码需要手动设置参数信息和对结果集的数据封装等问题。它不仅对原生的JDBC 操作进行封装，还加入了自己特有的一些功能点，例如\n通过使用xml或者Java 5 推出的注解方式来支持以下几大模块，\n\n* 一：数据库表和普通的Java对象做对一层映射关系，解决数据转换的问题\n* 二：在xml配置文件中编写增删改查操作配置，其配置的id与接口方法名一致或者是在接口方法名上加上注解方式，实现接口式编程，不必需要编写实现类\n\nMyBatis还支持声明式的数据缓存，如果我们将sql语句标记成 “可缓存”，当它首次执行数据操作时会将数据存放在一个高速缓存中，这样下次查询就可以从缓存中读取不必在执行数据库操作了，进而可以减轻数据库的负载。这种缓存方式是基于JAVA JVM 实现的，它内部提供了API 接口，因此可以通过一些开源的缓存框架实现缓存，开源缓存框架主要有 Ehcache，Memcached，redis等。\nMybatis与市场上一些开源框架实现融合，例如：通过与spring框架集成，参与spring事务，创建会话和对应的映射关系，通过spring ioc 实现 依赖注入。与Velocity模板框架做集成，实现动态生成SQL查询语句，从而减少开发的时间，提高开发效率。\n\n\n# 2. 如何使用mybatis\n\n# 3. 底层实现原理\n\n# 4. 总结","slug":"mybatis-学习","published":1,"updated":"2019-07-14T03:37:15.749Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8mkctun000v4osx3d5xssp3","content":"<h1 id=\"1-介绍\"><a href=\"#1-介绍\" class=\"headerlink\" title=\"1. 介绍\"></a>1. 介绍</h1><p>MyBatis 源于 apache 下的一个开源项目iBatis，由于历史原因到了2010年，该项目从apache软件基金组织迁移到 google code，从那之后MyBatis就诞生了。它主要是基于数据库层的一套持久层框架，可以实现自定义的SQL语句，数据库的存储过程以及高级映射。MyBatis 改善了之前通过 JDBC 编写数据库操作代码需要手动设置参数信息和对结果集的数据封装等问题。它不仅对原生的JDBC 操作进行封装，还加入了自己特有的一些功能点，例如<br>通过使用xml或者Java 5 推出的注解方式来支持以下几大模块，</p>\n<ul>\n<li>一：数据库表和普通的Java对象做对一层映射关系，解决数据转换的问题</li>\n<li>二：在xml配置文件中编写增删改查操作配置，其配置的id与接口方法名一致或者是在接口方法名上加上注解方式，实现接口式编程，不必需要编写实现类</li>\n</ul>\n<p>MyBatis还支持声明式的数据缓存，如果我们将sql语句标记成 “可缓存”，当它首次执行数据操作时会将数据存放在一个高速缓存中，这样下次查询就可以从缓存中读取不必在执行数据库操作了，进而可以减轻数据库的负载。这种缓存方式是基于JAVA JVM 实现的，它内部提供了API 接口，因此可以通过一些开源的缓存框架实现缓存，开源缓存框架主要有 Ehcache，Memcached，redis等。<br>Mybatis与市场上一些开源框架实现融合，例如：通过与spring框架集成，参与spring事务，创建会话和对应的映射关系，通过spring ioc 实现 依赖注入。与Velocity模板框架做集成，实现动态生成SQL查询语句，从而减少开发的时间，提高开发效率。</p>\n<h1 id=\"2-如何使用mybatis\"><a href=\"#2-如何使用mybatis\" class=\"headerlink\" title=\"2. 如何使用mybatis\"></a>2. 如何使用mybatis</h1><h1 id=\"3-底层实现原理\"><a href=\"#3-底层实现原理\" class=\"headerlink\" title=\"3. 底层实现原理\"></a>3. 底层实现原理</h1><h1 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4. 总结\"></a>4. 总结</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-介绍\"><a href=\"#1-介绍\" class=\"headerlink\" title=\"1. 介绍\"></a>1. 介绍</h1><p>MyBatis 源于 apache 下的一个开源项目iBatis，由于历史原因到了2010年，该项目从apache软件基金组织迁移到 google code，从那之后MyBatis就诞生了。它主要是基于数据库层的一套持久层框架，可以实现自定义的SQL语句，数据库的存储过程以及高级映射。MyBatis 改善了之前通过 JDBC 编写数据库操作代码需要手动设置参数信息和对结果集的数据封装等问题。它不仅对原生的JDBC 操作进行封装，还加入了自己特有的一些功能点，例如<br>通过使用xml或者Java 5 推出的注解方式来支持以下几大模块，</p>\n<ul>\n<li>一：数据库表和普通的Java对象做对一层映射关系，解决数据转换的问题</li>\n<li>二：在xml配置文件中编写增删改查操作配置，其配置的id与接口方法名一致或者是在接口方法名上加上注解方式，实现接口式编程，不必需要编写实现类</li>\n</ul>\n<p>MyBatis还支持声明式的数据缓存，如果我们将sql语句标记成 “可缓存”，当它首次执行数据操作时会将数据存放在一个高速缓存中，这样下次查询就可以从缓存中读取不必在执行数据库操作了，进而可以减轻数据库的负载。这种缓存方式是基于JAVA JVM 实现的，它内部提供了API 接口，因此可以通过一些开源的缓存框架实现缓存，开源缓存框架主要有 Ehcache，Memcached，redis等。<br>Mybatis与市场上一些开源框架实现融合，例如：通过与spring框架集成，参与spring事务，创建会话和对应的映射关系，通过spring ioc 实现 依赖注入。与Velocity模板框架做集成，实现动态生成SQL查询语句，从而减少开发的时间，提高开发效率。</p>\n<h1 id=\"2-如何使用mybatis\"><a href=\"#2-如何使用mybatis\" class=\"headerlink\" title=\"2. 如何使用mybatis\"></a>2. 如何使用mybatis</h1><h1 id=\"3-底层实现原理\"><a href=\"#3-底层实现原理\" class=\"headerlink\" title=\"3. 底层实现原理\"></a>3. 底层实现原理</h1><h1 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4. 总结\"></a>4. 总结</h1>"},{"title":"关于executeUpdate方法返回的值问题","date":"2019-03-15T01:50:30.000Z","_content":"今天在项目中出现了一个问题，delete 语句使用executeUpdate方法后，如果是更新一条数则返回1，但是更新一条以上数据就出现返回0的问题，我一直以为executeUpdate返回更新的条数是错误的？带着疑问我们查看源码：\n```\n@Override\n\tpublic int update(final String sql) throws DataAccessException {\n\t\tAssert.notNull(sql, \"SQL must not be null\");\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Executing SQL update [\" + sql + \"]\");\n\t\t}\n\n\t\tclass UpdateStatementCallback implements StatementCallback<Integer>, SqlProvider {\n\t\t\t@Override\n\t\t\tpublic Integer doInStatement(Statement stmt) throws SQLException {\n\t\t\t\tint rows = stmt.executeUpdate(sql);\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"SQL update affected \" + rows + \" rows\");\n\t\t\t\t}\n\t\t\t\treturn rows;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic String getSql() {\n\t\t\t\treturn sql;\n\t\t\t}\n\t\t}\n\n\t\treturn execute(new UpdateStatementCallback());\n\t}\n```\n从源码上看，update方法返回的就是 stmt.executeUpdate(sql) 方法返回的条数，那么上述更新多条出现0的情况是什么问题？但是执行update语句的话返回的值就是正确的，难道是执行delete语句后数据被删除了，则返回空了？那之前我执行删除一条数据为啥返回1呢？没道理呀。。。。我们继续深入分析，原来是自己上层调用的方法已经将数据删除了，所以再次执行执行delete语句返回0，对自己的用法充满无奈。。。。。。。。。。。。。。\n# 总结\nexecuteUpdate 方法返回的是被更新条数，如果是删除语句则是被删除的条数\n\n\n\n\n","source":"_posts/关于executeUpdate方法返回的值问题.md","raw":"---\ntitle: 关于executeUpdate方法返回的值问题\ndate: 2019-03-15 09:50:30\ntags:\n- spring\n---\n今天在项目中出现了一个问题，delete 语句使用executeUpdate方法后，如果是更新一条数则返回1，但是更新一条以上数据就出现返回0的问题，我一直以为executeUpdate返回更新的条数是错误的？带着疑问我们查看源码：\n```\n@Override\n\tpublic int update(final String sql) throws DataAccessException {\n\t\tAssert.notNull(sql, \"SQL must not be null\");\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Executing SQL update [\" + sql + \"]\");\n\t\t}\n\n\t\tclass UpdateStatementCallback implements StatementCallback<Integer>, SqlProvider {\n\t\t\t@Override\n\t\t\tpublic Integer doInStatement(Statement stmt) throws SQLException {\n\t\t\t\tint rows = stmt.executeUpdate(sql);\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"SQL update affected \" + rows + \" rows\");\n\t\t\t\t}\n\t\t\t\treturn rows;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic String getSql() {\n\t\t\t\treturn sql;\n\t\t\t}\n\t\t}\n\n\t\treturn execute(new UpdateStatementCallback());\n\t}\n```\n从源码上看，update方法返回的就是 stmt.executeUpdate(sql) 方法返回的条数，那么上述更新多条出现0的情况是什么问题？但是执行update语句的话返回的值就是正确的，难道是执行delete语句后数据被删除了，则返回空了？那之前我执行删除一条数据为啥返回1呢？没道理呀。。。。我们继续深入分析，原来是自己上层调用的方法已经将数据删除了，所以再次执行执行delete语句返回0，对自己的用法充满无奈。。。。。。。。。。。。。。\n# 总结\nexecuteUpdate 方法返回的是被更新条数，如果是删除语句则是被删除的条数\n\n\n\n\n","slug":"关于executeUpdate方法返回的值问题","published":1,"updated":"2019-07-14T03:11:26.979Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8mkctuo000y4osxe3ttfkt1","content":"<p>今天在项目中出现了一个问题，delete 语句使用executeUpdate方法后，如果是更新一条数则返回1，但是更新一条以上数据就出现返回0的问题，我一直以为executeUpdate返回更新的条数是错误的？带着疑问我们查看源码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">\tpublic int update(final String sql) throws DataAccessException &#123;</span><br><span class=\"line\">\t\tAssert.notNull(sql, &quot;SQL must not be null&quot;);</span><br><span class=\"line\">\t\tif (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">\t\t\tlogger.debug(&quot;Executing SQL update [&quot; + sql + &quot;]&quot;);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tclass UpdateStatementCallback implements StatementCallback&lt;Integer&gt;, SqlProvider &#123;</span><br><span class=\"line\">\t\t\t@Override</span><br><span class=\"line\">\t\t\tpublic Integer doInStatement(Statement stmt) throws SQLException &#123;</span><br><span class=\"line\">\t\t\t\tint rows = stmt.executeUpdate(sql);</span><br><span class=\"line\">\t\t\t\tif (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">\t\t\t\t\tlogger.debug(&quot;SQL update affected &quot; + rows + &quot; rows&quot;);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\treturn rows;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t@Override</span><br><span class=\"line\">\t\t\tpublic String getSql() &#123;</span><br><span class=\"line\">\t\t\t\treturn sql;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\treturn execute(new UpdateStatementCallback());</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure></p>\n<p>从源码上看，update方法返回的就是 stmt.executeUpdate(sql) 方法返回的条数，那么上述更新多条出现0的情况是什么问题？但是执行update语句的话返回的值就是正确的，难道是执行delete语句后数据被删除了，则返回空了？那之前我执行删除一条数据为啥返回1呢？没道理呀。。。。我们继续深入分析，原来是自己上层调用的方法已经将数据删除了，所以再次执行执行delete语句返回0，对自己的用法充满无奈。。。。。。。。。。。。。。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>executeUpdate 方法返回的是被更新条数，如果是删除语句则是被删除的条数</p>\n","site":{"data":{}},"excerpt":"","more":"<p>今天在项目中出现了一个问题，delete 语句使用executeUpdate方法后，如果是更新一条数则返回1，但是更新一条以上数据就出现返回0的问题，我一直以为executeUpdate返回更新的条数是错误的？带着疑问我们查看源码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">\tpublic int update(final String sql) throws DataAccessException &#123;</span><br><span class=\"line\">\t\tAssert.notNull(sql, &quot;SQL must not be null&quot;);</span><br><span class=\"line\">\t\tif (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">\t\t\tlogger.debug(&quot;Executing SQL update [&quot; + sql + &quot;]&quot;);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tclass UpdateStatementCallback implements StatementCallback&lt;Integer&gt;, SqlProvider &#123;</span><br><span class=\"line\">\t\t\t@Override</span><br><span class=\"line\">\t\t\tpublic Integer doInStatement(Statement stmt) throws SQLException &#123;</span><br><span class=\"line\">\t\t\t\tint rows = stmt.executeUpdate(sql);</span><br><span class=\"line\">\t\t\t\tif (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">\t\t\t\t\tlogger.debug(&quot;SQL update affected &quot; + rows + &quot; rows&quot;);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\treturn rows;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t@Override</span><br><span class=\"line\">\t\t\tpublic String getSql() &#123;</span><br><span class=\"line\">\t\t\t\treturn sql;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\treturn execute(new UpdateStatementCallback());</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure></p>\n<p>从源码上看，update方法返回的就是 stmt.executeUpdate(sql) 方法返回的条数，那么上述更新多条出现0的情况是什么问题？但是执行update语句的话返回的值就是正确的，难道是执行delete语句后数据被删除了，则返回空了？那之前我执行删除一条数据为啥返回1呢？没道理呀。。。。我们继续深入分析，原来是自己上层调用的方法已经将数据删除了，所以再次执行执行delete语句返回0，对自己的用法充满无奈。。。。。。。。。。。。。。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>executeUpdate 方法返回的是被更新条数，如果是删除语句则是被删除的条数</p>\n"},{"title":"spring bean的作用域","date":"2019-03-15T01:51:36.000Z","_content":"\nSpring 中有五种作用域，但是有三种只适用在web环境![在这里插入图片描述](https://img-blog.csdnimg.cn/20190305163713526.png)\n下面我们来介绍一下 singleton 和 prototype\n* Singleton 作用域\n我们先通过idea 创建一个项目，然后创建一个NewCar 类拥有两个方法如下：\n```\npublic class NewCar {\n    private String content;\n    public void prints() {\n        System.out.println(content);\n    }\n   \tpublic void setContent(String content) {\n        this.content = content;\n    }\n}\n```\n接着创建一个singleton.xml 配置文件\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n    <bean id=\"testSingleton\" class=\"cn.assist.easydao.util.NewCar\" scope=\"singleton\"></bean>\n</beans>\n```\n接下来我们创建一个测试类，来检验\n```\nApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"singleton.xml\");\nNewCar newCar = (NewCar) applicationContext.getBean(\"testSingleton\");\nnewCar.setContent(\"test singleton\");\nNewCar newCar1 = (NewCar) applicationContext.getBean(\"testSingleton\");\nnewCar1.prints();\n```\n通过上述方法，打印结果如下：\n```\ntest singleton\n```\n说明 newCar 和 newCar1 指向的是同一个实例，如果使用prototype作用域会是一个什么结果？\n将上述配置文件scope 修改成 prototype，如下：\n* prototype 作用域\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n    <bean id=\"testSingleton\" class=\"cn.assist.easydao.util.NewCar\" scope=\"prototype\"></bean>\n</beans>\n```\n再次运行测试类，打印如下\n```\nNull\n```\n通过结果我们很容易知道，newCar1 和 newCar 指向的不是同一个实例。\n通过上述例子我们知道了singleton和prototype的区别，以后在实际过程中就能很好的利用它们了。\n* Request 作用域\n对于每个http请求，spring容器都会创建一个新的实例，由于每个请求都会创建一个新实例，相互之间不能看到对方的内部变化，所以相对来说是安全的。一旦请求完成，对应Request 作用域的实例也随着丢弃。\n* Session 作用域\n\t每个请求都会创建一个实例，每个实例共享一个HTTP  Session。\n. globalSession 作用域\n普遍适用于在基于portlets 的web环境下，所有的portlet共享全局的session。\n**注意：如果在基于 servlet 的web环境下，定义一个或者多个 global session 作用域，标准的http讲使用Session 作用，不会出现错误。**\n参考文档：\n[Bean scopes](https://docs.spring.io/spring/docs/3.0.0.M3/reference/html/ch04s04.html)\n\n接下来一篇我们来介绍一下一个Servlet 和 portlets 的区别","source":"_posts/spring-bean的作用域.md","raw":"---\ntitle: spring bean的作用域\ndate: 2019-03-15 09:51:36\ntags:\n- spring\n---\n\nSpring 中有五种作用域，但是有三种只适用在web环境![在这里插入图片描述](https://img-blog.csdnimg.cn/20190305163713526.png)\n下面我们来介绍一下 singleton 和 prototype\n* Singleton 作用域\n我们先通过idea 创建一个项目，然后创建一个NewCar 类拥有两个方法如下：\n```\npublic class NewCar {\n    private String content;\n    public void prints() {\n        System.out.println(content);\n    }\n   \tpublic void setContent(String content) {\n        this.content = content;\n    }\n}\n```\n接着创建一个singleton.xml 配置文件\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n    <bean id=\"testSingleton\" class=\"cn.assist.easydao.util.NewCar\" scope=\"singleton\"></bean>\n</beans>\n```\n接下来我们创建一个测试类，来检验\n```\nApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"singleton.xml\");\nNewCar newCar = (NewCar) applicationContext.getBean(\"testSingleton\");\nnewCar.setContent(\"test singleton\");\nNewCar newCar1 = (NewCar) applicationContext.getBean(\"testSingleton\");\nnewCar1.prints();\n```\n通过上述方法，打印结果如下：\n```\ntest singleton\n```\n说明 newCar 和 newCar1 指向的是同一个实例，如果使用prototype作用域会是一个什么结果？\n将上述配置文件scope 修改成 prototype，如下：\n* prototype 作用域\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n    <bean id=\"testSingleton\" class=\"cn.assist.easydao.util.NewCar\" scope=\"prototype\"></bean>\n</beans>\n```\n再次运行测试类，打印如下\n```\nNull\n```\n通过结果我们很容易知道，newCar1 和 newCar 指向的不是同一个实例。\n通过上述例子我们知道了singleton和prototype的区别，以后在实际过程中就能很好的利用它们了。\n* Request 作用域\n对于每个http请求，spring容器都会创建一个新的实例，由于每个请求都会创建一个新实例，相互之间不能看到对方的内部变化，所以相对来说是安全的。一旦请求完成，对应Request 作用域的实例也随着丢弃。\n* Session 作用域\n\t每个请求都会创建一个实例，每个实例共享一个HTTP  Session。\n. globalSession 作用域\n普遍适用于在基于portlets 的web环境下，所有的portlet共享全局的session。\n**注意：如果在基于 servlet 的web环境下，定义一个或者多个 global session 作用域，标准的http讲使用Session 作用，不会出现错误。**\n参考文档：\n[Bean scopes](https://docs.spring.io/spring/docs/3.0.0.M3/reference/html/ch04s04.html)\n\n接下来一篇我们来介绍一下一个Servlet 和 portlets 的区别","slug":"spring-bean的作用域","published":1,"updated":"2019-07-14T04:37:24.705Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8mkctuq00104osxlsnw1z47","content":"<p>Spring 中有五种作用域，但是有三种只适用在web环境<img src=\"https://img-blog.csdnimg.cn/20190305163713526.png\" alt=\"在这里插入图片描述\"><br>下面我们来介绍一下 singleton 和 prototype</p>\n<ul>\n<li>Singleton 作用域<br>我们先通过idea 创建一个项目，然后创建一个NewCar 类拥有两个方法如下：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class NewCar &#123;</span><br><span class=\"line\">    private String content;</span><br><span class=\"line\">    public void prints() &#123;</span><br><span class=\"line\">        System.out.println(content);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   \tpublic void setContent(String content) &#123;</span><br><span class=\"line\">        this.content = content;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>接着创建一个singleton.xml 配置文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class=\"line\">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class=\"line\">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class=\"line\">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class=\"line\">    &lt;bean id=&quot;testSingleton&quot; class=&quot;cn.assist.easydao.util.NewCar&quot; scope=&quot;singleton&quot;&gt;&lt;/bean&gt;</span><br><span class=\"line\">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p>\n<p>接下来我们创建一个测试类，来检验<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;singleton.xml&quot;);</span><br><span class=\"line\">NewCar newCar = (NewCar) applicationContext.getBean(&quot;testSingleton&quot;);</span><br><span class=\"line\">newCar.setContent(&quot;test singleton&quot;);</span><br><span class=\"line\">NewCar newCar1 = (NewCar) applicationContext.getBean(&quot;testSingleton&quot;);</span><br><span class=\"line\">newCar1.prints();</span><br></pre></td></tr></table></figure></p>\n<p>通过上述方法，打印结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test singleton</span><br></pre></td></tr></table></figure></p>\n<p>说明 newCar 和 newCar1 指向的是同一个实例，如果使用prototype作用域会是一个什么结果？<br>将上述配置文件scope 修改成 prototype，如下：</p>\n<ul>\n<li>prototype 作用域<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class=\"line\">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class=\"line\">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class=\"line\">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class=\"line\">    &lt;bean id=&quot;testSingleton&quot; class=&quot;cn.assist.easydao.util.NewCar&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt;</span><br><span class=\"line\">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>再次运行测试类，打印如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Null</span><br></pre></td></tr></table></figure></p>\n<p>通过结果我们很容易知道，newCar1 和 newCar 指向的不是同一个实例。<br>通过上述例子我们知道了singleton和prototype的区别，以后在实际过程中就能很好的利用它们了。</p>\n<ul>\n<li>Request 作用域<br>对于每个http请求，spring容器都会创建一个新的实例，由于每个请求都会创建一个新实例，相互之间不能看到对方的内部变化，所以相对来说是安全的。一旦请求完成，对应Request 作用域的实例也随着丢弃。</li>\n<li>Session 作用域<br>  每个请求都会创建一个实例，每个实例共享一个HTTP  Session。<br>. globalSession 作用域<br>普遍适用于在基于portlets 的web环境下，所有的portlet共享全局的session。<br><strong>注意：如果在基于 servlet 的web环境下，定义一个或者多个 global session 作用域，标准的http讲使用Session 作用，不会出现错误。</strong><br>参考文档：<br><a href=\"https://docs.spring.io/spring/docs/3.0.0.M3/reference/html/ch04s04.html\" target=\"_blank\" rel=\"noopener\">Bean scopes</a></li>\n</ul>\n<p>接下来一篇我们来介绍一下一个Servlet 和 portlets 的区别</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Spring 中有五种作用域，但是有三种只适用在web环境<img src=\"https://img-blog.csdnimg.cn/20190305163713526.png\" alt=\"在这里插入图片描述\"><br>下面我们来介绍一下 singleton 和 prototype</p>\n<ul>\n<li>Singleton 作用域<br>我们先通过idea 创建一个项目，然后创建一个NewCar 类拥有两个方法如下：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class NewCar &#123;</span><br><span class=\"line\">    private String content;</span><br><span class=\"line\">    public void prints() &#123;</span><br><span class=\"line\">        System.out.println(content);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   \tpublic void setContent(String content) &#123;</span><br><span class=\"line\">        this.content = content;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>接着创建一个singleton.xml 配置文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class=\"line\">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class=\"line\">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class=\"line\">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class=\"line\">    &lt;bean id=&quot;testSingleton&quot; class=&quot;cn.assist.easydao.util.NewCar&quot; scope=&quot;singleton&quot;&gt;&lt;/bean&gt;</span><br><span class=\"line\">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p>\n<p>接下来我们创建一个测试类，来检验<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;singleton.xml&quot;);</span><br><span class=\"line\">NewCar newCar = (NewCar) applicationContext.getBean(&quot;testSingleton&quot;);</span><br><span class=\"line\">newCar.setContent(&quot;test singleton&quot;);</span><br><span class=\"line\">NewCar newCar1 = (NewCar) applicationContext.getBean(&quot;testSingleton&quot;);</span><br><span class=\"line\">newCar1.prints();</span><br></pre></td></tr></table></figure></p>\n<p>通过上述方法，打印结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test singleton</span><br></pre></td></tr></table></figure></p>\n<p>说明 newCar 和 newCar1 指向的是同一个实例，如果使用prototype作用域会是一个什么结果？<br>将上述配置文件scope 修改成 prototype，如下：</p>\n<ul>\n<li>prototype 作用域<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class=\"line\">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class=\"line\">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class=\"line\">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class=\"line\">    &lt;bean id=&quot;testSingleton&quot; class=&quot;cn.assist.easydao.util.NewCar&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt;</span><br><span class=\"line\">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>再次运行测试类，打印如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Null</span><br></pre></td></tr></table></figure></p>\n<p>通过结果我们很容易知道，newCar1 和 newCar 指向的不是同一个实例。<br>通过上述例子我们知道了singleton和prototype的区别，以后在实际过程中就能很好的利用它们了。</p>\n<ul>\n<li>Request 作用域<br>对于每个http请求，spring容器都会创建一个新的实例，由于每个请求都会创建一个新实例，相互之间不能看到对方的内部变化，所以相对来说是安全的。一旦请求完成，对应Request 作用域的实例也随着丢弃。</li>\n<li>Session 作用域<br>  每个请求都会创建一个实例，每个实例共享一个HTTP  Session。<br>. globalSession 作用域<br>普遍适用于在基于portlets 的web环境下，所有的portlet共享全局的session。<br><strong>注意：如果在基于 servlet 的web环境下，定义一个或者多个 global session 作用域，标准的http讲使用Session 作用，不会出现错误。</strong><br>参考文档：<br><a href=\"https://docs.spring.io/spring/docs/3.0.0.M3/reference/html/ch04s04.html\" target=\"_blank\" rel=\"noopener\">Bean scopes</a></li>\n</ul>\n<p>接下来一篇我们来介绍一下一个Servlet 和 portlets 的区别</p>\n"},{"title":"关于Volatile的那点事","date":"2019-03-15T01:53:46.000Z","_content":"# 1.\t为啥要使用Volatile？\n通常我们在Java中给变量加上Volatile修饰，主要用途是使该变量具有可见性。因为在多线程的操作中，由于每个线程内部都会开辟一个内存空间，如果想让每个空间都可见该变量则需要给这个变量加在Volatile修饰，使变量变成共享变量。它也能避免 jvm 指令重排。\n# 2. Volatile 实现原理？\n在了解volatile原理之前，我们先了解一下cpu和主存，关于cpu的定义如下图：\n![cpu术语定义](https://img.mupaie.com/20190301100135878.png)\n知道cpu定义后，我们来看一下内存和cpu是怎么交互的，由于内存处理速度和cpu的处理速度差距太大，为了平衡两者之间的差距引入了cpu\n缓存如下图：\n![cpu和内存的交互](https://img.mupaie.com/20190301101210752.png)\n知道内存和cpu的交互后，我们来解决一个问题 -- volatile 关键字是如何实现变量可见性的呢，我们通过一段代码来展示如何实现可见性的：\nJava 代码如下：\nobject = new Singleton(); // object 是 volatile 修饰的变量\n转变成汇编代码：\n ![在这里插入图片描述](https://img.mupaie.com/20190301100533374.png)\n 我们发现通过volatile 修饰的变量进行写操作的时候会多出一段Lock 前缀指令，这段指令的用途主要有两点：\n 1. 将当前的处理器缓存行写会系统内存\n 2. 这个写回操作使其他cpu里面缓存该值的内存地址数据实效。\n我们来了解一下实现过程，Lock前缀指令在执行期间会给处理器发送一个LOCK#信号，处理器收到信号后会锁住cpu缓存并将变量写入主内存中。由于处理器使用嗅探技术确保它内存缓存，系统内存和其他处理器的缓存的数据在总线上保持一致。如果嗅探到有一个处理器来检测其他处理器打算写入内存地址，而这个地址是处于共享状态的，那么正在嗅探的处理器中缓存的内存地址将变成无效，下次访问的时候直接读取主存中的内存地址。\n# 3. volatile 能实现可见性，但不能保证原子性\n虽然volatile关键字能保证从主内存中直接获取被volatile修饰的变量，也能直接把volatile修饰的变量写入主内存中，但是这样也不能保证原子性。在多cpu的情况下，还是会出现线程不安全情况，比如：在多线程下，多个线程正在写入一个volatile变量，并正确的将值写入主内存中，如果新写入的值不是根据之前的值计算得到的，那么就不能保证数据原子性了。\n除了上述写了还有一种情况：\n在多线程中，递增一个volatile变量counter，通过volatile不足够解决问题，下面我们通过一个例子来解释：\n你想象一下如果线程1读取值为0的变量counter将他写入cpu缓存中，递增这个变量counter将它变成1，没有将修改的值写入主内存中。线程2也能从主内存中读取到相同的变量counter，但是这个变量counter还是0，然后将变量counter写入cpu的缓存中，线程2也递增了这个变量counter为1，没有将值写入主内存中，这种情况如下图所示：\n![在这里插入图片描述](https://img.mupaie.com/20190301144702874.png)\n线程1和线程2现在不是同步的。上述结果原本应该是2，但是因为两个线程都没有把变量counter写入主内存，导致主内存的变量counter还是0，即使最终线程1和2将变量counter写入主内存也是错误的。\n# 4. 怎么保证volatile原子性呢？\n如果两个以上的线程对共享变量读写操作，使用volatile并不能解决问题。你需要使用 synchronized 来确保对变量读写操作使原子性的。不止可以通过synchronized锁解决这个问题，你也可以使用 java.util.concurrent package 下的一些原子数据，比如 AtomicLong，AtomicReference 还有其他一些。volatile关键字能保证在32和64位的变量运行。\n\n# 5. volatile 性能考虑\n读取和写入volatile变量会导致变量被读取或写入主存储器。读取和写入主内存比访问CPU缓存更昂贵。访问volatile变量也会阻止指令重新排序，这是一种正常的性能增强技术。因此，当您确实需要强制实施变量可见性时，应该只使用volatile变量。\n\n# 6. 总结\n主要讲了一些 volatile 的底层实现和如何保证volatile原子性，最后讲了一下 需要考虑一些 volatile 性能。\n注意：__使用 volatile 修饰的变量避免该变量计算需要依赖之前的值。__\n\n参考文档：\n[Java Volatile Keyword](http://tutorials.jenkov.com/java-concurrency/volatile.html)\n[聊聊并发（一）——深入分析 Volatile 的实现原理](https://www.infoq.cn/article/ftf-java-volatile)\n","source":"_posts/关于Volatile的那点事.md","raw":"---\ntitle: 关于Volatile的那点事\ndate: 2019-03-15 09:53:46\ntags:\n- 多线程\n- 并发\n---\n# 1.\t为啥要使用Volatile？\n通常我们在Java中给变量加上Volatile修饰，主要用途是使该变量具有可见性。因为在多线程的操作中，由于每个线程内部都会开辟一个内存空间，如果想让每个空间都可见该变量则需要给这个变量加在Volatile修饰，使变量变成共享变量。它也能避免 jvm 指令重排。\n# 2. Volatile 实现原理？\n在了解volatile原理之前，我们先了解一下cpu和主存，关于cpu的定义如下图：\n![cpu术语定义](https://img.mupaie.com/20190301100135878.png)\n知道cpu定义后，我们来看一下内存和cpu是怎么交互的，由于内存处理速度和cpu的处理速度差距太大，为了平衡两者之间的差距引入了cpu\n缓存如下图：\n![cpu和内存的交互](https://img.mupaie.com/20190301101210752.png)\n知道内存和cpu的交互后，我们来解决一个问题 -- volatile 关键字是如何实现变量可见性的呢，我们通过一段代码来展示如何实现可见性的：\nJava 代码如下：\nobject = new Singleton(); // object 是 volatile 修饰的变量\n转变成汇编代码：\n ![在这里插入图片描述](https://img.mupaie.com/20190301100533374.png)\n 我们发现通过volatile 修饰的变量进行写操作的时候会多出一段Lock 前缀指令，这段指令的用途主要有两点：\n 1. 将当前的处理器缓存行写会系统内存\n 2. 这个写回操作使其他cpu里面缓存该值的内存地址数据实效。\n我们来了解一下实现过程，Lock前缀指令在执行期间会给处理器发送一个LOCK#信号，处理器收到信号后会锁住cpu缓存并将变量写入主内存中。由于处理器使用嗅探技术确保它内存缓存，系统内存和其他处理器的缓存的数据在总线上保持一致。如果嗅探到有一个处理器来检测其他处理器打算写入内存地址，而这个地址是处于共享状态的，那么正在嗅探的处理器中缓存的内存地址将变成无效，下次访问的时候直接读取主存中的内存地址。\n# 3. volatile 能实现可见性，但不能保证原子性\n虽然volatile关键字能保证从主内存中直接获取被volatile修饰的变量，也能直接把volatile修饰的变量写入主内存中，但是这样也不能保证原子性。在多cpu的情况下，还是会出现线程不安全情况，比如：在多线程下，多个线程正在写入一个volatile变量，并正确的将值写入主内存中，如果新写入的值不是根据之前的值计算得到的，那么就不能保证数据原子性了。\n除了上述写了还有一种情况：\n在多线程中，递增一个volatile变量counter，通过volatile不足够解决问题，下面我们通过一个例子来解释：\n你想象一下如果线程1读取值为0的变量counter将他写入cpu缓存中，递增这个变量counter将它变成1，没有将修改的值写入主内存中。线程2也能从主内存中读取到相同的变量counter，但是这个变量counter还是0，然后将变量counter写入cpu的缓存中，线程2也递增了这个变量counter为1，没有将值写入主内存中，这种情况如下图所示：\n![在这里插入图片描述](https://img.mupaie.com/20190301144702874.png)\n线程1和线程2现在不是同步的。上述结果原本应该是2，但是因为两个线程都没有把变量counter写入主内存，导致主内存的变量counter还是0，即使最终线程1和2将变量counter写入主内存也是错误的。\n# 4. 怎么保证volatile原子性呢？\n如果两个以上的线程对共享变量读写操作，使用volatile并不能解决问题。你需要使用 synchronized 来确保对变量读写操作使原子性的。不止可以通过synchronized锁解决这个问题，你也可以使用 java.util.concurrent package 下的一些原子数据，比如 AtomicLong，AtomicReference 还有其他一些。volatile关键字能保证在32和64位的变量运行。\n\n# 5. volatile 性能考虑\n读取和写入volatile变量会导致变量被读取或写入主存储器。读取和写入主内存比访问CPU缓存更昂贵。访问volatile变量也会阻止指令重新排序，这是一种正常的性能增强技术。因此，当您确实需要强制实施变量可见性时，应该只使用volatile变量。\n\n# 6. 总结\n主要讲了一些 volatile 的底层实现和如何保证volatile原子性，最后讲了一下 需要考虑一些 volatile 性能。\n注意：__使用 volatile 修饰的变量避免该变量计算需要依赖之前的值。__\n\n参考文档：\n[Java Volatile Keyword](http://tutorials.jenkov.com/java-concurrency/volatile.html)\n[聊聊并发（一）——深入分析 Volatile 的实现原理](https://www.infoq.cn/article/ftf-java-volatile)\n","slug":"关于Volatile的那点事","published":1,"updated":"2019-07-14T04:28:18.393Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8mkctuu00134osx890c50k2","content":"<h1 id=\"1-为啥要使用Volatile？\"><a href=\"#1-为啥要使用Volatile？\" class=\"headerlink\" title=\"1.    为啥要使用Volatile？\"></a>1.    为啥要使用Volatile？</h1><p>通常我们在Java中给变量加上Volatile修饰，主要用途是使该变量具有可见性。因为在多线程的操作中，由于每个线程内部都会开辟一个内存空间，如果想让每个空间都可见该变量则需要给这个变量加在Volatile修饰，使变量变成共享变量。它也能避免 jvm 指令重排。</p>\n<h1 id=\"2-Volatile-实现原理？\"><a href=\"#2-Volatile-实现原理？\" class=\"headerlink\" title=\"2. Volatile 实现原理？\"></a>2. Volatile 实现原理？</h1><p>在了解volatile原理之前，我们先了解一下cpu和主存，关于cpu的定义如下图：<br><img src=\"https://img.mupaie.com/20190301100135878.png\" alt=\"cpu术语定义\"><br>知道cpu定义后，我们来看一下内存和cpu是怎么交互的，由于内存处理速度和cpu的处理速度差距太大，为了平衡两者之间的差距引入了cpu<br>缓存如下图：<br><img src=\"https://img.mupaie.com/20190301101210752.png\" alt=\"cpu和内存的交互\"><br>知道内存和cpu的交互后，我们来解决一个问题 – volatile 关键字是如何实现变量可见性的呢，我们通过一段代码来展示如何实现可见性的：<br>Java 代码如下：<br>object = new Singleton(); // object 是 volatile 修饰的变量<br>转变成汇编代码：<br> <img src=\"https://img.mupaie.com/20190301100533374.png\" alt=\"在这里插入图片描述\"><br> 我们发现通过volatile 修饰的变量进行写操作的时候会多出一段Lock 前缀指令，这段指令的用途主要有两点：</p>\n<ol>\n<li>将当前的处理器缓存行写会系统内存</li>\n<li>这个写回操作使其他cpu里面缓存该值的内存地址数据实效。<br>我们来了解一下实现过程，Lock前缀指令在执行期间会给处理器发送一个LOCK#信号，处理器收到信号后会锁住cpu缓存并将变量写入主内存中。由于处理器使用嗅探技术确保它内存缓存，系统内存和其他处理器的缓存的数据在总线上保持一致。如果嗅探到有一个处理器来检测其他处理器打算写入内存地址，而这个地址是处于共享状态的，那么正在嗅探的处理器中缓存的内存地址将变成无效，下次访问的时候直接读取主存中的内存地址。<h1 id=\"3-volatile-能实现可见性，但不能保证原子性\"><a href=\"#3-volatile-能实现可见性，但不能保证原子性\" class=\"headerlink\" title=\"3. volatile 能实现可见性，但不能保证原子性\"></a>3. volatile 能实现可见性，但不能保证原子性</h1>虽然volatile关键字能保证从主内存中直接获取被volatile修饰的变量，也能直接把volatile修饰的变量写入主内存中，但是这样也不能保证原子性。在多cpu的情况下，还是会出现线程不安全情况，比如：在多线程下，多个线程正在写入一个volatile变量，并正确的将值写入主内存中，如果新写入的值不是根据之前的值计算得到的，那么就不能保证数据原子性了。<br>除了上述写了还有一种情况：<br>在多线程中，递增一个volatile变量counter，通过volatile不足够解决问题，下面我们通过一个例子来解释：<br>你想象一下如果线程1读取值为0的变量counter将他写入cpu缓存中，递增这个变量counter将它变成1，没有将修改的值写入主内存中。线程2也能从主内存中读取到相同的变量counter，但是这个变量counter还是0，然后将变量counter写入cpu的缓存中，线程2也递增了这个变量counter为1，没有将值写入主内存中，这种情况如下图所示：<br><img src=\"https://img.mupaie.com/20190301144702874.png\" alt=\"在这里插入图片描述\"><br>线程1和线程2现在不是同步的。上述结果原本应该是2，但是因为两个线程都没有把变量counter写入主内存，导致主内存的变量counter还是0，即使最终线程1和2将变量counter写入主内存也是错误的。<h1 id=\"4-怎么保证volatile原子性呢？\"><a href=\"#4-怎么保证volatile原子性呢？\" class=\"headerlink\" title=\"4. 怎么保证volatile原子性呢？\"></a>4. 怎么保证volatile原子性呢？</h1>如果两个以上的线程对共享变量读写操作，使用volatile并不能解决问题。你需要使用 synchronized 来确保对变量读写操作使原子性的。不止可以通过synchronized锁解决这个问题，你也可以使用 java.util.concurrent package 下的一些原子数据，比如 AtomicLong，AtomicReference 还有其他一些。volatile关键字能保证在32和64位的变量运行。</li>\n</ol>\n<h1 id=\"5-volatile-性能考虑\"><a href=\"#5-volatile-性能考虑\" class=\"headerlink\" title=\"5. volatile 性能考虑\"></a>5. volatile 性能考虑</h1><p>读取和写入volatile变量会导致变量被读取或写入主存储器。读取和写入主内存比访问CPU缓存更昂贵。访问volatile变量也会阻止指令重新排序，这是一种正常的性能增强技术。因此，当您确实需要强制实施变量可见性时，应该只使用volatile变量。</p>\n<h1 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6. 总结\"></a>6. 总结</h1><p>主要讲了一些 volatile 的底层实现和如何保证volatile原子性，最后讲了一下 需要考虑一些 volatile 性能。<br>注意：<strong>使用 volatile 修饰的变量避免该变量计算需要依赖之前的值。</strong></p>\n<p>参考文档：<br><a href=\"http://tutorials.jenkov.com/java-concurrency/volatile.html\" target=\"_blank\" rel=\"noopener\">Java Volatile Keyword</a><br><a href=\"https://www.infoq.cn/article/ftf-java-volatile\" target=\"_blank\" rel=\"noopener\">聊聊并发（一）——深入分析 Volatile 的实现原理</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-为啥要使用Volatile？\"><a href=\"#1-为啥要使用Volatile？\" class=\"headerlink\" title=\"1.    为啥要使用Volatile？\"></a>1.    为啥要使用Volatile？</h1><p>通常我们在Java中给变量加上Volatile修饰，主要用途是使该变量具有可见性。因为在多线程的操作中，由于每个线程内部都会开辟一个内存空间，如果想让每个空间都可见该变量则需要给这个变量加在Volatile修饰，使变量变成共享变量。它也能避免 jvm 指令重排。</p>\n<h1 id=\"2-Volatile-实现原理？\"><a href=\"#2-Volatile-实现原理？\" class=\"headerlink\" title=\"2. Volatile 实现原理？\"></a>2. Volatile 实现原理？</h1><p>在了解volatile原理之前，我们先了解一下cpu和主存，关于cpu的定义如下图：<br><img src=\"https://img.mupaie.com/20190301100135878.png\" alt=\"cpu术语定义\"><br>知道cpu定义后，我们来看一下内存和cpu是怎么交互的，由于内存处理速度和cpu的处理速度差距太大，为了平衡两者之间的差距引入了cpu<br>缓存如下图：<br><img src=\"https://img.mupaie.com/20190301101210752.png\" alt=\"cpu和内存的交互\"><br>知道内存和cpu的交互后，我们来解决一个问题 – volatile 关键字是如何实现变量可见性的呢，我们通过一段代码来展示如何实现可见性的：<br>Java 代码如下：<br>object = new Singleton(); // object 是 volatile 修饰的变量<br>转变成汇编代码：<br> <img src=\"https://img.mupaie.com/20190301100533374.png\" alt=\"在这里插入图片描述\"><br> 我们发现通过volatile 修饰的变量进行写操作的时候会多出一段Lock 前缀指令，这段指令的用途主要有两点：</p>\n<ol>\n<li>将当前的处理器缓存行写会系统内存</li>\n<li>这个写回操作使其他cpu里面缓存该值的内存地址数据实效。<br>我们来了解一下实现过程，Lock前缀指令在执行期间会给处理器发送一个LOCK#信号，处理器收到信号后会锁住cpu缓存并将变量写入主内存中。由于处理器使用嗅探技术确保它内存缓存，系统内存和其他处理器的缓存的数据在总线上保持一致。如果嗅探到有一个处理器来检测其他处理器打算写入内存地址，而这个地址是处于共享状态的，那么正在嗅探的处理器中缓存的内存地址将变成无效，下次访问的时候直接读取主存中的内存地址。<h1 id=\"3-volatile-能实现可见性，但不能保证原子性\"><a href=\"#3-volatile-能实现可见性，但不能保证原子性\" class=\"headerlink\" title=\"3. volatile 能实现可见性，但不能保证原子性\"></a>3. volatile 能实现可见性，但不能保证原子性</h1>虽然volatile关键字能保证从主内存中直接获取被volatile修饰的变量，也能直接把volatile修饰的变量写入主内存中，但是这样也不能保证原子性。在多cpu的情况下，还是会出现线程不安全情况，比如：在多线程下，多个线程正在写入一个volatile变量，并正确的将值写入主内存中，如果新写入的值不是根据之前的值计算得到的，那么就不能保证数据原子性了。<br>除了上述写了还有一种情况：<br>在多线程中，递增一个volatile变量counter，通过volatile不足够解决问题，下面我们通过一个例子来解释：<br>你想象一下如果线程1读取值为0的变量counter将他写入cpu缓存中，递增这个变量counter将它变成1，没有将修改的值写入主内存中。线程2也能从主内存中读取到相同的变量counter，但是这个变量counter还是0，然后将变量counter写入cpu的缓存中，线程2也递增了这个变量counter为1，没有将值写入主内存中，这种情况如下图所示：<br><img src=\"https://img.mupaie.com/20190301144702874.png\" alt=\"在这里插入图片描述\"><br>线程1和线程2现在不是同步的。上述结果原本应该是2，但是因为两个线程都没有把变量counter写入主内存，导致主内存的变量counter还是0，即使最终线程1和2将变量counter写入主内存也是错误的。<h1 id=\"4-怎么保证volatile原子性呢？\"><a href=\"#4-怎么保证volatile原子性呢？\" class=\"headerlink\" title=\"4. 怎么保证volatile原子性呢？\"></a>4. 怎么保证volatile原子性呢？</h1>如果两个以上的线程对共享变量读写操作，使用volatile并不能解决问题。你需要使用 synchronized 来确保对变量读写操作使原子性的。不止可以通过synchronized锁解决这个问题，你也可以使用 java.util.concurrent package 下的一些原子数据，比如 AtomicLong，AtomicReference 还有其他一些。volatile关键字能保证在32和64位的变量运行。</li>\n</ol>\n<h1 id=\"5-volatile-性能考虑\"><a href=\"#5-volatile-性能考虑\" class=\"headerlink\" title=\"5. volatile 性能考虑\"></a>5. volatile 性能考虑</h1><p>读取和写入volatile变量会导致变量被读取或写入主存储器。读取和写入主内存比访问CPU缓存更昂贵。访问volatile变量也会阻止指令重新排序，这是一种正常的性能增强技术。因此，当您确实需要强制实施变量可见性时，应该只使用volatile变量。</p>\n<h1 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6. 总结\"></a>6. 总结</h1><p>主要讲了一些 volatile 的底层实现和如何保证volatile原子性，最后讲了一下 需要考虑一些 volatile 性能。<br>注意：<strong>使用 volatile 修饰的变量避免该变量计算需要依赖之前的值。</strong></p>\n<p>参考文档：<br><a href=\"http://tutorials.jenkov.com/java-concurrency/volatile.html\" target=\"_blank\" rel=\"noopener\">Java Volatile Keyword</a><br><a href=\"https://www.infoq.cn/article/ftf-java-volatile\" target=\"_blank\" rel=\"noopener\">聊聊并发（一）——深入分析 Volatile 的实现原理</a></p>\n"},{"title":"spring mvc @RequestBody 和 @RequestParam 比较","date":"2019-02-19T10:03:23.000Z","_content":"1： @RequestBody\n\n    @RequestBody 注解 通过 HttpMessageReader 使请求的body反序列化成一个对象。\n    \n    GET、POST方式提交时， 根据 request header Content-Type 的值来判断:\n    \n    application/x-www-form-urlencoded， 可选（即非必须，因为这种情况的数据@RequestParam, @ModelAttribute也可以处理，当然@RequestBody也能处理）；\n    multipart/form-data, 不能处理（即使用@RequestBody不能处理这种格式的数据）；\n    其他格式， 必须（其他格式包括application/json, application/xml等。这些格式的数据，使用@RequestBody来处理）；\n    $.ajax({\n        type: \"POST\",\n        url: \"/coupon/del\",\n        dataType : 'json',\n        contentType : 'application/json;charset=UTF-8', // 设置请求的文本类型\n        data: JSON.stringify(ids),\n        success: function (result) {\n            layer.msg(result.msg)\n        }\n    });\n    控制层接收\n    \n    public JSONObject del(@RequestBody String[] cids){\n           RecordBean<String> result = couponService.delBatch(cids);\n       if (result.isSuccessCode()) {\n          return JsonBean.success(result.getMsg());\n       }\n       return JsonBean.error(result.getMsg());\n2：@RequestParam\n\n    @RequestParam \n    \n    A） 常用来处理简单类型的绑定，通过Request.getParameter() 获取的String可直接转换为简单类型的情况（ String--> 简单类型的转换操作由ConversionService配置的转换器来完成）；因为使用request.getParameter()方式获取参数，所以可以处理get 方式中queryString的值，也可以处理post方式中 body data的值；\n    \n    B）用来处理Content-Type: 为 application/x-www-form-urlencoded编码的内容，提交方式GET、POST；\n    \n    C) 该注解有两个属性： name、required； \n    \n    name：用来指定要传入值的key名称\n    \n    required：用来指示参数是否必须绑定；当@RequestParam 被声明是Map<String, String> or MultiValueMap<String, String> required 为false\n    \n    相比 Request.getParameter() 获取 优点：\n    \n    通过注解的方式可以减少代码量，代码更整洁\n    \n    示例代码：\n    \n    $.ajax({\n        type: \"POST\",\n        url: \"/coupon/del\",\n        data: {ids:123},\n        success: function (result) {\n            layer.msg(result.msg)\n        }\n    });\n    控制层\n    \n    \n     \n     * 删除\n        */\n       @ResponseBody\n       @RequestMapping(\"/dels\")\n       public JSONObject dels(@RequestParam(name = \"ids\") Integer cids){\n          System.out.println(cids);\n          return JsonBean.success(\"ok\",cids);\n       }\n3:@ModelAttribute 注解获取参数\n\n    /**\n        * 删除\n        */\n       @RequestMapping(\"/coupon\")\n       @ResponseBody\n    // @RequiresPermissions(\"coupon:del\")\n       public JSONObject coupon(@ModelAttribute Coupon coupon){\n      return JsonBean.success(\"\",coupon);\n\n","source":"_posts/spring-mvc-RequestBody-和-RequestParam-比较.md","raw":"---\ntitle: spring mvc @RequestBody 和 @RequestParam 比较\ndate: 2019-02-19 18:03:23\ntags:\n---\n1： @RequestBody\n\n    @RequestBody 注解 通过 HttpMessageReader 使请求的body反序列化成一个对象。\n    \n    GET、POST方式提交时， 根据 request header Content-Type 的值来判断:\n    \n    application/x-www-form-urlencoded， 可选（即非必须，因为这种情况的数据@RequestParam, @ModelAttribute也可以处理，当然@RequestBody也能处理）；\n    multipart/form-data, 不能处理（即使用@RequestBody不能处理这种格式的数据）；\n    其他格式， 必须（其他格式包括application/json, application/xml等。这些格式的数据，使用@RequestBody来处理）；\n    $.ajax({\n        type: \"POST\",\n        url: \"/coupon/del\",\n        dataType : 'json',\n        contentType : 'application/json;charset=UTF-8', // 设置请求的文本类型\n        data: JSON.stringify(ids),\n        success: function (result) {\n            layer.msg(result.msg)\n        }\n    });\n    控制层接收\n    \n    public JSONObject del(@RequestBody String[] cids){\n           RecordBean<String> result = couponService.delBatch(cids);\n       if (result.isSuccessCode()) {\n          return JsonBean.success(result.getMsg());\n       }\n       return JsonBean.error(result.getMsg());\n2：@RequestParam\n\n    @RequestParam \n    \n    A） 常用来处理简单类型的绑定，通过Request.getParameter() 获取的String可直接转换为简单类型的情况（ String--> 简单类型的转换操作由ConversionService配置的转换器来完成）；因为使用request.getParameter()方式获取参数，所以可以处理get 方式中queryString的值，也可以处理post方式中 body data的值；\n    \n    B）用来处理Content-Type: 为 application/x-www-form-urlencoded编码的内容，提交方式GET、POST；\n    \n    C) 该注解有两个属性： name、required； \n    \n    name：用来指定要传入值的key名称\n    \n    required：用来指示参数是否必须绑定；当@RequestParam 被声明是Map<String, String> or MultiValueMap<String, String> required 为false\n    \n    相比 Request.getParameter() 获取 优点：\n    \n    通过注解的方式可以减少代码量，代码更整洁\n    \n    示例代码：\n    \n    $.ajax({\n        type: \"POST\",\n        url: \"/coupon/del\",\n        data: {ids:123},\n        success: function (result) {\n            layer.msg(result.msg)\n        }\n    });\n    控制层\n    \n    \n     \n     * 删除\n        */\n       @ResponseBody\n       @RequestMapping(\"/dels\")\n       public JSONObject dels(@RequestParam(name = \"ids\") Integer cids){\n          System.out.println(cids);\n          return JsonBean.success(\"ok\",cids);\n       }\n3:@ModelAttribute 注解获取参数\n\n    /**\n        * 删除\n        */\n       @RequestMapping(\"/coupon\")\n       @ResponseBody\n    // @RequiresPermissions(\"coupon:del\")\n       public JSONObject coupon(@ModelAttribute Coupon coupon){\n      return JsonBean.success(\"\",coupon);\n\n","slug":"spring-mvc-RequestBody-和-RequestParam-比较","published":1,"updated":"2019-07-14T03:11:26.978Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8mkctuw00154osx5fzjak9z","content":"<p>1： @RequestBody</p>\n<pre><code>@RequestBody 注解 通过 HttpMessageReader 使请求的body反序列化成一个对象。\n\nGET、POST方式提交时， 根据 request header Content-Type 的值来判断:\n\napplication/x-www-form-urlencoded， 可选（即非必须，因为这种情况的数据@RequestParam, @ModelAttribute也可以处理，当然@RequestBody也能处理）；\nmultipart/form-data, 不能处理（即使用@RequestBody不能处理这种格式的数据）；\n其他格式， 必须（其他格式包括application/json, application/xml等。这些格式的数据，使用@RequestBody来处理）；\n$.ajax({\n    type: &quot;POST&quot;,\n    url: &quot;/coupon/del&quot;,\n    dataType : &apos;json&apos;,\n    contentType : &apos;application/json;charset=UTF-8&apos;, // 设置请求的文本类型\n    data: JSON.stringify(ids),\n    success: function (result) {\n        layer.msg(result.msg)\n    }\n});\n控制层接收\n\npublic JSONObject del(@RequestBody String[] cids){\n       RecordBean&lt;String&gt; result = couponService.delBatch(cids);\n   if (result.isSuccessCode()) {\n      return JsonBean.success(result.getMsg());\n   }\n   return JsonBean.error(result.getMsg());\n</code></pre><p>2：@RequestParam</p>\n<pre><code>@RequestParam \n\nA） 常用来处理简单类型的绑定，通过Request.getParameter() 获取的String可直接转换为简单类型的情况（ String--&gt; 简单类型的转换操作由ConversionService配置的转换器来完成）；因为使用request.getParameter()方式获取参数，所以可以处理get 方式中queryString的值，也可以处理post方式中 body data的值；\n\nB）用来处理Content-Type: 为 application/x-www-form-urlencoded编码的内容，提交方式GET、POST；\n\nC) 该注解有两个属性： name、required； \n\nname：用来指定要传入值的key名称\n\nrequired：用来指示参数是否必须绑定；当@RequestParam 被声明是Map&lt;String, String&gt; or MultiValueMap&lt;String, String&gt; required 为false\n\n相比 Request.getParameter() 获取 优点：\n\n通过注解的方式可以减少代码量，代码更整洁\n\n示例代码：\n\n$.ajax({\n    type: &quot;POST&quot;,\n    url: &quot;/coupon/del&quot;,\n    data: {ids:123},\n    success: function (result) {\n        layer.msg(result.msg)\n    }\n});\n控制层\n\n\n\n * 删除\n    */\n   @ResponseBody\n   @RequestMapping(&quot;/dels&quot;)\n   public JSONObject dels(@RequestParam(name = &quot;ids&quot;) Integer cids){\n      System.out.println(cids);\n      return JsonBean.success(&quot;ok&quot;,cids);\n   }\n</code></pre><p>3:@ModelAttribute 注解获取参数</p>\n<pre><code>/**\n    * 删除\n    */\n   @RequestMapping(&quot;/coupon&quot;)\n   @ResponseBody\n// @RequiresPermissions(&quot;coupon:del&quot;)\n   public JSONObject coupon(@ModelAttribute Coupon coupon){\n  return JsonBean.success(&quot;&quot;,coupon);\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>1： @RequestBody</p>\n<pre><code>@RequestBody 注解 通过 HttpMessageReader 使请求的body反序列化成一个对象。\n\nGET、POST方式提交时， 根据 request header Content-Type 的值来判断:\n\napplication/x-www-form-urlencoded， 可选（即非必须，因为这种情况的数据@RequestParam, @ModelAttribute也可以处理，当然@RequestBody也能处理）；\nmultipart/form-data, 不能处理（即使用@RequestBody不能处理这种格式的数据）；\n其他格式， 必须（其他格式包括application/json, application/xml等。这些格式的数据，使用@RequestBody来处理）；\n$.ajax({\n    type: &quot;POST&quot;,\n    url: &quot;/coupon/del&quot;,\n    dataType : &apos;json&apos;,\n    contentType : &apos;application/json;charset=UTF-8&apos;, // 设置请求的文本类型\n    data: JSON.stringify(ids),\n    success: function (result) {\n        layer.msg(result.msg)\n    }\n});\n控制层接收\n\npublic JSONObject del(@RequestBody String[] cids){\n       RecordBean&lt;String&gt; result = couponService.delBatch(cids);\n   if (result.isSuccessCode()) {\n      return JsonBean.success(result.getMsg());\n   }\n   return JsonBean.error(result.getMsg());\n</code></pre><p>2：@RequestParam</p>\n<pre><code>@RequestParam \n\nA） 常用来处理简单类型的绑定，通过Request.getParameter() 获取的String可直接转换为简单类型的情况（ String--&gt; 简单类型的转换操作由ConversionService配置的转换器来完成）；因为使用request.getParameter()方式获取参数，所以可以处理get 方式中queryString的值，也可以处理post方式中 body data的值；\n\nB）用来处理Content-Type: 为 application/x-www-form-urlencoded编码的内容，提交方式GET、POST；\n\nC) 该注解有两个属性： name、required； \n\nname：用来指定要传入值的key名称\n\nrequired：用来指示参数是否必须绑定；当@RequestParam 被声明是Map&lt;String, String&gt; or MultiValueMap&lt;String, String&gt; required 为false\n\n相比 Request.getParameter() 获取 优点：\n\n通过注解的方式可以减少代码量，代码更整洁\n\n示例代码：\n\n$.ajax({\n    type: &quot;POST&quot;,\n    url: &quot;/coupon/del&quot;,\n    data: {ids:123},\n    success: function (result) {\n        layer.msg(result.msg)\n    }\n});\n控制层\n\n\n\n * 删除\n    */\n   @ResponseBody\n   @RequestMapping(&quot;/dels&quot;)\n   public JSONObject dels(@RequestParam(name = &quot;ids&quot;) Integer cids){\n      System.out.println(cids);\n      return JsonBean.success(&quot;ok&quot;,cids);\n   }\n</code></pre><p>3:@ModelAttribute 注解获取参数</p>\n<pre><code>/**\n    * 删除\n    */\n   @RequestMapping(&quot;/coupon&quot;)\n   @ResponseBody\n// @RequiresPermissions(&quot;coupon:del&quot;)\n   public JSONObject coupon(@ModelAttribute Coupon coupon){\n  return JsonBean.success(&quot;&quot;,coupon);\n</code></pre>"},{"title":"使用iframe遇到的问题","date":"2019-03-15T01:58:07.000Z","_content":"# 1：在iframe中使用layer弹框引发的一些问题\n1. 弹框后，出现子窗口高度不够，导致显示内容不全\n![在这里插入图片描述](https://img.mupaie.com/20190227175949596.png)\n\n使用iframe 代码如下：\n\n\t<div class=\"layui-tab-content\" style=\"min-height: 150px; padding: 0 0 0 0;\">\n\t\t<div class=\"layui-tab-item layui-show\">\n\t\t\t<iframe src=\"/main\" name=\"main\" scrolling=\"auto\"></iframe>\n\t\t</div>\n\t</div>\n出现这个问题的原因主要是 iframe 设置的高度是100%，没有设置具体的高度，导致子窗口没有参考物导致其即使设置了高度也不能讲父元素撑开。出现这种情况目前有二种方式：\n* 给iframe 设置样式 overflow: auto;\n* 通过 js 获取窗体的高度，减去头部和底部的高度剩下的就是内容的高度，然后给iframe 设置高度，具体代码如下：\n\n\t\t$(window).on('resize', function () {\n\t\t        let resizeTimer = null;\n\t\t        if (resizeTimer) {\n\t\t            clearTimeout(resizeTimer);\n\t\t        }\n\t\t        resizeTimer = setTimeout(function () {\n\t\t            setContentSize();\n\t\t        }, 500);\n\t\t    }).resize();\n\n\t    function setContentSize() {\n\t        var $content = $('.admin-nav-card .layui-tab-content');\n\t        $content.height($(this).height() - 147);\n\t        $content.find('iframe').each(function () {\n\t            $(this).height($content.height());\n\t            $(this).width($content.width());\n\t            $(this).contents().find(\".layui-layer-iframe\").width($content.width())\n\t        });\n\t    }\n解释一下，主要是监听窗体调整，获取窗体的高度，减去头部和底部的高度剩下的就是\\$content的高度，然后给iframe设置高度，代码中运行了延迟加载，防止函数执行过快。\n\n2. 高度虽然解决了，但是又出现一个问题，当弹窗使用全屏显示的时候，调整窗体宽度，里面内容不会跟着改变，那么问题来了出现这种效果：\n![在这里插入图片描述](https://img.mupaie.com/20190227184346806.png)\n里面的内容被覆盖了，导致这个原因主要是里面iframe和弹窗内容div的宽度没有跟着改变，那么我们怎么解决呢，想到上一节讲了高度设置，那么我们宽度也跟着设置呀。带着这个想法，我试一下修改iframe的宽度\n\n```\n\t\tfunction setContentSize() {\n\t        var $content = $('.admin-nav-card .layui-tab-content');\n\t        $content.height($(this).height() - 147);\n\t        $content.find('iframe').each(function () {\n\t            $(this).height($content.height());\n\t            $(this).width($content.width());\n\t        });\n\t    }\n   ```\n结果还是出现上述那个问题，那到底为啥呢？然后通过F12 模式 调试了一下，原来弹框里面有一个div也设置了宽度，那我跟iframe一起一并修改呢?\n\n```\n\tfunction setContentSize() {\n        var $content = $('.admin-nav-card .layui-tab-content');\n        if ($(this).width > 768) {\n\n        }\n        $content.height($(this).height() - 147);\n        $content.find('iframe').each(function () {\n            $(this).height($content.height());\n            $(this).width($content.width());\n            $(this).contents().find(\".layui-layer-iframe\").width($content.width())\n        });\n    }.\n```\n尝试了一下果真可以，现在看效果：\n![调整窗体前](https://img.mupaie.com/20190227185309289.png)\n\n![调整窗体后](https://img.mupaie.com/20190227185353924.png)\n这样终于算解决问题了，有一个前端小伙伴告诉我还有一种方式，就是改变窗体宽度的时候，调用一个layer.full(index)，index 是创建弹窗的编号。这种方式好处就是内部自动根据窗体宽度调整弹窗宽度，但是有个问题我怎么去获取那个index呢？这个问题等以后解决吧，先放放。。。\n\n# 2. 手机端解决iframe 中内容不能左右移动的问题\n现在是pc端解决了适配，但是手机端呢，用上述的代码显示的页面不能左右移动。这下就需要Google一把了，带着问题去搜索了一下网上大佬说：先给iframe 套一个div 然后给div设置样式\n\n```\n@media screen and (max-width: 768px) {\n\t/* 主体容器 */\n    .admin-nav-card .layui-tab-item {\n        -webkit-overflow-scrolling: touch;\n        overflow: auto;\n    }\n }\n ```\n结果试了一次果真可以实现，但是由于手机品牌很多，需要适配就难上加难，由于自己又不是一个前端人员就先放放了，等有时间在跟着上述的问题一起解决。\n\n参考文档：\n\n[子窗口高度不够](https://fly.layui.com/jie/33662/)\n[iphone下iframe问题记录](https://www.jianshu.com/p/bd9fbf5a14f0)\n\n","source":"_posts/使用iframe遇到的问题.md","raw":"---\ntitle: 使用iframe遇到的问题\ndate: 2019-03-15 09:58:07\ntags:\n- HTML\n---\n# 1：在iframe中使用layer弹框引发的一些问题\n1. 弹框后，出现子窗口高度不够，导致显示内容不全\n![在这里插入图片描述](https://img.mupaie.com/20190227175949596.png)\n\n使用iframe 代码如下：\n\n\t<div class=\"layui-tab-content\" style=\"min-height: 150px; padding: 0 0 0 0;\">\n\t\t<div class=\"layui-tab-item layui-show\">\n\t\t\t<iframe src=\"/main\" name=\"main\" scrolling=\"auto\"></iframe>\n\t\t</div>\n\t</div>\n出现这个问题的原因主要是 iframe 设置的高度是100%，没有设置具体的高度，导致子窗口没有参考物导致其即使设置了高度也不能讲父元素撑开。出现这种情况目前有二种方式：\n* 给iframe 设置样式 overflow: auto;\n* 通过 js 获取窗体的高度，减去头部和底部的高度剩下的就是内容的高度，然后给iframe 设置高度，具体代码如下：\n\n\t\t$(window).on('resize', function () {\n\t\t        let resizeTimer = null;\n\t\t        if (resizeTimer) {\n\t\t            clearTimeout(resizeTimer);\n\t\t        }\n\t\t        resizeTimer = setTimeout(function () {\n\t\t            setContentSize();\n\t\t        }, 500);\n\t\t    }).resize();\n\n\t    function setContentSize() {\n\t        var $content = $('.admin-nav-card .layui-tab-content');\n\t        $content.height($(this).height() - 147);\n\t        $content.find('iframe').each(function () {\n\t            $(this).height($content.height());\n\t            $(this).width($content.width());\n\t            $(this).contents().find(\".layui-layer-iframe\").width($content.width())\n\t        });\n\t    }\n解释一下，主要是监听窗体调整，获取窗体的高度，减去头部和底部的高度剩下的就是\\$content的高度，然后给iframe设置高度，代码中运行了延迟加载，防止函数执行过快。\n\n2. 高度虽然解决了，但是又出现一个问题，当弹窗使用全屏显示的时候，调整窗体宽度，里面内容不会跟着改变，那么问题来了出现这种效果：\n![在这里插入图片描述](https://img.mupaie.com/20190227184346806.png)\n里面的内容被覆盖了，导致这个原因主要是里面iframe和弹窗内容div的宽度没有跟着改变，那么我们怎么解决呢，想到上一节讲了高度设置，那么我们宽度也跟着设置呀。带着这个想法，我试一下修改iframe的宽度\n\n```\n\t\tfunction setContentSize() {\n\t        var $content = $('.admin-nav-card .layui-tab-content');\n\t        $content.height($(this).height() - 147);\n\t        $content.find('iframe').each(function () {\n\t            $(this).height($content.height());\n\t            $(this).width($content.width());\n\t        });\n\t    }\n   ```\n结果还是出现上述那个问题，那到底为啥呢？然后通过F12 模式 调试了一下，原来弹框里面有一个div也设置了宽度，那我跟iframe一起一并修改呢?\n\n```\n\tfunction setContentSize() {\n        var $content = $('.admin-nav-card .layui-tab-content');\n        if ($(this).width > 768) {\n\n        }\n        $content.height($(this).height() - 147);\n        $content.find('iframe').each(function () {\n            $(this).height($content.height());\n            $(this).width($content.width());\n            $(this).contents().find(\".layui-layer-iframe\").width($content.width())\n        });\n    }.\n```\n尝试了一下果真可以，现在看效果：\n![调整窗体前](https://img.mupaie.com/20190227185309289.png)\n\n![调整窗体后](https://img.mupaie.com/20190227185353924.png)\n这样终于算解决问题了，有一个前端小伙伴告诉我还有一种方式，就是改变窗体宽度的时候，调用一个layer.full(index)，index 是创建弹窗的编号。这种方式好处就是内部自动根据窗体宽度调整弹窗宽度，但是有个问题我怎么去获取那个index呢？这个问题等以后解决吧，先放放。。。\n\n# 2. 手机端解决iframe 中内容不能左右移动的问题\n现在是pc端解决了适配，但是手机端呢，用上述的代码显示的页面不能左右移动。这下就需要Google一把了，带着问题去搜索了一下网上大佬说：先给iframe 套一个div 然后给div设置样式\n\n```\n@media screen and (max-width: 768px) {\n\t/* 主体容器 */\n    .admin-nav-card .layui-tab-item {\n        -webkit-overflow-scrolling: touch;\n        overflow: auto;\n    }\n }\n ```\n结果试了一次果真可以实现，但是由于手机品牌很多，需要适配就难上加难，由于自己又不是一个前端人员就先放放了，等有时间在跟着上述的问题一起解决。\n\n参考文档：\n\n[子窗口高度不够](https://fly.layui.com/jie/33662/)\n[iphone下iframe问题记录](https://www.jianshu.com/p/bd9fbf5a14f0)\n\n","slug":"使用iframe遇到的问题","published":1,"updated":"2019-07-14T04:34:16.891Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8mkctux00174osxpxx51gmc","content":"<h1 id=\"1：在iframe中使用layer弹框引发的一些问题\"><a href=\"#1：在iframe中使用layer弹框引发的一些问题\" class=\"headerlink\" title=\"1：在iframe中使用layer弹框引发的一些问题\"></a>1：在iframe中使用layer弹框引发的一些问题</h1><ol>\n<li>弹框后，出现子窗口高度不够，导致显示内容不全<br><img src=\"https://img.mupaie.com/20190227175949596.png\" alt=\"在这里插入图片描述\"></li>\n</ol>\n<p>使用iframe 代码如下：</p>\n<pre><code>&lt;div class=&quot;layui-tab-content&quot; style=&quot;min-height: 150px; padding: 0 0 0 0;&quot;&gt;\n    &lt;div class=&quot;layui-tab-item layui-show&quot;&gt;\n        &lt;iframe src=&quot;/main&quot; name=&quot;main&quot; scrolling=&quot;auto&quot;&gt;&lt;/iframe&gt;\n    &lt;/div&gt;\n&lt;/div&gt;\n</code></pre><p>出现这个问题的原因主要是 iframe 设置的高度是100%，没有设置具体的高度，导致子窗口没有参考物导致其即使设置了高度也不能讲父元素撑开。出现这种情况目前有二种方式：</p>\n<ul>\n<li>给iframe 设置样式 overflow: auto;</li>\n<li><p>通过 js 获取窗体的高度，减去头部和底部的高度剩下的就是内容的高度，然后给iframe 设置高度，具体代码如下：</p>\n<pre><code>$(window).on(&apos;resize&apos;, function () {\n        let resizeTimer = null;\n        if (resizeTimer) {\n            clearTimeout(resizeTimer);\n        }\n        resizeTimer = setTimeout(function () {\n            setContentSize();\n        }, 500);\n    }).resize();\n\nfunction setContentSize() {\n    var $content = $(&apos;.admin-nav-card .layui-tab-content&apos;);\n    $content.height($(this).height() - 147);\n    $content.find(&apos;iframe&apos;).each(function () {\n        $(this).height($content.height());\n        $(this).width($content.width());\n        $(this).contents().find(&quot;.layui-layer-iframe&quot;).width($content.width())\n    });\n}\n</code></pre><p>解释一下，主要是监听窗体调整，获取窗体的高度，减去头部和底部的高度剩下的就是\\$content的高度，然后给iframe设置高度，代码中运行了延迟加载，防止函数执行过快。</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li>高度虽然解决了，但是又出现一个问题，当弹窗使用全屏显示的时候，调整窗体宽度，里面内容不会跟着改变，那么问题来了出现这种效果：<br><img src=\"https://img.mupaie.com/20190227184346806.png\" alt=\"在这里插入图片描述\"><br>里面的内容被覆盖了，导致这个原因主要是里面iframe和弹窗内容div的宽度没有跟着改变，那么我们怎么解决呢，想到上一节讲了高度设置，那么我们宽度也跟着设置呀。带着这个想法，我试一下修改iframe的宽度</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function setContentSize() &#123;</span><br><span class=\"line\">       var $content = $(&apos;.admin-nav-card .layui-tab-content&apos;);</span><br><span class=\"line\">       $content.height($(this).height() - 147);</span><br><span class=\"line\">       $content.find(&apos;iframe&apos;).each(function () &#123;</span><br><span class=\"line\">           $(this).height($content.height());</span><br><span class=\"line\">           $(this).width($content.width());</span><br><span class=\"line\">       &#125;);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>结果还是出现上述那个问题，那到底为啥呢？然后通过F12 模式 调试了一下，原来弹框里面有一个div也设置了宽度，那我跟iframe一起一并修改呢?</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function setContentSize() &#123;</span><br><span class=\"line\">       var $content = $(&apos;.admin-nav-card .layui-tab-content&apos;);</span><br><span class=\"line\">       if ($(this).width &gt; 768) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       $content.height($(this).height() - 147);</span><br><span class=\"line\">       $content.find(&apos;iframe&apos;).each(function () &#123;</span><br><span class=\"line\">           $(this).height($content.height());</span><br><span class=\"line\">           $(this).width($content.width());</span><br><span class=\"line\">           $(this).contents().find(&quot;.layui-layer-iframe&quot;).width($content.width())</span><br><span class=\"line\">       &#125;);</span><br><span class=\"line\">   &#125;.</span><br></pre></td></tr></table></figure>\n<p>尝试了一下果真可以，现在看效果：<br><img src=\"https://img.mupaie.com/20190227185309289.png\" alt=\"调整窗体前\"></p>\n<p><img src=\"https://img.mupaie.com/20190227185353924.png\" alt=\"调整窗体后\"><br>这样终于算解决问题了，有一个前端小伙伴告诉我还有一种方式，就是改变窗体宽度的时候，调用一个layer.full(index)，index 是创建弹窗的编号。这种方式好处就是内部自动根据窗体宽度调整弹窗宽度，但是有个问题我怎么去获取那个index呢？这个问题等以后解决吧，先放放。。。</p>\n<h1 id=\"2-手机端解决iframe-中内容不能左右移动的问题\"><a href=\"#2-手机端解决iframe-中内容不能左右移动的问题\" class=\"headerlink\" title=\"2. 手机端解决iframe 中内容不能左右移动的问题\"></a>2. 手机端解决iframe 中内容不能左右移动的问题</h1><p>现在是pc端解决了适配，但是手机端呢，用上述的代码显示的页面不能左右移动。这下就需要Google一把了，带着问题去搜索了一下网上大佬说：先给iframe 套一个div 然后给div设置样式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@media screen and (max-width: 768px) &#123;</span><br><span class=\"line\">\t/* 主体容器 */</span><br><span class=\"line\">    .admin-nav-card .layui-tab-item &#123;</span><br><span class=\"line\">        -webkit-overflow-scrolling: touch;</span><br><span class=\"line\">        overflow: auto;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>结果试了一次果真可以实现，但是由于手机品牌很多，需要适配就难上加难，由于自己又不是一个前端人员就先放放了，等有时间在跟着上述的问题一起解决。</p>\n<p>参考文档：</p>\n<p><a href=\"https://fly.layui.com/jie/33662/\" target=\"_blank\" rel=\"noopener\">子窗口高度不够</a><br><a href=\"https://www.jianshu.com/p/bd9fbf5a14f0\" target=\"_blank\" rel=\"noopener\">iphone下iframe问题记录</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1：在iframe中使用layer弹框引发的一些问题\"><a href=\"#1：在iframe中使用layer弹框引发的一些问题\" class=\"headerlink\" title=\"1：在iframe中使用layer弹框引发的一些问题\"></a>1：在iframe中使用layer弹框引发的一些问题</h1><ol>\n<li>弹框后，出现子窗口高度不够，导致显示内容不全<br><img src=\"https://img.mupaie.com/20190227175949596.png\" alt=\"在这里插入图片描述\"></li>\n</ol>\n<p>使用iframe 代码如下：</p>\n<pre><code>&lt;div class=&quot;layui-tab-content&quot; style=&quot;min-height: 150px; padding: 0 0 0 0;&quot;&gt;\n    &lt;div class=&quot;layui-tab-item layui-show&quot;&gt;\n        &lt;iframe src=&quot;/main&quot; name=&quot;main&quot; scrolling=&quot;auto&quot;&gt;&lt;/iframe&gt;\n    &lt;/div&gt;\n&lt;/div&gt;\n</code></pre><p>出现这个问题的原因主要是 iframe 设置的高度是100%，没有设置具体的高度，导致子窗口没有参考物导致其即使设置了高度也不能讲父元素撑开。出现这种情况目前有二种方式：</p>\n<ul>\n<li>给iframe 设置样式 overflow: auto;</li>\n<li><p>通过 js 获取窗体的高度，减去头部和底部的高度剩下的就是内容的高度，然后给iframe 设置高度，具体代码如下：</p>\n<pre><code>$(window).on(&apos;resize&apos;, function () {\n        let resizeTimer = null;\n        if (resizeTimer) {\n            clearTimeout(resizeTimer);\n        }\n        resizeTimer = setTimeout(function () {\n            setContentSize();\n        }, 500);\n    }).resize();\n\nfunction setContentSize() {\n    var $content = $(&apos;.admin-nav-card .layui-tab-content&apos;);\n    $content.height($(this).height() - 147);\n    $content.find(&apos;iframe&apos;).each(function () {\n        $(this).height($content.height());\n        $(this).width($content.width());\n        $(this).contents().find(&quot;.layui-layer-iframe&quot;).width($content.width())\n    });\n}\n</code></pre><p>解释一下，主要是监听窗体调整，获取窗体的高度，减去头部和底部的高度剩下的就是\\$content的高度，然后给iframe设置高度，代码中运行了延迟加载，防止函数执行过快。</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li>高度虽然解决了，但是又出现一个问题，当弹窗使用全屏显示的时候，调整窗体宽度，里面内容不会跟着改变，那么问题来了出现这种效果：<br><img src=\"https://img.mupaie.com/20190227184346806.png\" alt=\"在这里插入图片描述\"><br>里面的内容被覆盖了，导致这个原因主要是里面iframe和弹窗内容div的宽度没有跟着改变，那么我们怎么解决呢，想到上一节讲了高度设置，那么我们宽度也跟着设置呀。带着这个想法，我试一下修改iframe的宽度</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function setContentSize() &#123;</span><br><span class=\"line\">       var $content = $(&apos;.admin-nav-card .layui-tab-content&apos;);</span><br><span class=\"line\">       $content.height($(this).height() - 147);</span><br><span class=\"line\">       $content.find(&apos;iframe&apos;).each(function () &#123;</span><br><span class=\"line\">           $(this).height($content.height());</span><br><span class=\"line\">           $(this).width($content.width());</span><br><span class=\"line\">       &#125;);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>结果还是出现上述那个问题，那到底为啥呢？然后通过F12 模式 调试了一下，原来弹框里面有一个div也设置了宽度，那我跟iframe一起一并修改呢?</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function setContentSize() &#123;</span><br><span class=\"line\">       var $content = $(&apos;.admin-nav-card .layui-tab-content&apos;);</span><br><span class=\"line\">       if ($(this).width &gt; 768) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       $content.height($(this).height() - 147);</span><br><span class=\"line\">       $content.find(&apos;iframe&apos;).each(function () &#123;</span><br><span class=\"line\">           $(this).height($content.height());</span><br><span class=\"line\">           $(this).width($content.width());</span><br><span class=\"line\">           $(this).contents().find(&quot;.layui-layer-iframe&quot;).width($content.width())</span><br><span class=\"line\">       &#125;);</span><br><span class=\"line\">   &#125;.</span><br></pre></td></tr></table></figure>\n<p>尝试了一下果真可以，现在看效果：<br><img src=\"https://img.mupaie.com/20190227185309289.png\" alt=\"调整窗体前\"></p>\n<p><img src=\"https://img.mupaie.com/20190227185353924.png\" alt=\"调整窗体后\"><br>这样终于算解决问题了，有一个前端小伙伴告诉我还有一种方式，就是改变窗体宽度的时候，调用一个layer.full(index)，index 是创建弹窗的编号。这种方式好处就是内部自动根据窗体宽度调整弹窗宽度，但是有个问题我怎么去获取那个index呢？这个问题等以后解决吧，先放放。。。</p>\n<h1 id=\"2-手机端解决iframe-中内容不能左右移动的问题\"><a href=\"#2-手机端解决iframe-中内容不能左右移动的问题\" class=\"headerlink\" title=\"2. 手机端解决iframe 中内容不能左右移动的问题\"></a>2. 手机端解决iframe 中内容不能左右移动的问题</h1><p>现在是pc端解决了适配，但是手机端呢，用上述的代码显示的页面不能左右移动。这下就需要Google一把了，带着问题去搜索了一下网上大佬说：先给iframe 套一个div 然后给div设置样式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@media screen and (max-width: 768px) &#123;</span><br><span class=\"line\">\t/* 主体容器 */</span><br><span class=\"line\">    .admin-nav-card .layui-tab-item &#123;</span><br><span class=\"line\">        -webkit-overflow-scrolling: touch;</span><br><span class=\"line\">        overflow: auto;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>结果试了一次果真可以实现，但是由于手机品牌很多，需要适配就难上加难，由于自己又不是一个前端人员就先放放了，等有时间在跟着上述的问题一起解决。</p>\n<p>参考文档：</p>\n<p><a href=\"https://fly.layui.com/jie/33662/\" target=\"_blank\" rel=\"noopener\">子窗口高度不够</a><br><a href=\"https://www.jianshu.com/p/bd9fbf5a14f0\" target=\"_blank\" rel=\"noopener\">iphone下iframe问题记录</a></p>\n"},{"title":"jvm 面试问题总结(一)","date":"2019-03-15T01:49:26.000Z","_content":"\n\n# 1.java 8 将 jvm 中 永久代去除带来的好处？\n* 元空间存放在本地内存中避免之前使用永久代出现内存溢出的问题。\n* 类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。\n* 永久代会通过 full GC 进行回收，这种操作复杂度较高，回收效率偏低。\n# 2.如何判断对象死亡，有哪两种方法？\n1. 引用计数法：\n当该对象被引用时，计数器就加1；当引用失效，计数器就减1；任何时候计数器为0的对象就是不可能再被使用的。\n缺点：这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。 所谓对象之间的相互引用问题，如下面代码所示：除了对象objA 和 objB 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为0，于是引用计数算法无法通知 GC 回收器回收他们。\n2. 可达性分析算法：\n通过一系列“GC Roots” 的对象为起点，从这些节点开始向下搜索，搜索多走过的路径称为引用链，当对象到GC Roots没有任何的引用链相连就判断该对象已经失效。\n# 3.再谈引用：\n1. 强引用\n\t* 概述：强引用在代码中很普遍，平时我们通过new 关键字创建的引用都是强引用，只要强引用存在，垃圾收集器就不会回收引用对象强引用在代码中很普遍，平时我们通过new 关键字创建的引用都是强引用，只要强引用存在，垃圾收集器就不会回收引用对象\n\t* 实现：通过new 关键字创建的引用\n2. 软引用\n\t* 概述：描述一些还有用但是并不必需的对象，如果内存空间足够，垃圾回收器就不会回收它，如果发生内存溢出之前，垃圾回收器将这些对象列进回收范围之中进行第二次回收。如果这次回收还是没有足够的内存，就会发生内存溢出。\n\t* 用途：软引用可用来实现内存敏感的高速缓存。\n\t* 实现：Jdk 提供 SoftReference 类来实现软引用。\n3. 弱引用\n   * 概述：非必要对象，当GC发生就会被回收，生命周期很短暂\n   * 实现：Jdk 提供 WeakReference 类来实现弱引用。\n   **注意：由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象**\n4. 虚引用\n\t* 概述：与其他几种引用都不同，虚引用完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。\n\t* 用途：使对象被收集器回收时收到一个系统通知。\n\t* 实现：Jdk 提供 PhantomkReference 类来实现虚引用。\n5. 弱引用和软引用的区别\n只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收掉只被弱引用关联的对象。\n# 4.HotSpot为什么要分为新生代和老年代？\n一般将java堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。\n* 新生代：每次收集都会有大量对象死去，所以可以选择复制算法\n* 老年代：对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集\n# 5.Minor GC和Full GC 分别指什么？\n* 新生代（Minor GC）:指新生代的垃圾收集，执行操作频繁，回收速度较快。\n* 老年代（Major GC/Full GC）:指发生老年代的垃圾回收，出现Major GC经常会伴随一次Minor GC （并非绝对，只有当发生Major GC时 晋升到老年代的内存 大于老年代的剩余内存，这种情况下 会发生Full GC），Major GC的速度一般会比Minor GC的慢10倍以上。\n默认情况下 新生代和老年代的堆空间的分布情况\n![在这里插入图片描述](https://img.mupaie.com/20190228151004551.png)\n注意：虚拟机每次只会使用 Eden 和其中的一块 Survivor 区域来为对象服务，所以无论什么时候，总是有一块 Survivor 区域是空闲着的。 因此，新生代实际可用的内存空间为90%的新生代空间。\n大数据（数组和字符串【字符数组】 ）直接被存放在老年代中，原因是（为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率）\n* 长期存活的对象进入老年代\n每次进行垃圾回收存活下来的对象年龄都会加一岁，等达到一定程度后该对象就会进行老年代。具体设置年龄阈值，通过参数 -XX:MaxTenuringThreshold 来设置。\n* 动态对象年龄判定\n有一种情况当相同年龄的对象总和大于Survivor 空间的一半时，年龄大于或等于该值的对象直接进入老年代\n# 6. 垃圾回收算法有哪些？优缺点？\n* 标记 - 清除算法\n标记需要回收的对象，标记完成后在垃圾回收器统一收集那些被标记的对象。\n缺点：\n  * 效率不高：标记和清除过程效率不高，主要原因是标记的对象分布不均匀\n  * 空间问题：清除后产生大量内存碎片，导致以后程序不能给大对象分配连续的内存空间\n* 复制算法\n将内存分成两块容量大小相同区域，当一块区域内存用完后，经过GC之后幸存的对象将复制到另外一个区域中，剩余的内存空间一次清除即可，不管什么时刻总有一块区域是空闲的。\n\t* 效率高：每次只需要回收复制后剩余的内存，这样也不会产生内存碎片的问题，移动对顶指针，按顺序分配内存即可，实现简单，运行高效，但是如果存活率较高的情况，复制算法的效率也会随着下降\n\t* 成本高：时刻保证有一块区域是空闲的，这样导致新生代有10%的内存是浪费的。由于 Eden : from : to = 8:1:1\n\t![在这里插入图片描述](https://img.mupaie.com/20190307141705245.png)\n* 标记-整理算法\n跟上述说的标记-清除算法很类似，但是后续步骤不是对可回收的对象直接回收，而是让这一部分标记的对象都向一端移动，最终清除靠近端边的内存，这样好处减少内存碎片的产生。\n缺点：实现起来复杂，执行步骤较多\n![在这里插入图片描述](https://img.mupaie.com/20190307142226586.png)\n* 分代收集算法\n目前很多虚拟机的垃圾回收器都采用分代收集算法，主要原因分代回收能根据对象的生存周期进行内存划分，主要分新生代和老年代并根据每个年代的特点采用不同的回收算法，使内存回收更加高效。由于新生代，每次垃圾回收都有大片对象死亡，只有少数对象存活这样我们使用复制算法。老年代每次垃圾回收只有少量对象死亡，整体存活率较高，没有额外的内存对它进行分配，所以采用标记-整理算法或标记-清除算法\n# 7.垃圾回收器有哪些？\n* Serial 收集器\n单线程进行垃圾回收工作，在收集过程中，必须停止其他所有的工作线程，直到回收结束其他工作线程才能继续工作。\n算法：复制算法\n* ParNew 收集器\n对上述收集器进行补充，采用多线程对垃圾进行回收，这样相比单线程整体的效率得到提高。\n算法：复制算法\n* Parallel Scavenge 收集器\n和上述收集器不同的是，Parallel Scavenge 关注点主要是达到一个可控制的吞吐量。所谓的吞吐量就是CPU 用于运行代码的时间与CPU总消耗时间的比值，吞吐量 = 运行代码的时间/(运行代码的时间 +垃圾回收的时间)，吞吐量越高，则相对的垃圾回收时间降低。那平时我们如何控制吞吐量呢，Parallel Scavenge给了我们两个参数来控制吞吐量 最大垃圾收集停顿时间 -XX：MaxGCPauseMillis 和 设置吞吐量大小 -XX:GCTimeRatio 参数，具体参考 [深入理解Java虚拟器]()\n算法：复制算法\n* Serial old 收集器\n主要用于老年代的垃圾回收，采用单线程进行垃圾回收。\n算法：标记-整理\n* Parallel old 收集器\n主要用于老年代的垃圾回收，采用多线程进行垃圾回收。和 Parallel Scavenge 收集器一样， Parallel old 关注点也是吞吐量\n算法：标记-整理\n* cms 收集器\nCMS 收集器是一种以获取最短回收停顿时间为目标的收集器，基于标记-清除算法实现，具体包括四个步骤：\n\t* 初始化标记\n\t* 并发标记\n\t* 重新标记\n\t* 并发清除\n整体执行过程如下图所示：\n![在这里插入图片描述](https://img.mupaie.com/20190307151001702.png)\n从上图可以看出，除了初始标记和重新标记需要“Stop The World”,其余都是可以和用户线程一起执行的。\n缺点：\n   * 对CPU 资源非常敏感\n   * 无法处理浮动垃圾，由于清除过程伴随着用户线程，用户线程产生的新垃圾在标记过后，CMS 无法在当次收集中处理它们，留给下次GC再进行处理，这部分垃圾就叫做浮动垃圾\n   * 由于采用 标记-清除算法会产生大量内存碎片\n* G1 收集器\nG1 是当今收集器技术中的最前沿技术，相比其他收集器它具有几个特点：\n\t* 并行与并发\n\t* 分代收集\n\t* 空间整理\n\t* 可预测的停顿\n\n算法：复制算法和标记-整理算法\n\n\n参考文档\n\t[深入理解Java虚拟器]()\n\t[Java面试通关手册](https://github.com/Snailclimb/JavaGuide/blob/master/Java%E7%9B%B8%E5%85%B3/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88jvm%EF%BC%89.md)\n\n","source":"_posts/jvm-面试问题总结-一.md","raw":"---\ntitle: jvm 面试问题总结(一)\ndate: 2019-03-15 09:49:26\ntags:\n- JVM\n---\n\n\n# 1.java 8 将 jvm 中 永久代去除带来的好处？\n* 元空间存放在本地内存中避免之前使用永久代出现内存溢出的问题。\n* 类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。\n* 永久代会通过 full GC 进行回收，这种操作复杂度较高，回收效率偏低。\n# 2.如何判断对象死亡，有哪两种方法？\n1. 引用计数法：\n当该对象被引用时，计数器就加1；当引用失效，计数器就减1；任何时候计数器为0的对象就是不可能再被使用的。\n缺点：这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。 所谓对象之间的相互引用问题，如下面代码所示：除了对象objA 和 objB 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为0，于是引用计数算法无法通知 GC 回收器回收他们。\n2. 可达性分析算法：\n通过一系列“GC Roots” 的对象为起点，从这些节点开始向下搜索，搜索多走过的路径称为引用链，当对象到GC Roots没有任何的引用链相连就判断该对象已经失效。\n# 3.再谈引用：\n1. 强引用\n\t* 概述：强引用在代码中很普遍，平时我们通过new 关键字创建的引用都是强引用，只要强引用存在，垃圾收集器就不会回收引用对象强引用在代码中很普遍，平时我们通过new 关键字创建的引用都是强引用，只要强引用存在，垃圾收集器就不会回收引用对象\n\t* 实现：通过new 关键字创建的引用\n2. 软引用\n\t* 概述：描述一些还有用但是并不必需的对象，如果内存空间足够，垃圾回收器就不会回收它，如果发生内存溢出之前，垃圾回收器将这些对象列进回收范围之中进行第二次回收。如果这次回收还是没有足够的内存，就会发生内存溢出。\n\t* 用途：软引用可用来实现内存敏感的高速缓存。\n\t* 实现：Jdk 提供 SoftReference 类来实现软引用。\n3. 弱引用\n   * 概述：非必要对象，当GC发生就会被回收，生命周期很短暂\n   * 实现：Jdk 提供 WeakReference 类来实现弱引用。\n   **注意：由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象**\n4. 虚引用\n\t* 概述：与其他几种引用都不同，虚引用完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。\n\t* 用途：使对象被收集器回收时收到一个系统通知。\n\t* 实现：Jdk 提供 PhantomkReference 类来实现虚引用。\n5. 弱引用和软引用的区别\n只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收掉只被弱引用关联的对象。\n# 4.HotSpot为什么要分为新生代和老年代？\n一般将java堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。\n* 新生代：每次收集都会有大量对象死去，所以可以选择复制算法\n* 老年代：对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集\n# 5.Minor GC和Full GC 分别指什么？\n* 新生代（Minor GC）:指新生代的垃圾收集，执行操作频繁，回收速度较快。\n* 老年代（Major GC/Full GC）:指发生老年代的垃圾回收，出现Major GC经常会伴随一次Minor GC （并非绝对，只有当发生Major GC时 晋升到老年代的内存 大于老年代的剩余内存，这种情况下 会发生Full GC），Major GC的速度一般会比Minor GC的慢10倍以上。\n默认情况下 新生代和老年代的堆空间的分布情况\n![在这里插入图片描述](https://img.mupaie.com/20190228151004551.png)\n注意：虚拟机每次只会使用 Eden 和其中的一块 Survivor 区域来为对象服务，所以无论什么时候，总是有一块 Survivor 区域是空闲着的。 因此，新生代实际可用的内存空间为90%的新生代空间。\n大数据（数组和字符串【字符数组】 ）直接被存放在老年代中，原因是（为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率）\n* 长期存活的对象进入老年代\n每次进行垃圾回收存活下来的对象年龄都会加一岁，等达到一定程度后该对象就会进行老年代。具体设置年龄阈值，通过参数 -XX:MaxTenuringThreshold 来设置。\n* 动态对象年龄判定\n有一种情况当相同年龄的对象总和大于Survivor 空间的一半时，年龄大于或等于该值的对象直接进入老年代\n# 6. 垃圾回收算法有哪些？优缺点？\n* 标记 - 清除算法\n标记需要回收的对象，标记完成后在垃圾回收器统一收集那些被标记的对象。\n缺点：\n  * 效率不高：标记和清除过程效率不高，主要原因是标记的对象分布不均匀\n  * 空间问题：清除后产生大量内存碎片，导致以后程序不能给大对象分配连续的内存空间\n* 复制算法\n将内存分成两块容量大小相同区域，当一块区域内存用完后，经过GC之后幸存的对象将复制到另外一个区域中，剩余的内存空间一次清除即可，不管什么时刻总有一块区域是空闲的。\n\t* 效率高：每次只需要回收复制后剩余的内存，这样也不会产生内存碎片的问题，移动对顶指针，按顺序分配内存即可，实现简单，运行高效，但是如果存活率较高的情况，复制算法的效率也会随着下降\n\t* 成本高：时刻保证有一块区域是空闲的，这样导致新生代有10%的内存是浪费的。由于 Eden : from : to = 8:1:1\n\t![在这里插入图片描述](https://img.mupaie.com/20190307141705245.png)\n* 标记-整理算法\n跟上述说的标记-清除算法很类似，但是后续步骤不是对可回收的对象直接回收，而是让这一部分标记的对象都向一端移动，最终清除靠近端边的内存，这样好处减少内存碎片的产生。\n缺点：实现起来复杂，执行步骤较多\n![在这里插入图片描述](https://img.mupaie.com/20190307142226586.png)\n* 分代收集算法\n目前很多虚拟机的垃圾回收器都采用分代收集算法，主要原因分代回收能根据对象的生存周期进行内存划分，主要分新生代和老年代并根据每个年代的特点采用不同的回收算法，使内存回收更加高效。由于新生代，每次垃圾回收都有大片对象死亡，只有少数对象存活这样我们使用复制算法。老年代每次垃圾回收只有少量对象死亡，整体存活率较高，没有额外的内存对它进行分配，所以采用标记-整理算法或标记-清除算法\n# 7.垃圾回收器有哪些？\n* Serial 收集器\n单线程进行垃圾回收工作，在收集过程中，必须停止其他所有的工作线程，直到回收结束其他工作线程才能继续工作。\n算法：复制算法\n* ParNew 收集器\n对上述收集器进行补充，采用多线程对垃圾进行回收，这样相比单线程整体的效率得到提高。\n算法：复制算法\n* Parallel Scavenge 收集器\n和上述收集器不同的是，Parallel Scavenge 关注点主要是达到一个可控制的吞吐量。所谓的吞吐量就是CPU 用于运行代码的时间与CPU总消耗时间的比值，吞吐量 = 运行代码的时间/(运行代码的时间 +垃圾回收的时间)，吞吐量越高，则相对的垃圾回收时间降低。那平时我们如何控制吞吐量呢，Parallel Scavenge给了我们两个参数来控制吞吐量 最大垃圾收集停顿时间 -XX：MaxGCPauseMillis 和 设置吞吐量大小 -XX:GCTimeRatio 参数，具体参考 [深入理解Java虚拟器]()\n算法：复制算法\n* Serial old 收集器\n主要用于老年代的垃圾回收，采用单线程进行垃圾回收。\n算法：标记-整理\n* Parallel old 收集器\n主要用于老年代的垃圾回收，采用多线程进行垃圾回收。和 Parallel Scavenge 收集器一样， Parallel old 关注点也是吞吐量\n算法：标记-整理\n* cms 收集器\nCMS 收集器是一种以获取最短回收停顿时间为目标的收集器，基于标记-清除算法实现，具体包括四个步骤：\n\t* 初始化标记\n\t* 并发标记\n\t* 重新标记\n\t* 并发清除\n整体执行过程如下图所示：\n![在这里插入图片描述](https://img.mupaie.com/20190307151001702.png)\n从上图可以看出，除了初始标记和重新标记需要“Stop The World”,其余都是可以和用户线程一起执行的。\n缺点：\n   * 对CPU 资源非常敏感\n   * 无法处理浮动垃圾，由于清除过程伴随着用户线程，用户线程产生的新垃圾在标记过后，CMS 无法在当次收集中处理它们，留给下次GC再进行处理，这部分垃圾就叫做浮动垃圾\n   * 由于采用 标记-清除算法会产生大量内存碎片\n* G1 收集器\nG1 是当今收集器技术中的最前沿技术，相比其他收集器它具有几个特点：\n\t* 并行与并发\n\t* 分代收集\n\t* 空间整理\n\t* 可预测的停顿\n\n算法：复制算法和标记-整理算法\n\n\n参考文档\n\t[深入理解Java虚拟器]()\n\t[Java面试通关手册](https://github.com/Snailclimb/JavaGuide/blob/master/Java%E7%9B%B8%E5%85%B3/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88jvm%EF%BC%89.md)\n\n","slug":"jvm-面试问题总结-一","published":1,"updated":"2019-07-14T04:16:44.345Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8mkctuy00184osxij0d9u1v","content":"<h1 id=\"1-java-8-将-jvm-中-永久代去除带来的好处？\"><a href=\"#1-java-8-将-jvm-中-永久代去除带来的好处？\" class=\"headerlink\" title=\"1.java 8 将 jvm 中 永久代去除带来的好处？\"></a>1.java 8 将 jvm 中 永久代去除带来的好处？</h1><ul>\n<li>元空间存放在本地内存中避免之前使用永久代出现内存溢出的问题。</li>\n<li>类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。</li>\n<li>永久代会通过 full GC 进行回收，这种操作复杂度较高，回收效率偏低。<h1 id=\"2-如何判断对象死亡，有哪两种方法？\"><a href=\"#2-如何判断对象死亡，有哪两种方法？\" class=\"headerlink\" title=\"2.如何判断对象死亡，有哪两种方法？\"></a>2.如何判断对象死亡，有哪两种方法？</h1></li>\n</ul>\n<ol>\n<li>引用计数法：<br>当该对象被引用时，计数器就加1；当引用失效，计数器就减1；任何时候计数器为0的对象就是不可能再被使用的。<br>缺点：这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。 所谓对象之间的相互引用问题，如下面代码所示：除了对象objA 和 objB 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为0，于是引用计数算法无法通知 GC 回收器回收他们。</li>\n<li>可达性分析算法：<br>通过一系列“GC Roots” 的对象为起点，从这些节点开始向下搜索，搜索多走过的路径称为引用链，当对象到GC Roots没有任何的引用链相连就判断该对象已经失效。<h1 id=\"3-再谈引用：\"><a href=\"#3-再谈引用：\" class=\"headerlink\" title=\"3.再谈引用：\"></a>3.再谈引用：</h1></li>\n<li>强引用<ul>\n<li>概述：强引用在代码中很普遍，平时我们通过new 关键字创建的引用都是强引用，只要强引用存在，垃圾收集器就不会回收引用对象强引用在代码中很普遍，平时我们通过new 关键字创建的引用都是强引用，只要强引用存在，垃圾收集器就不会回收引用对象</li>\n<li>实现：通过new 关键字创建的引用</li>\n</ul>\n</li>\n<li>软引用<ul>\n<li>概述：描述一些还有用但是并不必需的对象，如果内存空间足够，垃圾回收器就不会回收它，如果发生内存溢出之前，垃圾回收器将这些对象列进回收范围之中进行第二次回收。如果这次回收还是没有足够的内存，就会发生内存溢出。</li>\n<li>用途：软引用可用来实现内存敏感的高速缓存。</li>\n<li>实现：Jdk 提供 SoftReference 类来实现软引用。</li>\n</ul>\n</li>\n<li>弱引用<ul>\n<li>概述：非必要对象，当GC发生就会被回收，生命周期很短暂</li>\n<li>实现：Jdk 提供 WeakReference 类来实现弱引用。<br><strong>注意：由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象</strong></li>\n</ul>\n</li>\n<li>虚引用<ul>\n<li>概述：与其他几种引用都不同，虚引用完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。</li>\n<li>用途：使对象被收集器回收时收到一个系统通知。</li>\n<li>实现：Jdk 提供 PhantomkReference 类来实现虚引用。</li>\n</ul>\n</li>\n<li>弱引用和软引用的区别<br>只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收掉只被弱引用关联的对象。<h1 id=\"4-HotSpot为什么要分为新生代和老年代？\"><a href=\"#4-HotSpot为什么要分为新生代和老年代？\" class=\"headerlink\" title=\"4.HotSpot为什么要分为新生代和老年代？\"></a>4.HotSpot为什么要分为新生代和老年代？</h1>一般将java堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</li>\n</ol>\n<ul>\n<li>新生代：每次收集都会有大量对象死去，所以可以选择复制算法</li>\n<li>老年代：对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集<h1 id=\"5-Minor-GC和Full-GC-分别指什么？\"><a href=\"#5-Minor-GC和Full-GC-分别指什么？\" class=\"headerlink\" title=\"5.Minor GC和Full GC 分别指什么？\"></a>5.Minor GC和Full GC 分别指什么？</h1></li>\n<li>新生代（Minor GC）:指新生代的垃圾收集，执行操作频繁，回收速度较快。</li>\n<li>老年代（Major GC/Full GC）:指发生老年代的垃圾回收，出现Major GC经常会伴随一次Minor GC （并非绝对，只有当发生Major GC时 晋升到老年代的内存 大于老年代的剩余内存，这种情况下 会发生Full GC），Major GC的速度一般会比Minor GC的慢10倍以上。<br>默认情况下 新生代和老年代的堆空间的分布情况<br><img src=\"https://img.mupaie.com/20190228151004551.png\" alt=\"在这里插入图片描述\"><br>注意：虚拟机每次只会使用 Eden 和其中的一块 Survivor 区域来为对象服务，所以无论什么时候，总是有一块 Survivor 区域是空闲着的。 因此，新生代实际可用的内存空间为90%的新生代空间。<br>大数据（数组和字符串【字符数组】 ）直接被存放在老年代中，原因是（为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率）</li>\n<li>长期存活的对象进入老年代<br>每次进行垃圾回收存活下来的对象年龄都会加一岁，等达到一定程度后该对象就会进行老年代。具体设置年龄阈值，通过参数 -XX:MaxTenuringThreshold 来设置。</li>\n<li>动态对象年龄判定<br>有一种情况当相同年龄的对象总和大于Survivor 空间的一半时，年龄大于或等于该值的对象直接进入老年代<h1 id=\"6-垃圾回收算法有哪些？优缺点？\"><a href=\"#6-垃圾回收算法有哪些？优缺点？\" class=\"headerlink\" title=\"6. 垃圾回收算法有哪些？优缺点？\"></a>6. 垃圾回收算法有哪些？优缺点？</h1></li>\n<li>标记 - 清除算法<br>标记需要回收的对象，标记完成后在垃圾回收器统一收集那些被标记的对象。<br>缺点：<ul>\n<li>效率不高：标记和清除过程效率不高，主要原因是标记的对象分布不均匀</li>\n<li>空间问题：清除后产生大量内存碎片，导致以后程序不能给大对象分配连续的内存空间</li>\n</ul>\n</li>\n<li>复制算法<br>将内存分成两块容量大小相同区域，当一块区域内存用完后，经过GC之后幸存的对象将复制到另外一个区域中，剩余的内存空间一次清除即可，不管什么时刻总有一块区域是空闲的。<ul>\n<li>效率高：每次只需要回收复制后剩余的内存，这样也不会产生内存碎片的问题，移动对顶指针，按顺序分配内存即可，实现简单，运行高效，但是如果存活率较高的情况，复制算法的效率也会随着下降</li>\n<li>成本高：时刻保证有一块区域是空闲的，这样导致新生代有10%的内存是浪费的。由于 Eden : from : to = 8:1:1<br><img src=\"https://img.mupaie.com/20190307141705245.png\" alt=\"在这里插入图片描述\"></li>\n</ul>\n</li>\n<li>标记-整理算法<br>跟上述说的标记-清除算法很类似，但是后续步骤不是对可回收的对象直接回收，而是让这一部分标记的对象都向一端移动，最终清除靠近端边的内存，这样好处减少内存碎片的产生。<br>缺点：实现起来复杂，执行步骤较多<br><img src=\"https://img.mupaie.com/20190307142226586.png\" alt=\"在这里插入图片描述\"></li>\n<li>分代收集算法<br>目前很多虚拟机的垃圾回收器都采用分代收集算法，主要原因分代回收能根据对象的生存周期进行内存划分，主要分新生代和老年代并根据每个年代的特点采用不同的回收算法，使内存回收更加高效。由于新生代，每次垃圾回收都有大片对象死亡，只有少数对象存活这样我们使用复制算法。老年代每次垃圾回收只有少量对象死亡，整体存活率较高，没有额外的内存对它进行分配，所以采用标记-整理算法或标记-清除算法<h1 id=\"7-垃圾回收器有哪些？\"><a href=\"#7-垃圾回收器有哪些？\" class=\"headerlink\" title=\"7.垃圾回收器有哪些？\"></a>7.垃圾回收器有哪些？</h1></li>\n<li>Serial 收集器<br>单线程进行垃圾回收工作，在收集过程中，必须停止其他所有的工作线程，直到回收结束其他工作线程才能继续工作。<br>算法：复制算法</li>\n<li>ParNew 收集器<br>对上述收集器进行补充，采用多线程对垃圾进行回收，这样相比单线程整体的效率得到提高。<br>算法：复制算法</li>\n<li>Parallel Scavenge 收集器<br>和上述收集器不同的是，Parallel Scavenge 关注点主要是达到一个可控制的吞吐量。所谓的吞吐量就是CPU 用于运行代码的时间与CPU总消耗时间的比值，吞吐量 = 运行代码的时间/(运行代码的时间 +垃圾回收的时间)，吞吐量越高，则相对的垃圾回收时间降低。那平时我们如何控制吞吐量呢，Parallel Scavenge给了我们两个参数来控制吞吐量 最大垃圾收集停顿时间 -XX：MaxGCPauseMillis 和 设置吞吐量大小 -XX:GCTimeRatio 参数，具体参考 <a href=\"\">深入理解Java虚拟器</a><br>算法：复制算法</li>\n<li>Serial old 收集器<br>主要用于老年代的垃圾回收，采用单线程进行垃圾回收。<br>算法：标记-整理</li>\n<li>Parallel old 收集器<br>主要用于老年代的垃圾回收，采用多线程进行垃圾回收。和 Parallel Scavenge 收集器一样， Parallel old 关注点也是吞吐量<br>算法：标记-整理</li>\n<li>cms 收集器<br>CMS 收集器是一种以获取最短回收停顿时间为目标的收集器，基于标记-清除算法实现，具体包括四个步骤：<ul>\n<li>初始化标记</li>\n<li>并发标记</li>\n<li>重新标记</li>\n<li>并发清除<br>整体执行过程如下图所示：<br><img src=\"https://img.mupaie.com/20190307151001702.png\" alt=\"在这里插入图片描述\"><br>从上图可以看出，除了初始标记和重新标记需要“Stop The World”,其余都是可以和用户线程一起执行的。<br>缺点：<ul>\n<li>对CPU 资源非常敏感</li>\n<li>无法处理浮动垃圾，由于清除过程伴随着用户线程，用户线程产生的新垃圾在标记过后，CMS 无法在当次收集中处理它们，留给下次GC再进行处理，这部分垃圾就叫做浮动垃圾</li>\n<li>由于采用 标记-清除算法会产生大量内存碎片</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>G1 收集器<br>G1 是当今收集器技术中的最前沿技术，相比其他收集器它具有几个特点：<ul>\n<li>并行与并发</li>\n<li>分代收集</li>\n<li>空间整理</li>\n<li>可预测的停顿</li>\n</ul>\n</li>\n</ul>\n<p>算法：复制算法和标记-整理算法</p>\n<p>参考文档<br>    <a href=\"\">深入理解Java虚拟器</a><br>    <a href=\"https://github.com/Snailclimb/JavaGuide/blob/master/Java%E7%9B%B8%E5%85%B3/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88jvm%EF%BC%89.md\" target=\"_blank\" rel=\"noopener\">Java面试通关手册</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-java-8-将-jvm-中-永久代去除带来的好处？\"><a href=\"#1-java-8-将-jvm-中-永久代去除带来的好处？\" class=\"headerlink\" title=\"1.java 8 将 jvm 中 永久代去除带来的好处？\"></a>1.java 8 将 jvm 中 永久代去除带来的好处？</h1><ul>\n<li>元空间存放在本地内存中避免之前使用永久代出现内存溢出的问题。</li>\n<li>类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。</li>\n<li>永久代会通过 full GC 进行回收，这种操作复杂度较高，回收效率偏低。<h1 id=\"2-如何判断对象死亡，有哪两种方法？\"><a href=\"#2-如何判断对象死亡，有哪两种方法？\" class=\"headerlink\" title=\"2.如何判断对象死亡，有哪两种方法？\"></a>2.如何判断对象死亡，有哪两种方法？</h1></li>\n</ul>\n<ol>\n<li>引用计数法：<br>当该对象被引用时，计数器就加1；当引用失效，计数器就减1；任何时候计数器为0的对象就是不可能再被使用的。<br>缺点：这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。 所谓对象之间的相互引用问题，如下面代码所示：除了对象objA 和 objB 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为0，于是引用计数算法无法通知 GC 回收器回收他们。</li>\n<li>可达性分析算法：<br>通过一系列“GC Roots” 的对象为起点，从这些节点开始向下搜索，搜索多走过的路径称为引用链，当对象到GC Roots没有任何的引用链相连就判断该对象已经失效。<h1 id=\"3-再谈引用：\"><a href=\"#3-再谈引用：\" class=\"headerlink\" title=\"3.再谈引用：\"></a>3.再谈引用：</h1></li>\n<li>强引用<ul>\n<li>概述：强引用在代码中很普遍，平时我们通过new 关键字创建的引用都是强引用，只要强引用存在，垃圾收集器就不会回收引用对象强引用在代码中很普遍，平时我们通过new 关键字创建的引用都是强引用，只要强引用存在，垃圾收集器就不会回收引用对象</li>\n<li>实现：通过new 关键字创建的引用</li>\n</ul>\n</li>\n<li>软引用<ul>\n<li>概述：描述一些还有用但是并不必需的对象，如果内存空间足够，垃圾回收器就不会回收它，如果发生内存溢出之前，垃圾回收器将这些对象列进回收范围之中进行第二次回收。如果这次回收还是没有足够的内存，就会发生内存溢出。</li>\n<li>用途：软引用可用来实现内存敏感的高速缓存。</li>\n<li>实现：Jdk 提供 SoftReference 类来实现软引用。</li>\n</ul>\n</li>\n<li>弱引用<ul>\n<li>概述：非必要对象，当GC发生就会被回收，生命周期很短暂</li>\n<li>实现：Jdk 提供 WeakReference 类来实现弱引用。<br><strong>注意：由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象</strong></li>\n</ul>\n</li>\n<li>虚引用<ul>\n<li>概述：与其他几种引用都不同，虚引用完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。</li>\n<li>用途：使对象被收集器回收时收到一个系统通知。</li>\n<li>实现：Jdk 提供 PhantomkReference 类来实现虚引用。</li>\n</ul>\n</li>\n<li>弱引用和软引用的区别<br>只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收掉只被弱引用关联的对象。<h1 id=\"4-HotSpot为什么要分为新生代和老年代？\"><a href=\"#4-HotSpot为什么要分为新生代和老年代？\" class=\"headerlink\" title=\"4.HotSpot为什么要分为新生代和老年代？\"></a>4.HotSpot为什么要分为新生代和老年代？</h1>一般将java堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</li>\n</ol>\n<ul>\n<li>新生代：每次收集都会有大量对象死去，所以可以选择复制算法</li>\n<li>老年代：对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集<h1 id=\"5-Minor-GC和Full-GC-分别指什么？\"><a href=\"#5-Minor-GC和Full-GC-分别指什么？\" class=\"headerlink\" title=\"5.Minor GC和Full GC 分别指什么？\"></a>5.Minor GC和Full GC 分别指什么？</h1></li>\n<li>新生代（Minor GC）:指新生代的垃圾收集，执行操作频繁，回收速度较快。</li>\n<li>老年代（Major GC/Full GC）:指发生老年代的垃圾回收，出现Major GC经常会伴随一次Minor GC （并非绝对，只有当发生Major GC时 晋升到老年代的内存 大于老年代的剩余内存，这种情况下 会发生Full GC），Major GC的速度一般会比Minor GC的慢10倍以上。<br>默认情况下 新生代和老年代的堆空间的分布情况<br><img src=\"https://img.mupaie.com/20190228151004551.png\" alt=\"在这里插入图片描述\"><br>注意：虚拟机每次只会使用 Eden 和其中的一块 Survivor 区域来为对象服务，所以无论什么时候，总是有一块 Survivor 区域是空闲着的。 因此，新生代实际可用的内存空间为90%的新生代空间。<br>大数据（数组和字符串【字符数组】 ）直接被存放在老年代中，原因是（为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率）</li>\n<li>长期存活的对象进入老年代<br>每次进行垃圾回收存活下来的对象年龄都会加一岁，等达到一定程度后该对象就会进行老年代。具体设置年龄阈值，通过参数 -XX:MaxTenuringThreshold 来设置。</li>\n<li>动态对象年龄判定<br>有一种情况当相同年龄的对象总和大于Survivor 空间的一半时，年龄大于或等于该值的对象直接进入老年代<h1 id=\"6-垃圾回收算法有哪些？优缺点？\"><a href=\"#6-垃圾回收算法有哪些？优缺点？\" class=\"headerlink\" title=\"6. 垃圾回收算法有哪些？优缺点？\"></a>6. 垃圾回收算法有哪些？优缺点？</h1></li>\n<li>标记 - 清除算法<br>标记需要回收的对象，标记完成后在垃圾回收器统一收集那些被标记的对象。<br>缺点：<ul>\n<li>效率不高：标记和清除过程效率不高，主要原因是标记的对象分布不均匀</li>\n<li>空间问题：清除后产生大量内存碎片，导致以后程序不能给大对象分配连续的内存空间</li>\n</ul>\n</li>\n<li>复制算法<br>将内存分成两块容量大小相同区域，当一块区域内存用完后，经过GC之后幸存的对象将复制到另外一个区域中，剩余的内存空间一次清除即可，不管什么时刻总有一块区域是空闲的。<ul>\n<li>效率高：每次只需要回收复制后剩余的内存，这样也不会产生内存碎片的问题，移动对顶指针，按顺序分配内存即可，实现简单，运行高效，但是如果存活率较高的情况，复制算法的效率也会随着下降</li>\n<li>成本高：时刻保证有一块区域是空闲的，这样导致新生代有10%的内存是浪费的。由于 Eden : from : to = 8:1:1<br><img src=\"https://img.mupaie.com/20190307141705245.png\" alt=\"在这里插入图片描述\"></li>\n</ul>\n</li>\n<li>标记-整理算法<br>跟上述说的标记-清除算法很类似，但是后续步骤不是对可回收的对象直接回收，而是让这一部分标记的对象都向一端移动，最终清除靠近端边的内存，这样好处减少内存碎片的产生。<br>缺点：实现起来复杂，执行步骤较多<br><img src=\"https://img.mupaie.com/20190307142226586.png\" alt=\"在这里插入图片描述\"></li>\n<li>分代收集算法<br>目前很多虚拟机的垃圾回收器都采用分代收集算法，主要原因分代回收能根据对象的生存周期进行内存划分，主要分新生代和老年代并根据每个年代的特点采用不同的回收算法，使内存回收更加高效。由于新生代，每次垃圾回收都有大片对象死亡，只有少数对象存活这样我们使用复制算法。老年代每次垃圾回收只有少量对象死亡，整体存活率较高，没有额外的内存对它进行分配，所以采用标记-整理算法或标记-清除算法<h1 id=\"7-垃圾回收器有哪些？\"><a href=\"#7-垃圾回收器有哪些？\" class=\"headerlink\" title=\"7.垃圾回收器有哪些？\"></a>7.垃圾回收器有哪些？</h1></li>\n<li>Serial 收集器<br>单线程进行垃圾回收工作，在收集过程中，必须停止其他所有的工作线程，直到回收结束其他工作线程才能继续工作。<br>算法：复制算法</li>\n<li>ParNew 收集器<br>对上述收集器进行补充，采用多线程对垃圾进行回收，这样相比单线程整体的效率得到提高。<br>算法：复制算法</li>\n<li>Parallel Scavenge 收集器<br>和上述收集器不同的是，Parallel Scavenge 关注点主要是达到一个可控制的吞吐量。所谓的吞吐量就是CPU 用于运行代码的时间与CPU总消耗时间的比值，吞吐量 = 运行代码的时间/(运行代码的时间 +垃圾回收的时间)，吞吐量越高，则相对的垃圾回收时间降低。那平时我们如何控制吞吐量呢，Parallel Scavenge给了我们两个参数来控制吞吐量 最大垃圾收集停顿时间 -XX：MaxGCPauseMillis 和 设置吞吐量大小 -XX:GCTimeRatio 参数，具体参考 <a href=\"\">深入理解Java虚拟器</a><br>算法：复制算法</li>\n<li>Serial old 收集器<br>主要用于老年代的垃圾回收，采用单线程进行垃圾回收。<br>算法：标记-整理</li>\n<li>Parallel old 收集器<br>主要用于老年代的垃圾回收，采用多线程进行垃圾回收。和 Parallel Scavenge 收集器一样， Parallel old 关注点也是吞吐量<br>算法：标记-整理</li>\n<li>cms 收集器<br>CMS 收集器是一种以获取最短回收停顿时间为目标的收集器，基于标记-清除算法实现，具体包括四个步骤：<ul>\n<li>初始化标记</li>\n<li>并发标记</li>\n<li>重新标记</li>\n<li>并发清除<br>整体执行过程如下图所示：<br><img src=\"https://img.mupaie.com/20190307151001702.png\" alt=\"在这里插入图片描述\"><br>从上图可以看出，除了初始标记和重新标记需要“Stop The World”,其余都是可以和用户线程一起执行的。<br>缺点：<ul>\n<li>对CPU 资源非常敏感</li>\n<li>无法处理浮动垃圾，由于清除过程伴随着用户线程，用户线程产生的新垃圾在标记过后，CMS 无法在当次收集中处理它们，留给下次GC再进行处理，这部分垃圾就叫做浮动垃圾</li>\n<li>由于采用 标记-清除算法会产生大量内存碎片</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>G1 收集器<br>G1 是当今收集器技术中的最前沿技术，相比其他收集器它具有几个特点：<ul>\n<li>并行与并发</li>\n<li>分代收集</li>\n<li>空间整理</li>\n<li>可预测的停顿</li>\n</ul>\n</li>\n</ul>\n<p>算法：复制算法和标记-整理算法</p>\n<p>参考文档<br>    <a href=\"\">深入理解Java虚拟器</a><br>    <a href=\"https://github.com/Snailclimb/JavaGuide/blob/master/Java%E7%9B%B8%E5%85%B3/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88jvm%EF%BC%89.md\" target=\"_blank\" rel=\"noopener\">Java面试通关手册</a></p>\n"},{"title":"理解 linux cpu 负载","date":"2019-03-15T01:55:24.000Z","_content":"# 1. 如何查看cpu负载？通过什么命令\n当你的电脑运行缓慢，操作起来很卡的时候，这时你应该查看一下你的cpu是不是处于负载状态下。下面我们通过命令 top 或 uptime 查看平均负载，如下：\n![在这里插入图片描述](https://img.mupaie.com/20190228111519685.png)\n三个参数分别表示 一分钟，5分钟，15分钟 占的cpu比例，越低表示cpu处于比较空闲的阶段，但是越大则会出现cpu过载的问题。\n# 2. 了解负载参数的意义？\n在单个cpu下，由于只有一个cpu，所以所有操作都经过它来完成，我们举个例子来形象的阐述这个过程：\n我们把cpu比作一条桥，操作进程比作车。因为只有一个cpu，所以车辆都必须从这个车道通过，\n\n系统负载为0的时候，表示没有车经过\n![在这里插入图片描述](https://img.mupaie.com/20190416130016.png)\n负载为0.5的时候，表示大桥有一半的路段有车辆\n![在这里插入图片描述](https://img.mupaie.com/20190228112700968.png)\n负载为1.0，意味着大桥的所有路段都有车，也就是说大桥已经\"满\"了。但是必须注意的是，直到此时大桥还是能顺畅通行的。\n![在这里插入图片描述](https://img.mupaie.com/20190228112715668.png)\n负载大于1，就表示大桥已经处于拥挤状态，后面的车必须处于等待中，等前面的车辆通过大桥后，后面排队的车辆才能依次通过。\n\n通过桥和车辆的例子，我们能很好的理解，如果你想车辆或者你的进程不需要等待，你就需要让你的cpu 负载 低于 1。当大于或等于 1的时候你就需要考虑如何降低负载。\n\n# 3. 多个cpu或者多核cpu 负载值的变化？\n上述我们讲的都是单cpu或者单核cpu的情况，那么多核或者多个cpu的情况下，负载是怎么变化的呢？\n 我们继续用之前桥的例子，单个cpu表示桥上只有一条道，那多个/多核 cpu 表示 桥上有多条道，这样桥上的整体容量是不是增加了n倍？\n![在这里插入图片描述](https://img.mupaie.com/20190228114606538.png)\n所以，2个CPU表明系统负荷可以达到2.0，此时每个CPU都达到100%的工作量。推广开来，n个CPU的电脑，可接受的系统负荷最大为n.0。\n\n# 4. 观察cpu负载每个时间的变化情况，判断运行状态？\n通过 top 命令显示了 \"load average\" 的三个平均值分别是1分钟、5分钟，15分钟的系统负载，那么问题来了，我们应该参考一分钟，五分钟，还是十五分钟？\n如果只有1分钟的系统负荷大于1.0，其他两个时间段都小于1.0，这表明只是暂时现象，问题不大。\n如果15分钟内，平均系统负荷大于1.0（调整CPU核心数之后），表明问题持续存在，不是暂时现象。所以，你应该主要观察\"15分钟系统负荷\"，将它作为电脑正常运行的指标。\n\n# 5. 查看系统的cpu核数\n通过 cat /proc/cpuinfo 能获取系统中每个处理器的信息，如果你想知道cpu核心数量，通过 grep -c 'model name' /proc/cpuinfo\n\n参考文档：\n[理解Linux系统负荷](http://www.ruanyifeng.com/blog/2011/07/linux_load_average_explained.html)\n[Understanding Linux CPU Load](https://scoutapp.com/blog/understanding-load-averages)\n\n","source":"_posts/理解-linux-cpu-负载.md","raw":"---\ntitle: 理解 linux cpu 负载\ndate: 2019-03-15 09:55:24\ntags:\n- linux\n---\n# 1. 如何查看cpu负载？通过什么命令\n当你的电脑运行缓慢，操作起来很卡的时候，这时你应该查看一下你的cpu是不是处于负载状态下。下面我们通过命令 top 或 uptime 查看平均负载，如下：\n![在这里插入图片描述](https://img.mupaie.com/20190228111519685.png)\n三个参数分别表示 一分钟，5分钟，15分钟 占的cpu比例，越低表示cpu处于比较空闲的阶段，但是越大则会出现cpu过载的问题。\n# 2. 了解负载参数的意义？\n在单个cpu下，由于只有一个cpu，所以所有操作都经过它来完成，我们举个例子来形象的阐述这个过程：\n我们把cpu比作一条桥，操作进程比作车。因为只有一个cpu，所以车辆都必须从这个车道通过，\n\n系统负载为0的时候，表示没有车经过\n![在这里插入图片描述](https://img.mupaie.com/20190416130016.png)\n负载为0.5的时候，表示大桥有一半的路段有车辆\n![在这里插入图片描述](https://img.mupaie.com/20190228112700968.png)\n负载为1.0，意味着大桥的所有路段都有车，也就是说大桥已经\"满\"了。但是必须注意的是，直到此时大桥还是能顺畅通行的。\n![在这里插入图片描述](https://img.mupaie.com/20190228112715668.png)\n负载大于1，就表示大桥已经处于拥挤状态，后面的车必须处于等待中，等前面的车辆通过大桥后，后面排队的车辆才能依次通过。\n\n通过桥和车辆的例子，我们能很好的理解，如果你想车辆或者你的进程不需要等待，你就需要让你的cpu 负载 低于 1。当大于或等于 1的时候你就需要考虑如何降低负载。\n\n# 3. 多个cpu或者多核cpu 负载值的变化？\n上述我们讲的都是单cpu或者单核cpu的情况，那么多核或者多个cpu的情况下，负载是怎么变化的呢？\n 我们继续用之前桥的例子，单个cpu表示桥上只有一条道，那多个/多核 cpu 表示 桥上有多条道，这样桥上的整体容量是不是增加了n倍？\n![在这里插入图片描述](https://img.mupaie.com/20190228114606538.png)\n所以，2个CPU表明系统负荷可以达到2.0，此时每个CPU都达到100%的工作量。推广开来，n个CPU的电脑，可接受的系统负荷最大为n.0。\n\n# 4. 观察cpu负载每个时间的变化情况，判断运行状态？\n通过 top 命令显示了 \"load average\" 的三个平均值分别是1分钟、5分钟，15分钟的系统负载，那么问题来了，我们应该参考一分钟，五分钟，还是十五分钟？\n如果只有1分钟的系统负荷大于1.0，其他两个时间段都小于1.0，这表明只是暂时现象，问题不大。\n如果15分钟内，平均系统负荷大于1.0（调整CPU核心数之后），表明问题持续存在，不是暂时现象。所以，你应该主要观察\"15分钟系统负荷\"，将它作为电脑正常运行的指标。\n\n# 5. 查看系统的cpu核数\n通过 cat /proc/cpuinfo 能获取系统中每个处理器的信息，如果你想知道cpu核心数量，通过 grep -c 'model name' /proc/cpuinfo\n\n参考文档：\n[理解Linux系统负荷](http://www.ruanyifeng.com/blog/2011/07/linux_load_average_explained.html)\n[Understanding Linux CPU Load](https://scoutapp.com/blog/understanding-load-averages)\n\n","slug":"理解-linux-cpu-负载","published":1,"updated":"2019-07-14T04:16:44.438Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8mkctuz001a4osx6gqifuid","content":"<h1 id=\"1-如何查看cpu负载？通过什么命令\"><a href=\"#1-如何查看cpu负载？通过什么命令\" class=\"headerlink\" title=\"1. 如何查看cpu负载？通过什么命令\"></a>1. 如何查看cpu负载？通过什么命令</h1><p>当你的电脑运行缓慢，操作起来很卡的时候，这时你应该查看一下你的cpu是不是处于负载状态下。下面我们通过命令 top 或 uptime 查看平均负载，如下：<br><img src=\"https://img.mupaie.com/20190228111519685.png\" alt=\"在这里插入图片描述\"><br>三个参数分别表示 一分钟，5分钟，15分钟 占的cpu比例，越低表示cpu处于比较空闲的阶段，但是越大则会出现cpu过载的问题。</p>\n<h1 id=\"2-了解负载参数的意义？\"><a href=\"#2-了解负载参数的意义？\" class=\"headerlink\" title=\"2. 了解负载参数的意义？\"></a>2. 了解负载参数的意义？</h1><p>在单个cpu下，由于只有一个cpu，所以所有操作都经过它来完成，我们举个例子来形象的阐述这个过程：<br>我们把cpu比作一条桥，操作进程比作车。因为只有一个cpu，所以车辆都必须从这个车道通过，</p>\n<p>系统负载为0的时候，表示没有车经过<br><img src=\"https://img.mupaie.com/20190416130016.png\" alt=\"在这里插入图片描述\"><br>负载为0.5的时候，表示大桥有一半的路段有车辆<br><img src=\"https://img.mupaie.com/20190228112700968.png\" alt=\"在这里插入图片描述\"><br>负载为1.0，意味着大桥的所有路段都有车，也就是说大桥已经”满”了。但是必须注意的是，直到此时大桥还是能顺畅通行的。<br><img src=\"https://img.mupaie.com/20190228112715668.png\" alt=\"在这里插入图片描述\"><br>负载大于1，就表示大桥已经处于拥挤状态，后面的车必须处于等待中，等前面的车辆通过大桥后，后面排队的车辆才能依次通过。</p>\n<p>通过桥和车辆的例子，我们能很好的理解，如果你想车辆或者你的进程不需要等待，你就需要让你的cpu 负载 低于 1。当大于或等于 1的时候你就需要考虑如何降低负载。</p>\n<h1 id=\"3-多个cpu或者多核cpu-负载值的变化？\"><a href=\"#3-多个cpu或者多核cpu-负载值的变化？\" class=\"headerlink\" title=\"3. 多个cpu或者多核cpu 负载值的变化？\"></a>3. 多个cpu或者多核cpu 负载值的变化？</h1><p>上述我们讲的都是单cpu或者单核cpu的情况，那么多核或者多个cpu的情况下，负载是怎么变化的呢？<br> 我们继续用之前桥的例子，单个cpu表示桥上只有一条道，那多个/多核 cpu 表示 桥上有多条道，这样桥上的整体容量是不是增加了n倍？<br><img src=\"https://img.mupaie.com/20190228114606538.png\" alt=\"在这里插入图片描述\"><br>所以，2个CPU表明系统负荷可以达到2.0，此时每个CPU都达到100%的工作量。推广开来，n个CPU的电脑，可接受的系统负荷最大为n.0。</p>\n<h1 id=\"4-观察cpu负载每个时间的变化情况，判断运行状态？\"><a href=\"#4-观察cpu负载每个时间的变化情况，判断运行状态？\" class=\"headerlink\" title=\"4. 观察cpu负载每个时间的变化情况，判断运行状态？\"></a>4. 观察cpu负载每个时间的变化情况，判断运行状态？</h1><p>通过 top 命令显示了 “load average” 的三个平均值分别是1分钟、5分钟，15分钟的系统负载，那么问题来了，我们应该参考一分钟，五分钟，还是十五分钟？<br>如果只有1分钟的系统负荷大于1.0，其他两个时间段都小于1.0，这表明只是暂时现象，问题不大。<br>如果15分钟内，平均系统负荷大于1.0（调整CPU核心数之后），表明问题持续存在，不是暂时现象。所以，你应该主要观察”15分钟系统负荷”，将它作为电脑正常运行的指标。</p>\n<h1 id=\"5-查看系统的cpu核数\"><a href=\"#5-查看系统的cpu核数\" class=\"headerlink\" title=\"5. 查看系统的cpu核数\"></a>5. 查看系统的cpu核数</h1><p>通过 cat /proc/cpuinfo 能获取系统中每个处理器的信息，如果你想知道cpu核心数量，通过 grep -c ‘model name’ /proc/cpuinfo</p>\n<p>参考文档：<br><a href=\"http://www.ruanyifeng.com/blog/2011/07/linux_load_average_explained.html\" target=\"_blank\" rel=\"noopener\">理解Linux系统负荷</a><br><a href=\"https://scoutapp.com/blog/understanding-load-averages\" target=\"_blank\" rel=\"noopener\">Understanding Linux CPU Load</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-如何查看cpu负载？通过什么命令\"><a href=\"#1-如何查看cpu负载？通过什么命令\" class=\"headerlink\" title=\"1. 如何查看cpu负载？通过什么命令\"></a>1. 如何查看cpu负载？通过什么命令</h1><p>当你的电脑运行缓慢，操作起来很卡的时候，这时你应该查看一下你的cpu是不是处于负载状态下。下面我们通过命令 top 或 uptime 查看平均负载，如下：<br><img src=\"https://img.mupaie.com/20190228111519685.png\" alt=\"在这里插入图片描述\"><br>三个参数分别表示 一分钟，5分钟，15分钟 占的cpu比例，越低表示cpu处于比较空闲的阶段，但是越大则会出现cpu过载的问题。</p>\n<h1 id=\"2-了解负载参数的意义？\"><a href=\"#2-了解负载参数的意义？\" class=\"headerlink\" title=\"2. 了解负载参数的意义？\"></a>2. 了解负载参数的意义？</h1><p>在单个cpu下，由于只有一个cpu，所以所有操作都经过它来完成，我们举个例子来形象的阐述这个过程：<br>我们把cpu比作一条桥，操作进程比作车。因为只有一个cpu，所以车辆都必须从这个车道通过，</p>\n<p>系统负载为0的时候，表示没有车经过<br><img src=\"https://img.mupaie.com/20190416130016.png\" alt=\"在这里插入图片描述\"><br>负载为0.5的时候，表示大桥有一半的路段有车辆<br><img src=\"https://img.mupaie.com/20190228112700968.png\" alt=\"在这里插入图片描述\"><br>负载为1.0，意味着大桥的所有路段都有车，也就是说大桥已经”满”了。但是必须注意的是，直到此时大桥还是能顺畅通行的。<br><img src=\"https://img.mupaie.com/20190228112715668.png\" alt=\"在这里插入图片描述\"><br>负载大于1，就表示大桥已经处于拥挤状态，后面的车必须处于等待中，等前面的车辆通过大桥后，后面排队的车辆才能依次通过。</p>\n<p>通过桥和车辆的例子，我们能很好的理解，如果你想车辆或者你的进程不需要等待，你就需要让你的cpu 负载 低于 1。当大于或等于 1的时候你就需要考虑如何降低负载。</p>\n<h1 id=\"3-多个cpu或者多核cpu-负载值的变化？\"><a href=\"#3-多个cpu或者多核cpu-负载值的变化？\" class=\"headerlink\" title=\"3. 多个cpu或者多核cpu 负载值的变化？\"></a>3. 多个cpu或者多核cpu 负载值的变化？</h1><p>上述我们讲的都是单cpu或者单核cpu的情况，那么多核或者多个cpu的情况下，负载是怎么变化的呢？<br> 我们继续用之前桥的例子，单个cpu表示桥上只有一条道，那多个/多核 cpu 表示 桥上有多条道，这样桥上的整体容量是不是增加了n倍？<br><img src=\"https://img.mupaie.com/20190228114606538.png\" alt=\"在这里插入图片描述\"><br>所以，2个CPU表明系统负荷可以达到2.0，此时每个CPU都达到100%的工作量。推广开来，n个CPU的电脑，可接受的系统负荷最大为n.0。</p>\n<h1 id=\"4-观察cpu负载每个时间的变化情况，判断运行状态？\"><a href=\"#4-观察cpu负载每个时间的变化情况，判断运行状态？\" class=\"headerlink\" title=\"4. 观察cpu负载每个时间的变化情况，判断运行状态？\"></a>4. 观察cpu负载每个时间的变化情况，判断运行状态？</h1><p>通过 top 命令显示了 “load average” 的三个平均值分别是1分钟、5分钟，15分钟的系统负载，那么问题来了，我们应该参考一分钟，五分钟，还是十五分钟？<br>如果只有1分钟的系统负荷大于1.0，其他两个时间段都小于1.0，这表明只是暂时现象，问题不大。<br>如果15分钟内，平均系统负荷大于1.0（调整CPU核心数之后），表明问题持续存在，不是暂时现象。所以，你应该主要观察”15分钟系统负荷”，将它作为电脑正常运行的指标。</p>\n<h1 id=\"5-查看系统的cpu核数\"><a href=\"#5-查看系统的cpu核数\" class=\"headerlink\" title=\"5. 查看系统的cpu核数\"></a>5. 查看系统的cpu核数</h1><p>通过 cat /proc/cpuinfo 能获取系统中每个处理器的信息，如果你想知道cpu核心数量，通过 grep -c ‘model name’ /proc/cpuinfo</p>\n<p>参考文档：<br><a href=\"http://www.ruanyifeng.com/blog/2011/07/linux_load_average_explained.html\" target=\"_blank\" rel=\"noopener\">理解Linux系统负荷</a><br><a href=\"https://scoutapp.com/blog/understanding-load-averages\" target=\"_blank\" rel=\"noopener\">Understanding Linux CPU Load</a></p>\n"},{"title":"双通道存储器技术","date":"2019-02-26T01:52:53.000Z","_content":"&nbsp;&nbsp;&nbsp;&nbsp;听说内存开始降价了，充满好奇心的我就打开京东看了一下内存条的价格，本来只想买一条的我，下单前看到一个套装两条内存居然比单条的价格贵了这么多，带着好奇询问了商家，商家的解释是这样的：\n* 内存条套装不是促销方式，而是2条（双通道）、3条（三通道）或者4条（四通道）品牌、参数完全相同的（同一生产线、同一批次的产品）内存成套销售，兼容性是最出色的。而单条内存，在组建通道的时候，具有随意性，可能品牌、参数都有差异，兼容性当然没有套装好。\n带着这个解释去了解双通道存储器技术\n# 1. 什么是双通道存储器技术\n维基百科给出的解释是：双通道（英语：Dual-channel）是一种能够让计算机性能增加的技术，此种技术将多个存储器由串联方式改良为并联方式，以得到更大的带宽。最早使用此技术的记忆体是Rambus。\n# 2. 为啥使用双通道存储器技术？\n主要是cpu随着技术发展，对内存要求越来越高，单通道技术已经不能满足cpu的要求。比如cpu 等待时间，数据传输，处理等要求。\n# 3. 双通道存储器技术的优点？相比单通道技术\n* 使用单通道技术时，主板上多条存储器是以串联方式运作，也就是仅是当作一条存储器运作，只是容量会相加。存储器总线宽度为64-bit，无论安装几条存储器，带宽都固定为64-bit。\n* 双通道便是利用并联方式运作，当连接两条存储器时，总线宽度将会达到128-bit，而套上存储器宽度计算便会知道相差甚远。也就是开双通道后，带宽可以增至两倍，性能也会增加；至于能否提升至两倍速度，根据测试似乎是没办法，但是对于存储器性能的提升却是很大的帮助。\n理论上，双通道能提升存储器两倍的性能；对系统整体性能来说，打开双通道带来的性能提升约为2至3%，最好的情况是提升约5%。一直到现在，双通道对整个系统的影响最高只有多5%的性能而已。在实际使用上，若非长时间的极大数据运算或透过软件测试获取测试数据，对于用户的操作上并没有太大的差异\n如果是纯粹的CPU运算，使用双通道近乎没有性能增长。但对于高端游戏玩家或是绘图需求较大的用户而言，双通道技术不吝为一大帮助，因为GPU要经常访问纹理贴图数据，需要很大的存储器带宽。所以在使用双通道时，双倍的带宽可使内置绘图核心(GPU)的性能增长近一倍。\n\n参考文档：\n[双通道存储器技](https://zh.wikipedia.org/wiki/%E9%9B%99%E9%80%9A%E9%81%93%E8%A8%98%E6%86%B6%E9%AB%94%E6%8A%80%E8%A1%93)","source":"_posts/双通道存储器技术.md","raw":"---\ntitle: 双通道存储器技术\ndate: 2019-02-26 09:52:53\ntags:\n- 硬件\n- 内存\n---\n&nbsp;&nbsp;&nbsp;&nbsp;听说内存开始降价了，充满好奇心的我就打开京东看了一下内存条的价格，本来只想买一条的我，下单前看到一个套装两条内存居然比单条的价格贵了这么多，带着好奇询问了商家，商家的解释是这样的：\n* 内存条套装不是促销方式，而是2条（双通道）、3条（三通道）或者4条（四通道）品牌、参数完全相同的（同一生产线、同一批次的产品）内存成套销售，兼容性是最出色的。而单条内存，在组建通道的时候，具有随意性，可能品牌、参数都有差异，兼容性当然没有套装好。\n带着这个解释去了解双通道存储器技术\n# 1. 什么是双通道存储器技术\n维基百科给出的解释是：双通道（英语：Dual-channel）是一种能够让计算机性能增加的技术，此种技术将多个存储器由串联方式改良为并联方式，以得到更大的带宽。最早使用此技术的记忆体是Rambus。\n# 2. 为啥使用双通道存储器技术？\n主要是cpu随着技术发展，对内存要求越来越高，单通道技术已经不能满足cpu的要求。比如cpu 等待时间，数据传输，处理等要求。\n# 3. 双通道存储器技术的优点？相比单通道技术\n* 使用单通道技术时，主板上多条存储器是以串联方式运作，也就是仅是当作一条存储器运作，只是容量会相加。存储器总线宽度为64-bit，无论安装几条存储器，带宽都固定为64-bit。\n* 双通道便是利用并联方式运作，当连接两条存储器时，总线宽度将会达到128-bit，而套上存储器宽度计算便会知道相差甚远。也就是开双通道后，带宽可以增至两倍，性能也会增加；至于能否提升至两倍速度，根据测试似乎是没办法，但是对于存储器性能的提升却是很大的帮助。\n理论上，双通道能提升存储器两倍的性能；对系统整体性能来说，打开双通道带来的性能提升约为2至3%，最好的情况是提升约5%。一直到现在，双通道对整个系统的影响最高只有多5%的性能而已。在实际使用上，若非长时间的极大数据运算或透过软件测试获取测试数据，对于用户的操作上并没有太大的差异\n如果是纯粹的CPU运算，使用双通道近乎没有性能增长。但对于高端游戏玩家或是绘图需求较大的用户而言，双通道技术不吝为一大帮助，因为GPU要经常访问纹理贴图数据，需要很大的存储器带宽。所以在使用双通道时，双倍的带宽可使内置绘图核心(GPU)的性能增长近一倍。\n\n参考文档：\n[双通道存储器技](https://zh.wikipedia.org/wiki/%E9%9B%99%E9%80%9A%E9%81%93%E8%A8%98%E6%86%B6%E9%AB%94%E6%8A%80%E8%A1%93)","slug":"双通道存储器技术","published":1,"updated":"2019-07-14T03:11:26.979Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8mkctv1001c4osxi3zkuqic","content":"<p>&nbsp;&nbsp;&nbsp;&nbsp;听说内存开始降价了，充满好奇心的我就打开京东看了一下内存条的价格，本来只想买一条的我，下单前看到一个套装两条内存居然比单条的价格贵了这么多，带着好奇询问了商家，商家的解释是这样的：</p>\n<ul>\n<li>内存条套装不是促销方式，而是2条（双通道）、3条（三通道）或者4条（四通道）品牌、参数完全相同的（同一生产线、同一批次的产品）内存成套销售，兼容性是最出色的。而单条内存，在组建通道的时候，具有随意性，可能品牌、参数都有差异，兼容性当然没有套装好。<br>带着这个解释去了解双通道存储器技术<h1 id=\"1-什么是双通道存储器技术\"><a href=\"#1-什么是双通道存储器技术\" class=\"headerlink\" title=\"1. 什么是双通道存储器技术\"></a>1. 什么是双通道存储器技术</h1>维基百科给出的解释是：双通道（英语：Dual-channel）是一种能够让计算机性能增加的技术，此种技术将多个存储器由串联方式改良为并联方式，以得到更大的带宽。最早使用此技术的记忆体是Rambus。<h1 id=\"2-为啥使用双通道存储器技术？\"><a href=\"#2-为啥使用双通道存储器技术？\" class=\"headerlink\" title=\"2. 为啥使用双通道存储器技术？\"></a>2. 为啥使用双通道存储器技术？</h1>主要是cpu随着技术发展，对内存要求越来越高，单通道技术已经不能满足cpu的要求。比如cpu 等待时间，数据传输，处理等要求。<h1 id=\"3-双通道存储器技术的优点？相比单通道技术\"><a href=\"#3-双通道存储器技术的优点？相比单通道技术\" class=\"headerlink\" title=\"3. 双通道存储器技术的优点？相比单通道技术\"></a>3. 双通道存储器技术的优点？相比单通道技术</h1></li>\n<li>使用单通道技术时，主板上多条存储器是以串联方式运作，也就是仅是当作一条存储器运作，只是容量会相加。存储器总线宽度为64-bit，无论安装几条存储器，带宽都固定为64-bit。</li>\n<li>双通道便是利用并联方式运作，当连接两条存储器时，总线宽度将会达到128-bit，而套上存储器宽度计算便会知道相差甚远。也就是开双通道后，带宽可以增至两倍，性能也会增加；至于能否提升至两倍速度，根据测试似乎是没办法，但是对于存储器性能的提升却是很大的帮助。<br>理论上，双通道能提升存储器两倍的性能；对系统整体性能来说，打开双通道带来的性能提升约为2至3%，最好的情况是提升约5%。一直到现在，双通道对整个系统的影响最高只有多5%的性能而已。在实际使用上，若非长时间的极大数据运算或透过软件测试获取测试数据，对于用户的操作上并没有太大的差异<br>如果是纯粹的CPU运算，使用双通道近乎没有性能增长。但对于高端游戏玩家或是绘图需求较大的用户而言，双通道技术不吝为一大帮助，因为GPU要经常访问纹理贴图数据，需要很大的存储器带宽。所以在使用双通道时，双倍的带宽可使内置绘图核心(GPU)的性能增长近一倍。</li>\n</ul>\n<p>参考文档：<br><a href=\"https://zh.wikipedia.org/wiki/%E9%9B%99%E9%80%9A%E9%81%93%E8%A8%98%E6%86%B6%E9%AB%94%E6%8A%80%E8%A1%93\" target=\"_blank\" rel=\"noopener\">双通道存储器技</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>&nbsp;&nbsp;&nbsp;&nbsp;听说内存开始降价了，充满好奇心的我就打开京东看了一下内存条的价格，本来只想买一条的我，下单前看到一个套装两条内存居然比单条的价格贵了这么多，带着好奇询问了商家，商家的解释是这样的：</p>\n<ul>\n<li>内存条套装不是促销方式，而是2条（双通道）、3条（三通道）或者4条（四通道）品牌、参数完全相同的（同一生产线、同一批次的产品）内存成套销售，兼容性是最出色的。而单条内存，在组建通道的时候，具有随意性，可能品牌、参数都有差异，兼容性当然没有套装好。<br>带着这个解释去了解双通道存储器技术<h1 id=\"1-什么是双通道存储器技术\"><a href=\"#1-什么是双通道存储器技术\" class=\"headerlink\" title=\"1. 什么是双通道存储器技术\"></a>1. 什么是双通道存储器技术</h1>维基百科给出的解释是：双通道（英语：Dual-channel）是一种能够让计算机性能增加的技术，此种技术将多个存储器由串联方式改良为并联方式，以得到更大的带宽。最早使用此技术的记忆体是Rambus。<h1 id=\"2-为啥使用双通道存储器技术？\"><a href=\"#2-为啥使用双通道存储器技术？\" class=\"headerlink\" title=\"2. 为啥使用双通道存储器技术？\"></a>2. 为啥使用双通道存储器技术？</h1>主要是cpu随着技术发展，对内存要求越来越高，单通道技术已经不能满足cpu的要求。比如cpu 等待时间，数据传输，处理等要求。<h1 id=\"3-双通道存储器技术的优点？相比单通道技术\"><a href=\"#3-双通道存储器技术的优点？相比单通道技术\" class=\"headerlink\" title=\"3. 双通道存储器技术的优点？相比单通道技术\"></a>3. 双通道存储器技术的优点？相比单通道技术</h1></li>\n<li>使用单通道技术时，主板上多条存储器是以串联方式运作，也就是仅是当作一条存储器运作，只是容量会相加。存储器总线宽度为64-bit，无论安装几条存储器，带宽都固定为64-bit。</li>\n<li>双通道便是利用并联方式运作，当连接两条存储器时，总线宽度将会达到128-bit，而套上存储器宽度计算便会知道相差甚远。也就是开双通道后，带宽可以增至两倍，性能也会增加；至于能否提升至两倍速度，根据测试似乎是没办法，但是对于存储器性能的提升却是很大的帮助。<br>理论上，双通道能提升存储器两倍的性能；对系统整体性能来说，打开双通道带来的性能提升约为2至3%，最好的情况是提升约5%。一直到现在，双通道对整个系统的影响最高只有多5%的性能而已。在实际使用上，若非长时间的极大数据运算或透过软件测试获取测试数据，对于用户的操作上并没有太大的差异<br>如果是纯粹的CPU运算，使用双通道近乎没有性能增长。但对于高端游戏玩家或是绘图需求较大的用户而言，双通道技术不吝为一大帮助，因为GPU要经常访问纹理贴图数据，需要很大的存储器带宽。所以在使用双通道时，双倍的带宽可使内置绘图核心(GPU)的性能增长近一倍。</li>\n</ul>\n<p>参考文档：<br><a href=\"https://zh.wikipedia.org/wiki/%E9%9B%99%E9%80%9A%E9%81%93%E8%A8%98%E6%86%B6%E9%AB%94%E6%8A%80%E8%A1%93\" target=\"_blank\" rel=\"noopener\">双通道存储器技</a></p>\n"},{"title":"烈火军校","date":"2020-04-05T04:46:24.000Z","_content":" * [第01集](https://feifei.feifeizuida.com/20190806/15873_a85d9ed6/index.m3u8▶)\n\n * [第02集](https://feifei.feifeizuida.com/20190806/15872_76b5340f/index.m3u8▶)\n\n * [第03集](https://feifei.feifeizuida.com/20190806/15871_8c69a57a/index.m3u8▶)\n\n * [第04集](https://feifei.feifeizuida.com/20190806/15870_4aaf215e/index.m3u8▶)\n\n * [第05集](https://wuji.zhulong-zuida.com/20190807/4308_02f4fc61/index.m3u8▶)\n\n * [第06集](https://wuji.zhulong-zuida.com/20190807/4307_d4ad8895/index.m3u8▶)\n\n * [第07集](https://wuji.zhulong-zuida.com/20190807/4306_8404677e/index.m3u8▶)\n\n * [第08集](https://wuji.zhulong-zuida.com/20190807/4305_3dca9950/index.m3u8▶)\n\n * [第09集](https://wuji.zhulong-zuida.com/20190807/4304_d2545687/index.m3u8▶)\n\n * [第10集](https://wuji.zhulong-zuida.com/20190807/4303_71427d27/index.m3u8▶)\n\n * [第11集](https://feifei.feifeizuida.com/20190807/15933_311882c9/index.m3u8▶)\n\n * [第12集](https://feifei.feifeizuida.com/20190807/15932_6c4b96ce/index.m3u8▶)\n\n * [第13集](https://feifei.feifeizuida.com/20190808/15988_a4b583a2/index.m3u8▶)\n\n * [第14集](https://feifei.feifeizuida.com/20190808/15987_50d01bce/index.m3u8▶)\n\n * [第15集](https://feifei.feifeizuida.com/20190809/16062_1de7f227/index.m3u8▶)\n\n * [第16集](https://feifei.feifeizuida.com/20190809/16061_daa165bc/index.m3u8▶)\n\n * [第17集](https://feifei.feifeizuida.com/20190813/16317_c48559e9/index.m3u8▶)\n\n * [第18集](https://feifei.feifeizuida.com/20190813/16316_373668e3/index.m3u8▶)\n\n * [第19集](https://feifei.feifeizuida.com/20190814/16371_acfd05fc/index.m3u8▶)\n\n * [第20集](https://feifei.feifeizuida.com/20190814/16372_18fa71ba/index.m3u8▶)\n\n * [第21集](https://feifei.feifeizuida.com/20190815/16433_93238a90/index.m3u8▶)\n\n * [第22集](https://feifei.feifeizuida.com/20190815/16434_3534887a/index.m3u8▶)\n\n * [第23集](https://feifei.feifeizuida.com/20190816/16489_8b4fa824/index.m3u8▶)\n\n * [第24集](https://feifei.feifeizuida.com/20190816/16490_9eb449c4/index.m3u8▶)\n\n * [第25集](https://wuji.zhulong-zuida.com/20190820/6258_15219ee3/index.m3u8▶)\n\n * [第26集](https://wuji.zhulong-zuida.com/20190820/6257_a0f06a2d/index.m3u8▶)\n\n * [第27集](https://wuji.zhulong-zuida.com/20190821/6316_85fe34be/index.m3u8▶)\n\n * [第28集](https://wuji.zhulong-zuida.com/20190821/6315_389c5d19/index.m3u8▶)\n\n * [第29集](https://feifei.feifeizuida.com/20190822/16838_3918c3d8/index.m3u8▶)\n\n * [第30集](https://feifei.feifeizuida.com/20190822/16837_4781fae4/index.m3u8▶)\n\n * [第31集](https://wuji.zhulong-zuida.com/20190823/6488_d048e037/index.m3u8▶)\n\n * [第32集](https://wuji.zhulong-zuida.com/20190823/6487_e25affe0/index.m3u8▶)\n\n * [第33集](https://feifei.feifeizuida.com/20190827/17061_c92375a9/index.m3u8▶)\n\n * [第34集](https://feifei.feifeizuida.com/20190827/17060_cfe5a856/index.m3u8▶)\n\n * [第35集](https://feifei.feifeizuida.com/20190828/17115_87f57c79/index.m3u8▶)\n\n * [第36集](https://feifei.feifeizuida.com/20190828/17114_c8cf5ddf/index.m3u8▶)\n\n * [第37集](https://yanzishan.shuhu-zuida.com/20190829/15702_3f6ede64/index.m3u8▶)\n\n * [第38集](https://yanzishan.shuhu-zuida.com/20190829/15701_73ee43a7/index.m3u8▶)\n\n * [第39集](https://feifei.feifeizuida.com/20190830/17222_584e3538/index.m3u8▶)\n\n * [第40集](https://feifei.feifeizuida.com/20190830/17221_db4b840d/index.m3u8▶)\n\n * [第41集](https://wuji.zhulong-zuida.com/20190903/7325_edb54108/index.m3u8▶)\n\n * [第42集](https://wuji.zhulong-zuida.com/20190903/7324_dc22173c/index.m3u8▶)\n\n * [第43集](https://feifei.feifeizuida.com/20190904/17417_ac25c4ce/index.m3u8▶)\n\n * [第44集](https://feifei.feifeizuida.com/20190904/17416_5e789d7c/index.m3u8▶)\n\n * [第45集](https://feifei.feifeizuida.com/20190905/17486_893e9b05/index.m3u8▶)\n\n * [第46集](https://feifei.feifeizuida.com/20190905/17485_3a624526/index.m3u8▶)\n\n * [第47集](https://wuji.zhulong-zuida.com/20190906/7571_fdc3d72e/index.m3u8▶)\n\n * [第48集](https://wuji.zhulong-zuida.com/20190906/7570_06bf4971/index.m3u8▶)\n\n","source":"_posts/烈火军校.md","raw":"---\ntitle: 烈火军校\ndate: 2020-04-05 12:46:24\ntags:\n---\n * [第01集](https://feifei.feifeizuida.com/20190806/15873_a85d9ed6/index.m3u8▶)\n\n * [第02集](https://feifei.feifeizuida.com/20190806/15872_76b5340f/index.m3u8▶)\n\n * [第03集](https://feifei.feifeizuida.com/20190806/15871_8c69a57a/index.m3u8▶)\n\n * [第04集](https://feifei.feifeizuida.com/20190806/15870_4aaf215e/index.m3u8▶)\n\n * [第05集](https://wuji.zhulong-zuida.com/20190807/4308_02f4fc61/index.m3u8▶)\n\n * [第06集](https://wuji.zhulong-zuida.com/20190807/4307_d4ad8895/index.m3u8▶)\n\n * [第07集](https://wuji.zhulong-zuida.com/20190807/4306_8404677e/index.m3u8▶)\n\n * [第08集](https://wuji.zhulong-zuida.com/20190807/4305_3dca9950/index.m3u8▶)\n\n * [第09集](https://wuji.zhulong-zuida.com/20190807/4304_d2545687/index.m3u8▶)\n\n * [第10集](https://wuji.zhulong-zuida.com/20190807/4303_71427d27/index.m3u8▶)\n\n * [第11集](https://feifei.feifeizuida.com/20190807/15933_311882c9/index.m3u8▶)\n\n * [第12集](https://feifei.feifeizuida.com/20190807/15932_6c4b96ce/index.m3u8▶)\n\n * [第13集](https://feifei.feifeizuida.com/20190808/15988_a4b583a2/index.m3u8▶)\n\n * [第14集](https://feifei.feifeizuida.com/20190808/15987_50d01bce/index.m3u8▶)\n\n * [第15集](https://feifei.feifeizuida.com/20190809/16062_1de7f227/index.m3u8▶)\n\n * [第16集](https://feifei.feifeizuida.com/20190809/16061_daa165bc/index.m3u8▶)\n\n * [第17集](https://feifei.feifeizuida.com/20190813/16317_c48559e9/index.m3u8▶)\n\n * [第18集](https://feifei.feifeizuida.com/20190813/16316_373668e3/index.m3u8▶)\n\n * [第19集](https://feifei.feifeizuida.com/20190814/16371_acfd05fc/index.m3u8▶)\n\n * [第20集](https://feifei.feifeizuida.com/20190814/16372_18fa71ba/index.m3u8▶)\n\n * [第21集](https://feifei.feifeizuida.com/20190815/16433_93238a90/index.m3u8▶)\n\n * [第22集](https://feifei.feifeizuida.com/20190815/16434_3534887a/index.m3u8▶)\n\n * [第23集](https://feifei.feifeizuida.com/20190816/16489_8b4fa824/index.m3u8▶)\n\n * [第24集](https://feifei.feifeizuida.com/20190816/16490_9eb449c4/index.m3u8▶)\n\n * [第25集](https://wuji.zhulong-zuida.com/20190820/6258_15219ee3/index.m3u8▶)\n\n * [第26集](https://wuji.zhulong-zuida.com/20190820/6257_a0f06a2d/index.m3u8▶)\n\n * [第27集](https://wuji.zhulong-zuida.com/20190821/6316_85fe34be/index.m3u8▶)\n\n * [第28集](https://wuji.zhulong-zuida.com/20190821/6315_389c5d19/index.m3u8▶)\n\n * [第29集](https://feifei.feifeizuida.com/20190822/16838_3918c3d8/index.m3u8▶)\n\n * [第30集](https://feifei.feifeizuida.com/20190822/16837_4781fae4/index.m3u8▶)\n\n * [第31集](https://wuji.zhulong-zuida.com/20190823/6488_d048e037/index.m3u8▶)\n\n * [第32集](https://wuji.zhulong-zuida.com/20190823/6487_e25affe0/index.m3u8▶)\n\n * [第33集](https://feifei.feifeizuida.com/20190827/17061_c92375a9/index.m3u8▶)\n\n * [第34集](https://feifei.feifeizuida.com/20190827/17060_cfe5a856/index.m3u8▶)\n\n * [第35集](https://feifei.feifeizuida.com/20190828/17115_87f57c79/index.m3u8▶)\n\n * [第36集](https://feifei.feifeizuida.com/20190828/17114_c8cf5ddf/index.m3u8▶)\n\n * [第37集](https://yanzishan.shuhu-zuida.com/20190829/15702_3f6ede64/index.m3u8▶)\n\n * [第38集](https://yanzishan.shuhu-zuida.com/20190829/15701_73ee43a7/index.m3u8▶)\n\n * [第39集](https://feifei.feifeizuida.com/20190830/17222_584e3538/index.m3u8▶)\n\n * [第40集](https://feifei.feifeizuida.com/20190830/17221_db4b840d/index.m3u8▶)\n\n * [第41集](https://wuji.zhulong-zuida.com/20190903/7325_edb54108/index.m3u8▶)\n\n * [第42集](https://wuji.zhulong-zuida.com/20190903/7324_dc22173c/index.m3u8▶)\n\n * [第43集](https://feifei.feifeizuida.com/20190904/17417_ac25c4ce/index.m3u8▶)\n\n * [第44集](https://feifei.feifeizuida.com/20190904/17416_5e789d7c/index.m3u8▶)\n\n * [第45集](https://feifei.feifeizuida.com/20190905/17486_893e9b05/index.m3u8▶)\n\n * [第46集](https://feifei.feifeizuida.com/20190905/17485_3a624526/index.m3u8▶)\n\n * [第47集](https://wuji.zhulong-zuida.com/20190906/7571_fdc3d72e/index.m3u8▶)\n\n * [第48集](https://wuji.zhulong-zuida.com/20190906/7570_06bf4971/index.m3u8▶)\n\n","slug":"烈火军校","published":1,"updated":"2020-04-05T04:46:24.985Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8mkctv2001e4osx7izhojsi","content":"<ul>\n<li><p><a href=\"https://feifei.feifeizuida.com/20190806/15873_a85d9ed6/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第01集</a></p>\n</li>\n<li><p><a href=\"https://feifei.feifeizuida.com/20190806/15872_76b5340f/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第02集</a></p>\n</li>\n<li><p><a href=\"https://feifei.feifeizuida.com/20190806/15871_8c69a57a/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第03集</a></p>\n</li>\n<li><p><a href=\"https://feifei.feifeizuida.com/20190806/15870_4aaf215e/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第04集</a></p>\n</li>\n<li><p><a href=\"https://wuji.zhulong-zuida.com/20190807/4308_02f4fc61/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第05集</a></p>\n</li>\n<li><p><a href=\"https://wuji.zhulong-zuida.com/20190807/4307_d4ad8895/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第06集</a></p>\n</li>\n<li><p><a href=\"https://wuji.zhulong-zuida.com/20190807/4306_8404677e/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第07集</a></p>\n</li>\n<li><p><a href=\"https://wuji.zhulong-zuida.com/20190807/4305_3dca9950/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第08集</a></p>\n</li>\n<li><p><a href=\"https://wuji.zhulong-zuida.com/20190807/4304_d2545687/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第09集</a></p>\n</li>\n<li><p><a href=\"https://wuji.zhulong-zuida.com/20190807/4303_71427d27/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第10集</a></p>\n</li>\n<li><p><a href=\"https://feifei.feifeizuida.com/20190807/15933_311882c9/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第11集</a></p>\n</li>\n<li><p><a href=\"https://feifei.feifeizuida.com/20190807/15932_6c4b96ce/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第12集</a></p>\n</li>\n<li><p><a href=\"https://feifei.feifeizuida.com/20190808/15988_a4b583a2/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第13集</a></p>\n</li>\n<li><p><a href=\"https://feifei.feifeizuida.com/20190808/15987_50d01bce/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第14集</a></p>\n</li>\n<li><p><a href=\"https://feifei.feifeizuida.com/20190809/16062_1de7f227/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第15集</a></p>\n</li>\n<li><p><a href=\"https://feifei.feifeizuida.com/20190809/16061_daa165bc/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第16集</a></p>\n</li>\n<li><p><a href=\"https://feifei.feifeizuida.com/20190813/16317_c48559e9/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第17集</a></p>\n</li>\n<li><p><a href=\"https://feifei.feifeizuida.com/20190813/16316_373668e3/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第18集</a></p>\n</li>\n<li><p><a href=\"https://feifei.feifeizuida.com/20190814/16371_acfd05fc/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第19集</a></p>\n</li>\n<li><p><a href=\"https://feifei.feifeizuida.com/20190814/16372_18fa71ba/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第20集</a></p>\n</li>\n<li><p><a href=\"https://feifei.feifeizuida.com/20190815/16433_93238a90/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第21集</a></p>\n</li>\n<li><p><a href=\"https://feifei.feifeizuida.com/20190815/16434_3534887a/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第22集</a></p>\n</li>\n<li><p><a href=\"https://feifei.feifeizuida.com/20190816/16489_8b4fa824/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第23集</a></p>\n</li>\n<li><p><a href=\"https://feifei.feifeizuida.com/20190816/16490_9eb449c4/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第24集</a></p>\n</li>\n<li><p><a href=\"https://wuji.zhulong-zuida.com/20190820/6258_15219ee3/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第25集</a></p>\n</li>\n<li><p><a href=\"https://wuji.zhulong-zuida.com/20190820/6257_a0f06a2d/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第26集</a></p>\n</li>\n<li><p><a href=\"https://wuji.zhulong-zuida.com/20190821/6316_85fe34be/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第27集</a></p>\n</li>\n<li><p><a href=\"https://wuji.zhulong-zuida.com/20190821/6315_389c5d19/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第28集</a></p>\n</li>\n<li><p><a href=\"https://feifei.feifeizuida.com/20190822/16838_3918c3d8/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第29集</a></p>\n</li>\n<li><p><a href=\"https://feifei.feifeizuida.com/20190822/16837_4781fae4/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第30集</a></p>\n</li>\n<li><p><a href=\"https://wuji.zhulong-zuida.com/20190823/6488_d048e037/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第31集</a></p>\n</li>\n<li><p><a href=\"https://wuji.zhulong-zuida.com/20190823/6487_e25affe0/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第32集</a></p>\n</li>\n<li><p><a href=\"https://feifei.feifeizuida.com/20190827/17061_c92375a9/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第33集</a></p>\n</li>\n<li><p><a href=\"https://feifei.feifeizuida.com/20190827/17060_cfe5a856/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第34集</a></p>\n</li>\n<li><p><a href=\"https://feifei.feifeizuida.com/20190828/17115_87f57c79/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第35集</a></p>\n</li>\n<li><p><a href=\"https://feifei.feifeizuida.com/20190828/17114_c8cf5ddf/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第36集</a></p>\n</li>\n<li><p><a href=\"https://yanzishan.shuhu-zuida.com/20190829/15702_3f6ede64/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第37集</a></p>\n</li>\n<li><p><a href=\"https://yanzishan.shuhu-zuida.com/20190829/15701_73ee43a7/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第38集</a></p>\n</li>\n<li><p><a href=\"https://feifei.feifeizuida.com/20190830/17222_584e3538/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第39集</a></p>\n</li>\n<li><p><a href=\"https://feifei.feifeizuida.com/20190830/17221_db4b840d/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第40集</a></p>\n</li>\n<li><p><a href=\"https://wuji.zhulong-zuida.com/20190903/7325_edb54108/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第41集</a></p>\n</li>\n<li><p><a href=\"https://wuji.zhulong-zuida.com/20190903/7324_dc22173c/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第42集</a></p>\n</li>\n<li><p><a href=\"https://feifei.feifeizuida.com/20190904/17417_ac25c4ce/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第43集</a></p>\n</li>\n<li><p><a href=\"https://feifei.feifeizuida.com/20190904/17416_5e789d7c/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第44集</a></p>\n</li>\n<li><p><a href=\"https://feifei.feifeizuida.com/20190905/17486_893e9b05/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第45集</a></p>\n</li>\n<li><p><a href=\"https://feifei.feifeizuida.com/20190905/17485_3a624526/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第46集</a></p>\n</li>\n<li><p><a href=\"https://wuji.zhulong-zuida.com/20190906/7571_fdc3d72e/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第47集</a></p>\n</li>\n<li><p><a href=\"https://wuji.zhulong-zuida.com/20190906/7570_06bf4971/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第48集</a></p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><p><a href=\"https://feifei.feifeizuida.com/20190806/15873_a85d9ed6/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第01集</a></p>\n</li>\n<li><p><a href=\"https://feifei.feifeizuida.com/20190806/15872_76b5340f/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第02集</a></p>\n</li>\n<li><p><a href=\"https://feifei.feifeizuida.com/20190806/15871_8c69a57a/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第03集</a></p>\n</li>\n<li><p><a href=\"https://feifei.feifeizuida.com/20190806/15870_4aaf215e/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第04集</a></p>\n</li>\n<li><p><a href=\"https://wuji.zhulong-zuida.com/20190807/4308_02f4fc61/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第05集</a></p>\n</li>\n<li><p><a href=\"https://wuji.zhulong-zuida.com/20190807/4307_d4ad8895/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第06集</a></p>\n</li>\n<li><p><a href=\"https://wuji.zhulong-zuida.com/20190807/4306_8404677e/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第07集</a></p>\n</li>\n<li><p><a href=\"https://wuji.zhulong-zuida.com/20190807/4305_3dca9950/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第08集</a></p>\n</li>\n<li><p><a href=\"https://wuji.zhulong-zuida.com/20190807/4304_d2545687/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第09集</a></p>\n</li>\n<li><p><a href=\"https://wuji.zhulong-zuida.com/20190807/4303_71427d27/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第10集</a></p>\n</li>\n<li><p><a href=\"https://feifei.feifeizuida.com/20190807/15933_311882c9/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第11集</a></p>\n</li>\n<li><p><a href=\"https://feifei.feifeizuida.com/20190807/15932_6c4b96ce/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第12集</a></p>\n</li>\n<li><p><a href=\"https://feifei.feifeizuida.com/20190808/15988_a4b583a2/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第13集</a></p>\n</li>\n<li><p><a href=\"https://feifei.feifeizuida.com/20190808/15987_50d01bce/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第14集</a></p>\n</li>\n<li><p><a href=\"https://feifei.feifeizuida.com/20190809/16062_1de7f227/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第15集</a></p>\n</li>\n<li><p><a href=\"https://feifei.feifeizuida.com/20190809/16061_daa165bc/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第16集</a></p>\n</li>\n<li><p><a href=\"https://feifei.feifeizuida.com/20190813/16317_c48559e9/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第17集</a></p>\n</li>\n<li><p><a href=\"https://feifei.feifeizuida.com/20190813/16316_373668e3/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第18集</a></p>\n</li>\n<li><p><a href=\"https://feifei.feifeizuida.com/20190814/16371_acfd05fc/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第19集</a></p>\n</li>\n<li><p><a href=\"https://feifei.feifeizuida.com/20190814/16372_18fa71ba/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第20集</a></p>\n</li>\n<li><p><a href=\"https://feifei.feifeizuida.com/20190815/16433_93238a90/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第21集</a></p>\n</li>\n<li><p><a href=\"https://feifei.feifeizuida.com/20190815/16434_3534887a/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第22集</a></p>\n</li>\n<li><p><a href=\"https://feifei.feifeizuida.com/20190816/16489_8b4fa824/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第23集</a></p>\n</li>\n<li><p><a href=\"https://feifei.feifeizuida.com/20190816/16490_9eb449c4/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第24集</a></p>\n</li>\n<li><p><a href=\"https://wuji.zhulong-zuida.com/20190820/6258_15219ee3/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第25集</a></p>\n</li>\n<li><p><a href=\"https://wuji.zhulong-zuida.com/20190820/6257_a0f06a2d/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第26集</a></p>\n</li>\n<li><p><a href=\"https://wuji.zhulong-zuida.com/20190821/6316_85fe34be/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第27集</a></p>\n</li>\n<li><p><a href=\"https://wuji.zhulong-zuida.com/20190821/6315_389c5d19/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第28集</a></p>\n</li>\n<li><p><a href=\"https://feifei.feifeizuida.com/20190822/16838_3918c3d8/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第29集</a></p>\n</li>\n<li><p><a href=\"https://feifei.feifeizuida.com/20190822/16837_4781fae4/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第30集</a></p>\n</li>\n<li><p><a href=\"https://wuji.zhulong-zuida.com/20190823/6488_d048e037/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第31集</a></p>\n</li>\n<li><p><a href=\"https://wuji.zhulong-zuida.com/20190823/6487_e25affe0/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第32集</a></p>\n</li>\n<li><p><a href=\"https://feifei.feifeizuida.com/20190827/17061_c92375a9/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第33集</a></p>\n</li>\n<li><p><a href=\"https://feifei.feifeizuida.com/20190827/17060_cfe5a856/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第34集</a></p>\n</li>\n<li><p><a href=\"https://feifei.feifeizuida.com/20190828/17115_87f57c79/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第35集</a></p>\n</li>\n<li><p><a href=\"https://feifei.feifeizuida.com/20190828/17114_c8cf5ddf/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第36集</a></p>\n</li>\n<li><p><a href=\"https://yanzishan.shuhu-zuida.com/20190829/15702_3f6ede64/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第37集</a></p>\n</li>\n<li><p><a href=\"https://yanzishan.shuhu-zuida.com/20190829/15701_73ee43a7/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第38集</a></p>\n</li>\n<li><p><a href=\"https://feifei.feifeizuida.com/20190830/17222_584e3538/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第39集</a></p>\n</li>\n<li><p><a href=\"https://feifei.feifeizuida.com/20190830/17221_db4b840d/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第40集</a></p>\n</li>\n<li><p><a href=\"https://wuji.zhulong-zuida.com/20190903/7325_edb54108/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第41集</a></p>\n</li>\n<li><p><a href=\"https://wuji.zhulong-zuida.com/20190903/7324_dc22173c/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第42集</a></p>\n</li>\n<li><p><a href=\"https://feifei.feifeizuida.com/20190904/17417_ac25c4ce/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第43集</a></p>\n</li>\n<li><p><a href=\"https://feifei.feifeizuida.com/20190904/17416_5e789d7c/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第44集</a></p>\n</li>\n<li><p><a href=\"https://feifei.feifeizuida.com/20190905/17486_893e9b05/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第45集</a></p>\n</li>\n<li><p><a href=\"https://feifei.feifeizuida.com/20190905/17485_3a624526/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第46集</a></p>\n</li>\n<li><p><a href=\"https://wuji.zhulong-zuida.com/20190906/7571_fdc3d72e/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第47集</a></p>\n</li>\n<li><p><a href=\"https://wuji.zhulong-zuida.com/20190906/7570_06bf4971/index.m3u8▶\" target=\"_blank\" rel=\"noopener\">第48集</a></p>\n</li>\n</ul>\n"},{"title":"如何使用flatMap","date":"2019-03-15T01:52:57.000Z","_content":"\n# 1. 什么情况下用到flatMap\n* 当使用map（）操作时，不是返回一个值，而是返回一个集合或者一个数组的时候，这时候就可以使用flatMap解决这个问题。举个例子，你有一个列表 [21,23,42]，然后你调用getPrimeFactors()方法map操作 使数组转化成stream。\n* 上述结果[[3,7],[23],[2,3,7]]，这个类型Stream<String[]> 使用 stream 操作（filter，sum，distinct ...）和 collectors 都不支持这种类型。如果你想把Stream of Stream转换为值列表，使用 flatMap() 方法 重新生成一个Stream对象，最后可以得到 [3,7,2,3,2,3,7]\n# 2. flatMap如何工作的\n通过下面的图，我们就很容易理解flatmap在java8 中是如何工作的\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190304131022877.png)\n使用红色标记的列表和绿色标记的列表，经过flatmap方法后在第二个管道中把把上述两个列表的数据合并成一个列表数据\n# 3. flatmap 使用例子\n```\n\t\tList<List<Integer>> lists = new ArrayList<>();\n        List<Integer> list = new ArrayList<>();\n        list.add(4444);\n        list.add(33333);\n        list.add(444444);\n        lists.add(list);\n        lists.stream().flatMap(Collection::stream).forEach(System.out::println);\n```\n由于上述 lists.stream() 后返回的是stream<list<Integer>> 所以需要使用flatMap 进行合并\n# 3. 总结\n本文主要通过为啥使用 flatmap，如何使用flatmap 这两点讲述了flatmap方法，下一章节我们来讲一个map & flatmap。\n\n参考文档\n[How to use flatMap() in Java 8](http://www.java67.com/2016/03/how-to-use-flatmap-in-java-8-stream.html)\n[Java 8 flatMap示例](https://www.mkyong.com/java8/java-8-flatmap-example/)\n\n","source":"_posts/如何使用flatMap.md","raw":"---\ntitle: 如何使用flatMap\ndate: 2019-03-15 09:52:57\ntags:\n- JAVA 8\n---\n\n# 1. 什么情况下用到flatMap\n* 当使用map（）操作时，不是返回一个值，而是返回一个集合或者一个数组的时候，这时候就可以使用flatMap解决这个问题。举个例子，你有一个列表 [21,23,42]，然后你调用getPrimeFactors()方法map操作 使数组转化成stream。\n* 上述结果[[3,7],[23],[2,3,7]]，这个类型Stream<String[]> 使用 stream 操作（filter，sum，distinct ...）和 collectors 都不支持这种类型。如果你想把Stream of Stream转换为值列表，使用 flatMap() 方法 重新生成一个Stream对象，最后可以得到 [3,7,2,3,2,3,7]\n# 2. flatMap如何工作的\n通过下面的图，我们就很容易理解flatmap在java8 中是如何工作的\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190304131022877.png)\n使用红色标记的列表和绿色标记的列表，经过flatmap方法后在第二个管道中把把上述两个列表的数据合并成一个列表数据\n# 3. flatmap 使用例子\n```\n\t\tList<List<Integer>> lists = new ArrayList<>();\n        List<Integer> list = new ArrayList<>();\n        list.add(4444);\n        list.add(33333);\n        list.add(444444);\n        lists.add(list);\n        lists.stream().flatMap(Collection::stream).forEach(System.out::println);\n```\n由于上述 lists.stream() 后返回的是stream<list<Integer>> 所以需要使用flatMap 进行合并\n# 3. 总结\n本文主要通过为啥使用 flatmap，如何使用flatmap 这两点讲述了flatmap方法，下一章节我们来讲一个map & flatmap。\n\n参考文档\n[How to use flatMap() in Java 8](http://www.java67.com/2016/03/how-to-use-flatmap-in-java-8-stream.html)\n[Java 8 flatMap示例](https://www.mkyong.com/java8/java-8-flatmap-example/)\n\n","slug":"如何使用flatMap","published":1,"updated":"2019-07-14T04:37:24.748Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8mkctvi002i4osxy9eqmok6","content":"<h1 id=\"1-什么情况下用到flatMap\"><a href=\"#1-什么情况下用到flatMap\" class=\"headerlink\" title=\"1. 什么情况下用到flatMap\"></a>1. 什么情况下用到flatMap</h1><ul>\n<li>当使用map（）操作时，不是返回一个值，而是返回一个集合或者一个数组的时候，这时候就可以使用flatMap解决这个问题。举个例子，你有一个列表 [21,23,42]，然后你调用getPrimeFactors()方法map操作 使数组转化成stream。</li>\n<li>上述结果[[3,7],[23],[2,3,7]]，这个类型Stream&lt;String[]&gt; 使用 stream 操作（filter，sum，distinct …）和 collectors 都不支持这种类型。如果你想把Stream of Stream转换为值列表，使用 flatMap() 方法 重新生成一个Stream对象，最后可以得到 [3,7,2,3,2,3,7]<h1 id=\"2-flatMap如何工作的\"><a href=\"#2-flatMap如何工作的\" class=\"headerlink\" title=\"2. flatMap如何工作的\"></a>2. flatMap如何工作的</h1>通过下面的图，我们就很容易理解flatmap在java8 中是如何工作的<br><img src=\"https://img-blog.csdnimg.cn/20190304131022877.png\" alt=\"在这里插入图片描述\"><br>使用红色标记的列表和绿色标记的列表，经过flatmap方法后在第二个管道中把把上述两个列表的数据合并成一个列表数据<h1 id=\"3-flatmap-使用例子\"><a href=\"#3-flatmap-使用例子\" class=\"headerlink\" title=\"3. flatmap 使用例子\"></a>3. flatmap 使用例子</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;List&lt;Integer&gt;&gt; lists = new ArrayList&lt;&gt;();</span><br><span class=\"line\">      List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class=\"line\">      list.add(4444);</span><br><span class=\"line\">      list.add(33333);</span><br><span class=\"line\">      list.add(444444);</span><br><span class=\"line\">      lists.add(list);</span><br><span class=\"line\">      lists.stream().flatMap(Collection::stream).forEach(System.out::println);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>由于上述 lists.stream() 后返回的是stream&lt;list<integer>&gt; 所以需要使用flatMap 进行合并</integer></p>\n<h1 id=\"3-总结\"><a href=\"#3-总结\" class=\"headerlink\" title=\"3. 总结\"></a>3. 总结</h1><p>本文主要通过为啥使用 flatmap，如何使用flatmap 这两点讲述了flatmap方法，下一章节我们来讲一个map &amp; flatmap。</p>\n<p>参考文档<br><a href=\"http://www.java67.com/2016/03/how-to-use-flatmap-in-java-8-stream.html\" target=\"_blank\" rel=\"noopener\">How to use flatMap() in Java 8</a><br><a href=\"https://www.mkyong.com/java8/java-8-flatmap-example/\" target=\"_blank\" rel=\"noopener\">Java 8 flatMap示例</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-什么情况下用到flatMap\"><a href=\"#1-什么情况下用到flatMap\" class=\"headerlink\" title=\"1. 什么情况下用到flatMap\"></a>1. 什么情况下用到flatMap</h1><ul>\n<li>当使用map（）操作时，不是返回一个值，而是返回一个集合或者一个数组的时候，这时候就可以使用flatMap解决这个问题。举个例子，你有一个列表 [21,23,42]，然后你调用getPrimeFactors()方法map操作 使数组转化成stream。</li>\n<li>上述结果[[3,7],[23],[2,3,7]]，这个类型Stream&lt;String[]&gt; 使用 stream 操作（filter，sum，distinct …）和 collectors 都不支持这种类型。如果你想把Stream of Stream转换为值列表，使用 flatMap() 方法 重新生成一个Stream对象，最后可以得到 [3,7,2,3,2,3,7]<h1 id=\"2-flatMap如何工作的\"><a href=\"#2-flatMap如何工作的\" class=\"headerlink\" title=\"2. flatMap如何工作的\"></a>2. flatMap如何工作的</h1>通过下面的图，我们就很容易理解flatmap在java8 中是如何工作的<br><img src=\"https://img-blog.csdnimg.cn/20190304131022877.png\" alt=\"在这里插入图片描述\"><br>使用红色标记的列表和绿色标记的列表，经过flatmap方法后在第二个管道中把把上述两个列表的数据合并成一个列表数据<h1 id=\"3-flatmap-使用例子\"><a href=\"#3-flatmap-使用例子\" class=\"headerlink\" title=\"3. flatmap 使用例子\"></a>3. flatmap 使用例子</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;List&lt;Integer&gt;&gt; lists = new ArrayList&lt;&gt;();</span><br><span class=\"line\">      List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class=\"line\">      list.add(4444);</span><br><span class=\"line\">      list.add(33333);</span><br><span class=\"line\">      list.add(444444);</span><br><span class=\"line\">      lists.add(list);</span><br><span class=\"line\">      lists.stream().flatMap(Collection::stream).forEach(System.out::println);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>由于上述 lists.stream() 后返回的是stream&lt;list<integer>&gt; 所以需要使用flatMap 进行合并</integer></p>\n<h1 id=\"3-总结\"><a href=\"#3-总结\" class=\"headerlink\" title=\"3. 总结\"></a>3. 总结</h1><p>本文主要通过为啥使用 flatmap，如何使用flatmap 这两点讲述了flatmap方法，下一章节我们来讲一个map &amp; flatmap。</p>\n<p>参考文档<br><a href=\"http://www.java67.com/2016/03/how-to-use-flatmap-in-java-8-stream.html\" target=\"_blank\" rel=\"noopener\">How to use flatMap() in Java 8</a><br><a href=\"https://www.mkyong.com/java8/java-8-flatmap-example/\" target=\"_blank\" rel=\"noopener\">Java 8 flatMap示例</a></p>\n"},{"title":"工具网站","date":"2019-03-15T01:52:57.000Z","_content":"\n* [站长工具](https://tool.chinaz.com/)\n* [国外视频下载网站](https://savieo.com )\n* [图片搜索网站](https://pixelmob.co)\n* [独立音乐](https://themusic.today)\n* [搜索引擎](http://www.kinginso.com)\n* [找歌谱](http://www.zhaogepu.com)\n* [全世界收吗平台](https://www.temp-phone-number.com)\n* [草根二维码](https://cli.im/)\n* [文件下载](https://www.filecroco.com/)\n\n破解\n\n* [最新破解工具包](https://down.52pojie.cn/Tools/)\n* [熊猫破解](https://www.xmpojie.com/1368.html)\n\n娱乐\n\n* [网盘工具](https://www.runningcheese.com/baiduyun)\n* [苗有券](https://open.21ds.cn/)\n* [guidgen生成](https://www.guidgen.com/)\n* [在线短信接收](https://www.materialtools.com/)\n* [系统下载](http://www.imsdn.cn/)\n* [下载音乐](http://music.zhuolin.wang/)\n\n\n资源\n* [最大资源网](http://www.zuidazy2.net/)\n\n\n\n学习\n\n* [开发命名](https://unbug.github.io)\n* [hexo 开发文档](https://hexo.io/docs/commands)\n* [linux 命令大全](https://man.linuxde.net/tar)\n* [软件设计师试题下载](http://www.ixinguan.com/pd.jsp?id=34)\n\n\n\n","source":"_posts/工具网站.md","raw":"---\ntitle: 工具网站\ndate: 2019-03-15 09:52:57\ntags:\n- 工具\n---\n\n* [站长工具](https://tool.chinaz.com/)\n* [国外视频下载网站](https://savieo.com )\n* [图片搜索网站](https://pixelmob.co)\n* [独立音乐](https://themusic.today)\n* [搜索引擎](http://www.kinginso.com)\n* [找歌谱](http://www.zhaogepu.com)\n* [全世界收吗平台](https://www.temp-phone-number.com)\n* [草根二维码](https://cli.im/)\n* [文件下载](https://www.filecroco.com/)\n\n破解\n\n* [最新破解工具包](https://down.52pojie.cn/Tools/)\n* [熊猫破解](https://www.xmpojie.com/1368.html)\n\n娱乐\n\n* [网盘工具](https://www.runningcheese.com/baiduyun)\n* [苗有券](https://open.21ds.cn/)\n* [guidgen生成](https://www.guidgen.com/)\n* [在线短信接收](https://www.materialtools.com/)\n* [系统下载](http://www.imsdn.cn/)\n* [下载音乐](http://music.zhuolin.wang/)\n\n\n资源\n* [最大资源网](http://www.zuidazy2.net/)\n\n\n\n学习\n\n* [开发命名](https://unbug.github.io)\n* [hexo 开发文档](https://hexo.io/docs/commands)\n* [linux 命令大全](https://man.linuxde.net/tar)\n* [软件设计师试题下载](http://www.ixinguan.com/pd.jsp?id=34)\n\n\n\n","slug":"工具网站","published":1,"updated":"2020-01-14T07:44:23.868Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8mkctvj002j4osxs0fxm663","content":"<ul>\n<li><a href=\"https://tool.chinaz.com/\" target=\"_blank\" rel=\"noopener\">站长工具</a></li>\n<li><a href=\"https://savieo.com\" target=\"_blank\" rel=\"noopener\">国外视频下载网站</a></li>\n<li><a href=\"https://pixelmob.co\" target=\"_blank\" rel=\"noopener\">图片搜索网站</a></li>\n<li><a href=\"https://themusic.today\" target=\"_blank\" rel=\"noopener\">独立音乐</a></li>\n<li><a href=\"http://www.kinginso.com\" target=\"_blank\" rel=\"noopener\">搜索引擎</a></li>\n<li><a href=\"http://www.zhaogepu.com\" target=\"_blank\" rel=\"noopener\">找歌谱</a></li>\n<li><a href=\"https://www.temp-phone-number.com\" target=\"_blank\" rel=\"noopener\">全世界收吗平台</a></li>\n<li><a href=\"https://cli.im/\" target=\"_blank\" rel=\"noopener\">草根二维码</a></li>\n<li><a href=\"https://www.filecroco.com/\" target=\"_blank\" rel=\"noopener\">文件下载</a></li>\n</ul>\n<p>破解</p>\n<ul>\n<li><a href=\"https://down.52pojie.cn/Tools/\" target=\"_blank\" rel=\"noopener\">最新破解工具包</a></li>\n<li><a href=\"https://www.xmpojie.com/1368.html\" target=\"_blank\" rel=\"noopener\">熊猫破解</a></li>\n</ul>\n<p>娱乐</p>\n<ul>\n<li><a href=\"https://www.runningcheese.com/baiduyun\" target=\"_blank\" rel=\"noopener\">网盘工具</a></li>\n<li><a href=\"https://open.21ds.cn/\" target=\"_blank\" rel=\"noopener\">苗有券</a></li>\n<li><a href=\"https://www.guidgen.com/\" target=\"_blank\" rel=\"noopener\">guidgen生成</a></li>\n<li><a href=\"https://www.materialtools.com/\" target=\"_blank\" rel=\"noopener\">在线短信接收</a></li>\n<li><a href=\"http://www.imsdn.cn/\" target=\"_blank\" rel=\"noopener\">系统下载</a></li>\n<li><a href=\"http://music.zhuolin.wang/\" target=\"_blank\" rel=\"noopener\">下载音乐</a></li>\n</ul>\n<p>资源</p>\n<ul>\n<li><a href=\"http://www.zuidazy2.net/\" target=\"_blank\" rel=\"noopener\">最大资源网</a></li>\n</ul>\n<p>学习</p>\n<ul>\n<li><a href=\"https://unbug.github.io\" target=\"_blank\" rel=\"noopener\">开发命名</a></li>\n<li><a href=\"https://hexo.io/docs/commands\" target=\"_blank\" rel=\"noopener\">hexo 开发文档</a></li>\n<li><a href=\"https://man.linuxde.net/tar\" target=\"_blank\" rel=\"noopener\">linux 命令大全</a></li>\n<li><a href=\"http://www.ixinguan.com/pd.jsp?id=34\" target=\"_blank\" rel=\"noopener\">软件设计师试题下载</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><a href=\"https://tool.chinaz.com/\" target=\"_blank\" rel=\"noopener\">站长工具</a></li>\n<li><a href=\"https://savieo.com\" target=\"_blank\" rel=\"noopener\">国外视频下载网站</a></li>\n<li><a href=\"https://pixelmob.co\" target=\"_blank\" rel=\"noopener\">图片搜索网站</a></li>\n<li><a href=\"https://themusic.today\" target=\"_blank\" rel=\"noopener\">独立音乐</a></li>\n<li><a href=\"http://www.kinginso.com\" target=\"_blank\" rel=\"noopener\">搜索引擎</a></li>\n<li><a href=\"http://www.zhaogepu.com\" target=\"_blank\" rel=\"noopener\">找歌谱</a></li>\n<li><a href=\"https://www.temp-phone-number.com\" target=\"_blank\" rel=\"noopener\">全世界收吗平台</a></li>\n<li><a href=\"https://cli.im/\" target=\"_blank\" rel=\"noopener\">草根二维码</a></li>\n<li><a href=\"https://www.filecroco.com/\" target=\"_blank\" rel=\"noopener\">文件下载</a></li>\n</ul>\n<p>破解</p>\n<ul>\n<li><a href=\"https://down.52pojie.cn/Tools/\" target=\"_blank\" rel=\"noopener\">最新破解工具包</a></li>\n<li><a href=\"https://www.xmpojie.com/1368.html\" target=\"_blank\" rel=\"noopener\">熊猫破解</a></li>\n</ul>\n<p>娱乐</p>\n<ul>\n<li><a href=\"https://www.runningcheese.com/baiduyun\" target=\"_blank\" rel=\"noopener\">网盘工具</a></li>\n<li><a href=\"https://open.21ds.cn/\" target=\"_blank\" rel=\"noopener\">苗有券</a></li>\n<li><a href=\"https://www.guidgen.com/\" target=\"_blank\" rel=\"noopener\">guidgen生成</a></li>\n<li><a href=\"https://www.materialtools.com/\" target=\"_blank\" rel=\"noopener\">在线短信接收</a></li>\n<li><a href=\"http://www.imsdn.cn/\" target=\"_blank\" rel=\"noopener\">系统下载</a></li>\n<li><a href=\"http://music.zhuolin.wang/\" target=\"_blank\" rel=\"noopener\">下载音乐</a></li>\n</ul>\n<p>资源</p>\n<ul>\n<li><a href=\"http://www.zuidazy2.net/\" target=\"_blank\" rel=\"noopener\">最大资源网</a></li>\n</ul>\n<p>学习</p>\n<ul>\n<li><a href=\"https://unbug.github.io\" target=\"_blank\" rel=\"noopener\">开发命名</a></li>\n<li><a href=\"https://hexo.io/docs/commands\" target=\"_blank\" rel=\"noopener\">hexo 开发文档</a></li>\n<li><a href=\"https://man.linuxde.net/tar\" target=\"_blank\" rel=\"noopener\">linux 命令大全</a></li>\n<li><a href=\"http://www.ixinguan.com/pd.jsp?id=34\" target=\"_blank\" rel=\"noopener\">软件设计师试题下载</a></li>\n</ul>\n"},{"title":"Linux下离线安装mysql","date":"2019-12-05T01:37:32.000Z","_content":"#  下载mysql-5.7.28源码包（不需要编译）：\n\n地址：https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.28-linux-glibc2.12-x86_64.tar.gz\n<!-- more -->\n#  创建MySQL组并添加MySQL用户，MySQL用户不存在则创建\n\n    注意：执行以下命令需要在root权限下执行\n\n    groupadd mysql -- 创建mysql 组\n\n    useradd -r -g mysql mysql  创建MySQL用户并加入MySQL组\n\n    useradd 命令参数如下：\n\n   ![useradd命令](https://img.mupaie.com/useradd.png)\n\n# 解压源码\n\n解压包到指定目录下（/usr/local/mysql/）如果/usr/local/mysql/ 目录不存在则创建该目录\n\n```\ntar -zxvf mysql-5.7.28-linux-glibc2.12-x86_64.tar.gz -C /usr/local/mysql/\n```\n\n# 设置目录权限 \n\n``` \ncd /usr/local/mysql/ \nchown -R mysql:mysql /usr/local/mysql/\nchmod 775 /usr/local/mysql/\n```\n   \n# 创建 my.cnf 文件 \n\n如果/etc 下没有该文件，并填入以下内容\n\n```\n[mysqld] sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES\nexplicit_defaults_for_timestamp=true\nbasedir = /usr/local/mysql datadir= /usr/local/mysql/data\nport = 3306\nsocket =/usr/local/mysql/mysqld/mysql.sock\npid-file =/usr/local/mysql/mysqld/mysql.pid\ncharacter-set-server=utf8\nback_log =300\nmax_connections = 3000\nmax_connect_errors = 50\ntable_open_cache = 4096\nmax_allowed_packet = 32M\nmax_heap_table_size = 128M\nread_rnd_buffer_size = 16M\nsort_buffer_size = 16M\njoin_buffer_size = 16M\nthread_cache_size = 16\nquery_cache_size = 128M\nquery_cache_limit = 4M\nft_min_word_len = 8\nthread_stack = 512K\ntransaction_isolation = REPEATABLE-READ\ntmp_table_size = 128M\nlong_query_time = 6\nserver_id=1\ninnodb_buffer_pool_size = 1G\ninnodb_thread_concurrency = 16\ninnodb_log_buffer_size = 16M\ninnodb_log_file_size = 512M\ninnodb_log_files_in_group = 3\ninnodb_max_dirty_pages_pct = 90\ninnodb_lock_wait_timeout = 120\ninnodb_file_per_table = on\n[mysqldump]\nquick max_allowed_packet = 32M\n[mysql]\nno-auto-rehash\ndefault-character-set=utf8\nsafe-updates\n[myisamchk]\nkey_buffer = 16M\nsort_buffer_size = 16M\nread_buffer = 8M\nwrite_buffer = 8M\n[mysqlhotcopy]\ninteractive-timeout\n[mysqld_safe]\nopen-files-limit = 8192\n[client]\nport = 3306\nsocket = /usr/local/mysql/mysqld/mysql.sock\ndefault-character-set = utf8\n```\n# 创建文件夹\n\n```\n $ mkdir -p /usr/local/mysql/data\n $ chown -R mysql:mysql /usr/local/mysql/data\n $ chmod -R 755 /usr/local/mysql/data $ mkdir -p /usr/local/mysql/mysqld\n $ chown -R mysql:mysql /usr/local/mysql/mysqld\n $ chmod -R 755 /usr/local/mysql/mysqld\n```\n# 初始化数据库 \n\n进入到/usr/local/mysql/bin 下执行以下命令\n\n```\n$ ./mysqld --user=mysql --basedir=/usr/local/mysql--datadir=/usr/local/mysql/data --initialize\n```\n\n执行结束后会有一个临时密码记入下来\nA temporary password is generated for root@localhost: dsuIeduSe5>E\n\n方便等下登录 比如 dsuIeduSe5 就是我的临时密码\n\n# 创建软链接并配置环境变量\n```\n $ln -fs /usr/local/mysql/bin/mysql\n/usr/local/bin/mysql $ cp /usr/local/mysql/support-files/mysql.server\n/etc/init.d/mysqld\n```\n打开 vim /etc/profile 文件填入以下内容：\n```\nMYSQL_HOME= /usr/local/mysq/bin PATH=$MYSQL_HOME/bin:$PATH export\nMYSQL_HOME\n```\n# 启用Mysql \n\n```\n/etc/init.d/mysqld start 或 service mysql start\n```\n\n# 登录mysql\n    mysql -uroot -p  回车\n\n    输入上述的临时密码\n\n    登入成功后出现以下内容则表示成功：\n\n   ![useradd命令](https://img.mupaie.com/mysql.png)\n\n# 安装过程下如果出现以下问题\n* 问题1：\n启动 mysql 的时候出现\nCan’t connect to local MySQL server through socket ‘/var/lib/mysql/mysql.sock’ \n解决方法：查看mysql.sock目录mysql用户是否有权限访问，如果没有权限则赋权\n\n* 问题2：\n启动 mysql 的时候出现\nStarting MySQL...[ERROR] The server quit without updating PID file (/usr/local/mysql/data/mysqld.pid).\n解决：\n1. 查看该目录是否有权限\n2. 查看 mysqld进程是否存在\n3. 去mysql的数据目录/data看看，如果存在mysql-bin.index，就赶快把它删除掉吧，它就是罪魁祸首了\n4. [mysqld]下指定数据目录(datadir) /usr/local/mysql/data \n\n* 问题3：\n\n5. 忘记临时密码\n上述执行mysqld命令会生成对应的日志文件，目录/var/log/mysqld.log 执行 grep\n'temporary password' /var/log/mysqld.log 查看临时密码\n如果日志中查不到密码使用以下方法： 进入/usr/local/mysql/bin\n目录，操作前先关闭mysql服务 执行 mysqld_safe --skip-grant-tables\n--user=mysql &\n\n执行 mysql 命令 进入mysql\n```\nuse mysql; update user set authentication_string=password(\"新密码\") where user='root';\n```\n执行这段sql可能会出现以下错误：\n```\nError Code: 1175. You are using safe update mode and you tried to\nupdate a table without a WHERE that uses a KEY column To disable safe\nmode, toggle the option in Preferences -> SQL Queries and reconnect.\n```\n\n由于安全模式下更新语句条件必须是主键 关闭安全模式：\n```\n SET SQL_SAFE_UPDATES = 0;\n```\n修改下数据库模式 继续执行上述sql\n\n* 问题4： 远程访问数据库 update user set host = '%' where user='root';\n 让root用户可以远程登录，但是这样做有风险不建议使用\n\n参考文档:\n\n[安装：MySQL mysql-5.7.19-linux-glibc2.12-x86_64.tar.gz](https://www.jianshu.com/p/82790b6b4e08)\n\n[【MySQL笔记】解除输入的安全模式](https://www.cnblogs.com/xuancaoyy/p/5814658.html)\n","source":"_posts/mysql-Linux下离线安装mysql.md","raw":"---\ntitle: 'Linux下离线安装mysql'\ndate: 2019-12-05 09:37:32\ntags:\n- mysql\n---\n#  下载mysql-5.7.28源码包（不需要编译）：\n\n地址：https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.28-linux-glibc2.12-x86_64.tar.gz\n<!-- more -->\n#  创建MySQL组并添加MySQL用户，MySQL用户不存在则创建\n\n    注意：执行以下命令需要在root权限下执行\n\n    groupadd mysql -- 创建mysql 组\n\n    useradd -r -g mysql mysql  创建MySQL用户并加入MySQL组\n\n    useradd 命令参数如下：\n\n   ![useradd命令](https://img.mupaie.com/useradd.png)\n\n# 解压源码\n\n解压包到指定目录下（/usr/local/mysql/）如果/usr/local/mysql/ 目录不存在则创建该目录\n\n```\ntar -zxvf mysql-5.7.28-linux-glibc2.12-x86_64.tar.gz -C /usr/local/mysql/\n```\n\n# 设置目录权限 \n\n``` \ncd /usr/local/mysql/ \nchown -R mysql:mysql /usr/local/mysql/\nchmod 775 /usr/local/mysql/\n```\n   \n# 创建 my.cnf 文件 \n\n如果/etc 下没有该文件，并填入以下内容\n\n```\n[mysqld] sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES\nexplicit_defaults_for_timestamp=true\nbasedir = /usr/local/mysql datadir= /usr/local/mysql/data\nport = 3306\nsocket =/usr/local/mysql/mysqld/mysql.sock\npid-file =/usr/local/mysql/mysqld/mysql.pid\ncharacter-set-server=utf8\nback_log =300\nmax_connections = 3000\nmax_connect_errors = 50\ntable_open_cache = 4096\nmax_allowed_packet = 32M\nmax_heap_table_size = 128M\nread_rnd_buffer_size = 16M\nsort_buffer_size = 16M\njoin_buffer_size = 16M\nthread_cache_size = 16\nquery_cache_size = 128M\nquery_cache_limit = 4M\nft_min_word_len = 8\nthread_stack = 512K\ntransaction_isolation = REPEATABLE-READ\ntmp_table_size = 128M\nlong_query_time = 6\nserver_id=1\ninnodb_buffer_pool_size = 1G\ninnodb_thread_concurrency = 16\ninnodb_log_buffer_size = 16M\ninnodb_log_file_size = 512M\ninnodb_log_files_in_group = 3\ninnodb_max_dirty_pages_pct = 90\ninnodb_lock_wait_timeout = 120\ninnodb_file_per_table = on\n[mysqldump]\nquick max_allowed_packet = 32M\n[mysql]\nno-auto-rehash\ndefault-character-set=utf8\nsafe-updates\n[myisamchk]\nkey_buffer = 16M\nsort_buffer_size = 16M\nread_buffer = 8M\nwrite_buffer = 8M\n[mysqlhotcopy]\ninteractive-timeout\n[mysqld_safe]\nopen-files-limit = 8192\n[client]\nport = 3306\nsocket = /usr/local/mysql/mysqld/mysql.sock\ndefault-character-set = utf8\n```\n# 创建文件夹\n\n```\n $ mkdir -p /usr/local/mysql/data\n $ chown -R mysql:mysql /usr/local/mysql/data\n $ chmod -R 755 /usr/local/mysql/data $ mkdir -p /usr/local/mysql/mysqld\n $ chown -R mysql:mysql /usr/local/mysql/mysqld\n $ chmod -R 755 /usr/local/mysql/mysqld\n```\n# 初始化数据库 \n\n进入到/usr/local/mysql/bin 下执行以下命令\n\n```\n$ ./mysqld --user=mysql --basedir=/usr/local/mysql--datadir=/usr/local/mysql/data --initialize\n```\n\n执行结束后会有一个临时密码记入下来\nA temporary password is generated for root@localhost: dsuIeduSe5>E\n\n方便等下登录 比如 dsuIeduSe5 就是我的临时密码\n\n# 创建软链接并配置环境变量\n```\n $ln -fs /usr/local/mysql/bin/mysql\n/usr/local/bin/mysql $ cp /usr/local/mysql/support-files/mysql.server\n/etc/init.d/mysqld\n```\n打开 vim /etc/profile 文件填入以下内容：\n```\nMYSQL_HOME= /usr/local/mysq/bin PATH=$MYSQL_HOME/bin:$PATH export\nMYSQL_HOME\n```\n# 启用Mysql \n\n```\n/etc/init.d/mysqld start 或 service mysql start\n```\n\n# 登录mysql\n    mysql -uroot -p  回车\n\n    输入上述的临时密码\n\n    登入成功后出现以下内容则表示成功：\n\n   ![useradd命令](https://img.mupaie.com/mysql.png)\n\n# 安装过程下如果出现以下问题\n* 问题1：\n启动 mysql 的时候出现\nCan’t connect to local MySQL server through socket ‘/var/lib/mysql/mysql.sock’ \n解决方法：查看mysql.sock目录mysql用户是否有权限访问，如果没有权限则赋权\n\n* 问题2：\n启动 mysql 的时候出现\nStarting MySQL...[ERROR] The server quit without updating PID file (/usr/local/mysql/data/mysqld.pid).\n解决：\n1. 查看该目录是否有权限\n2. 查看 mysqld进程是否存在\n3. 去mysql的数据目录/data看看，如果存在mysql-bin.index，就赶快把它删除掉吧，它就是罪魁祸首了\n4. [mysqld]下指定数据目录(datadir) /usr/local/mysql/data \n\n* 问题3：\n\n5. 忘记临时密码\n上述执行mysqld命令会生成对应的日志文件，目录/var/log/mysqld.log 执行 grep\n'temporary password' /var/log/mysqld.log 查看临时密码\n如果日志中查不到密码使用以下方法： 进入/usr/local/mysql/bin\n目录，操作前先关闭mysql服务 执行 mysqld_safe --skip-grant-tables\n--user=mysql &\n\n执行 mysql 命令 进入mysql\n```\nuse mysql; update user set authentication_string=password(\"新密码\") where user='root';\n```\n执行这段sql可能会出现以下错误：\n```\nError Code: 1175. You are using safe update mode and you tried to\nupdate a table without a WHERE that uses a KEY column To disable safe\nmode, toggle the option in Preferences -> SQL Queries and reconnect.\n```\n\n由于安全模式下更新语句条件必须是主键 关闭安全模式：\n```\n SET SQL_SAFE_UPDATES = 0;\n```\n修改下数据库模式 继续执行上述sql\n\n* 问题4： 远程访问数据库 update user set host = '%' where user='root';\n 让root用户可以远程登录，但是这样做有风险不建议使用\n\n参考文档:\n\n[安装：MySQL mysql-5.7.19-linux-glibc2.12-x86_64.tar.gz](https://www.jianshu.com/p/82790b6b4e08)\n\n[【MySQL笔记】解除输入的安全模式](https://www.cnblogs.com/xuancaoyy/p/5814658.html)\n","slug":"mysql-Linux下离线安装mysql","published":1,"updated":"2020-04-04T09:38:03.816Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8mkctvm002o4osxo5kora9p","content":"<h1 id=\"下载mysql-5-7-28源码包（不需要编译）：\"><a href=\"#下载mysql-5-7-28源码包（不需要编译）：\" class=\"headerlink\" title=\"下载mysql-5.7.28源码包（不需要编译）：\"></a>下载mysql-5.7.28源码包（不需要编译）：</h1><p>地址：<a href=\"https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.28-linux-glibc2.12-x86_64.tar.gz\" target=\"_blank\" rel=\"noopener\">https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.28-linux-glibc2.12-x86_64.tar.gz</a><br><a id=\"more\"></a></p>\n<h1 id=\"创建MySQL组并添加MySQL用户，MySQL用户不存在则创建\"><a href=\"#创建MySQL组并添加MySQL用户，MySQL用户不存在则创建\" class=\"headerlink\" title=\"创建MySQL组并添加MySQL用户，MySQL用户不存在则创建\"></a>创建MySQL组并添加MySQL用户，MySQL用户不存在则创建</h1><pre><code>注意：执行以下命令需要在root权限下执行\n\ngroupadd mysql -- 创建mysql 组\n\nuseradd -r -g mysql mysql  创建MySQL用户并加入MySQL组\n\nuseradd 命令参数如下：\n</code></pre><p>   <img src=\"https://img.mupaie.com/useradd.png\" alt=\"useradd命令\"></p>\n<h1 id=\"解压源码\"><a href=\"#解压源码\" class=\"headerlink\" title=\"解压源码\"></a>解压源码</h1><p>解压包到指定目录下（/usr/local/mysql/）如果/usr/local/mysql/ 目录不存在则创建该目录</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -zxvf mysql-5.7.28-linux-glibc2.12-x86_64.tar.gz -C /usr/local/mysql/</span><br></pre></td></tr></table></figure>\n<h1 id=\"设置目录权限\"><a href=\"#设置目录权限\" class=\"headerlink\" title=\"设置目录权限\"></a>设置目录权限</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd /usr/local/mysql/ </span><br><span class=\"line\">chown -R mysql:mysql /usr/local/mysql/</span><br><span class=\"line\">chmod 775 /usr/local/mysql/</span><br></pre></td></tr></table></figure>\n<h1 id=\"创建-my-cnf-文件\"><a href=\"#创建-my-cnf-文件\" class=\"headerlink\" title=\"创建 my.cnf 文件\"></a>创建 my.cnf 文件</h1><p>如果/etc 下没有该文件，并填入以下内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mysqld] sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES</span><br><span class=\"line\">explicit_defaults_for_timestamp=true</span><br><span class=\"line\">basedir = /usr/local/mysql datadir= /usr/local/mysql/data</span><br><span class=\"line\">port = 3306</span><br><span class=\"line\">socket =/usr/local/mysql/mysqld/mysql.sock</span><br><span class=\"line\">pid-file =/usr/local/mysql/mysqld/mysql.pid</span><br><span class=\"line\">character-set-server=utf8</span><br><span class=\"line\">back_log =300</span><br><span class=\"line\">max_connections = 3000</span><br><span class=\"line\">max_connect_errors = 50</span><br><span class=\"line\">table_open_cache = 4096</span><br><span class=\"line\">max_allowed_packet = 32M</span><br><span class=\"line\">max_heap_table_size = 128M</span><br><span class=\"line\">read_rnd_buffer_size = 16M</span><br><span class=\"line\">sort_buffer_size = 16M</span><br><span class=\"line\">join_buffer_size = 16M</span><br><span class=\"line\">thread_cache_size = 16</span><br><span class=\"line\">query_cache_size = 128M</span><br><span class=\"line\">query_cache_limit = 4M</span><br><span class=\"line\">ft_min_word_len = 8</span><br><span class=\"line\">thread_stack = 512K</span><br><span class=\"line\">transaction_isolation = REPEATABLE-READ</span><br><span class=\"line\">tmp_table_size = 128M</span><br><span class=\"line\">long_query_time = 6</span><br><span class=\"line\">server_id=1</span><br><span class=\"line\">innodb_buffer_pool_size = 1G</span><br><span class=\"line\">innodb_thread_concurrency = 16</span><br><span class=\"line\">innodb_log_buffer_size = 16M</span><br><span class=\"line\">innodb_log_file_size = 512M</span><br><span class=\"line\">innodb_log_files_in_group = 3</span><br><span class=\"line\">innodb_max_dirty_pages_pct = 90</span><br><span class=\"line\">innodb_lock_wait_timeout = 120</span><br><span class=\"line\">innodb_file_per_table = on</span><br><span class=\"line\">[mysqldump]</span><br><span class=\"line\">quick max_allowed_packet = 32M</span><br><span class=\"line\">[mysql]</span><br><span class=\"line\">no-auto-rehash</span><br><span class=\"line\">default-character-set=utf8</span><br><span class=\"line\">safe-updates</span><br><span class=\"line\">[myisamchk]</span><br><span class=\"line\">key_buffer = 16M</span><br><span class=\"line\">sort_buffer_size = 16M</span><br><span class=\"line\">read_buffer = 8M</span><br><span class=\"line\">write_buffer = 8M</span><br><span class=\"line\">[mysqlhotcopy]</span><br><span class=\"line\">interactive-timeout</span><br><span class=\"line\">[mysqld_safe]</span><br><span class=\"line\">open-files-limit = 8192</span><br><span class=\"line\">[client]</span><br><span class=\"line\">port = 3306</span><br><span class=\"line\">socket = /usr/local/mysql/mysqld/mysql.sock</span><br><span class=\"line\">default-character-set = utf8</span><br></pre></td></tr></table></figure>\n<h1 id=\"创建文件夹\"><a href=\"#创建文件夹\" class=\"headerlink\" title=\"创建文件夹\"></a>创建文件夹</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mkdir -p /usr/local/mysql/data</span><br><span class=\"line\">$ chown -R mysql:mysql /usr/local/mysql/data</span><br><span class=\"line\">$ chmod -R 755 /usr/local/mysql/data $ mkdir -p /usr/local/mysql/mysqld</span><br><span class=\"line\">$ chown -R mysql:mysql /usr/local/mysql/mysqld</span><br><span class=\"line\">$ chmod -R 755 /usr/local/mysql/mysqld</span><br></pre></td></tr></table></figure>\n<h1 id=\"初始化数据库\"><a href=\"#初始化数据库\" class=\"headerlink\" title=\"初始化数据库\"></a>初始化数据库</h1><p>进入到/usr/local/mysql/bin 下执行以下命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ./mysqld --user=mysql --basedir=/usr/local/mysql--datadir=/usr/local/mysql/data --initialize</span><br></pre></td></tr></table></figure>\n<p>执行结束后会有一个临时密码记入下来<br>A temporary password is generated for root@localhost: dsuIeduSe5&gt;E</p>\n<p>方便等下登录 比如 dsuIeduSe5 就是我的临时密码</p>\n<h1 id=\"创建软链接并配置环境变量\"><a href=\"#创建软链接并配置环境变量\" class=\"headerlink\" title=\"创建软链接并配置环境变量\"></a>创建软链接并配置环境变量</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> $ln -fs /usr/local/mysql/bin/mysql</span><br><span class=\"line\">/usr/local/bin/mysql $ cp /usr/local/mysql/support-files/mysql.server</span><br><span class=\"line\">/etc/init.d/mysqld</span><br></pre></td></tr></table></figure>\n<p>打开 vim /etc/profile 文件填入以下内容：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MYSQL_HOME= /usr/local/mysq/bin PATH=$MYSQL_HOME/bin:$PATH export</span><br><span class=\"line\">MYSQL_HOME</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"启用Mysql\"><a href=\"#启用Mysql\" class=\"headerlink\" title=\"启用Mysql\"></a>启用Mysql</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/etc/init.d/mysqld start 或 service mysql start</span><br></pre></td></tr></table></figure>\n<h1 id=\"登录mysql\"><a href=\"#登录mysql\" class=\"headerlink\" title=\"登录mysql\"></a>登录mysql</h1><pre><code>mysql -uroot -p  回车\n\n输入上述的临时密码\n\n登入成功后出现以下内容则表示成功：\n</code></pre><p>   <img src=\"https://img.mupaie.com/mysql.png\" alt=\"useradd命令\"></p>\n<h1 id=\"安装过程下如果出现以下问题\"><a href=\"#安装过程下如果出现以下问题\" class=\"headerlink\" title=\"安装过程下如果出现以下问题\"></a>安装过程下如果出现以下问题</h1><ul>\n<li><p>问题1：<br>启动 mysql 的时候出现<br>Can’t connect to local MySQL server through socket ‘/var/lib/mysql/mysql.sock’<br>解决方法：查看mysql.sock目录mysql用户是否有权限访问，如果没有权限则赋权</p>\n</li>\n<li><p>问题2：<br>启动 mysql 的时候出现<br>Starting MySQL…[ERROR] The server quit without updating PID file (/usr/local/mysql/data/mysqld.pid).<br>解决：</p>\n</li>\n</ul>\n<ol>\n<li>查看该目录是否有权限</li>\n<li>查看 mysqld进程是否存在</li>\n<li>去mysql的数据目录/data看看，如果存在mysql-bin.index，就赶快把它删除掉吧，它就是罪魁祸首了</li>\n<li>[mysqld]下指定数据目录(datadir) /usr/local/mysql/data </li>\n</ol>\n<ul>\n<li>问题3：</li>\n</ul>\n<ol start=\"5\">\n<li>忘记临时密码<br>上述执行mysqld命令会生成对应的日志文件，目录/var/log/mysqld.log 执行 grep<br>‘temporary password’ /var/log/mysqld.log 查看临时密码<br>如果日志中查不到密码使用以下方法： 进入/usr/local/mysql/bin<br>目录，操作前先关闭mysql服务 执行 mysqld_safe –skip-grant-tables<br>–user=mysql &amp;</li>\n</ol>\n<p>执行 mysql 命令 进入mysql<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">use mysql; update user set authentication_string=password(&quot;新密码&quot;) where user=&apos;root&apos;;</span><br></pre></td></tr></table></figure></p>\n<p>执行这段sql可能会出现以下错误：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Error Code: 1175. You are using safe update mode and you tried to</span><br><span class=\"line\">update a table without a WHERE that uses a KEY column To disable safe</span><br><span class=\"line\">mode, toggle the option in Preferences -&gt; SQL Queries and reconnect.</span><br></pre></td></tr></table></figure></p>\n<p>由于安全模式下更新语句条件必须是主键 关闭安全模式：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SET SQL_SAFE_UPDATES = 0;</span><br></pre></td></tr></table></figure></p>\n<p>修改下数据库模式 继续执行上述sql</p>\n<ul>\n<li>问题4： 远程访问数据库 update user set host = ‘%’ where user=’root’;<br>让root用户可以远程登录，但是这样做有风险不建议使用</li>\n</ul>\n<p>参考文档:</p>\n<p><a href=\"https://www.jianshu.com/p/82790b6b4e08\" target=\"_blank\" rel=\"noopener\">安装：MySQL mysql-5.7.19-linux-glibc2.12-x86_64.tar.gz</a></p>\n<p><a href=\"https://www.cnblogs.com/xuancaoyy/p/5814658.html\" target=\"_blank\" rel=\"noopener\">【MySQL笔记】解除输入的安全模式</a></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"下载mysql-5-7-28源码包（不需要编译）：\"><a href=\"#下载mysql-5-7-28源码包（不需要编译）：\" class=\"headerlink\" title=\"下载mysql-5.7.28源码包（不需要编译）：\"></a>下载mysql-5.7.28源码包（不需要编译）：</h1><p>地址：<a href=\"https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.28-linux-glibc2.12-x86_64.tar.gz\" target=\"_blank\" rel=\"noopener\">https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.28-linux-glibc2.12-x86_64.tar.gz</a><br></p>","more":"<p></p>\n<h1 id=\"创建MySQL组并添加MySQL用户，MySQL用户不存在则创建\"><a href=\"#创建MySQL组并添加MySQL用户，MySQL用户不存在则创建\" class=\"headerlink\" title=\"创建MySQL组并添加MySQL用户，MySQL用户不存在则创建\"></a>创建MySQL组并添加MySQL用户，MySQL用户不存在则创建</h1><pre><code>注意：执行以下命令需要在root权限下执行\n\ngroupadd mysql -- 创建mysql 组\n\nuseradd -r -g mysql mysql  创建MySQL用户并加入MySQL组\n\nuseradd 命令参数如下：\n</code></pre><p>   <img src=\"https://img.mupaie.com/useradd.png\" alt=\"useradd命令\"></p>\n<h1 id=\"解压源码\"><a href=\"#解压源码\" class=\"headerlink\" title=\"解压源码\"></a>解压源码</h1><p>解压包到指定目录下（/usr/local/mysql/）如果/usr/local/mysql/ 目录不存在则创建该目录</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -zxvf mysql-5.7.28-linux-glibc2.12-x86_64.tar.gz -C /usr/local/mysql/</span><br></pre></td></tr></table></figure>\n<h1 id=\"设置目录权限\"><a href=\"#设置目录权限\" class=\"headerlink\" title=\"设置目录权限\"></a>设置目录权限</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd /usr/local/mysql/ </span><br><span class=\"line\">chown -R mysql:mysql /usr/local/mysql/</span><br><span class=\"line\">chmod 775 /usr/local/mysql/</span><br></pre></td></tr></table></figure>\n<h1 id=\"创建-my-cnf-文件\"><a href=\"#创建-my-cnf-文件\" class=\"headerlink\" title=\"创建 my.cnf 文件\"></a>创建 my.cnf 文件</h1><p>如果/etc 下没有该文件，并填入以下内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mysqld] sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES</span><br><span class=\"line\">explicit_defaults_for_timestamp=true</span><br><span class=\"line\">basedir = /usr/local/mysql datadir= /usr/local/mysql/data</span><br><span class=\"line\">port = 3306</span><br><span class=\"line\">socket =/usr/local/mysql/mysqld/mysql.sock</span><br><span class=\"line\">pid-file =/usr/local/mysql/mysqld/mysql.pid</span><br><span class=\"line\">character-set-server=utf8</span><br><span class=\"line\">back_log =300</span><br><span class=\"line\">max_connections = 3000</span><br><span class=\"line\">max_connect_errors = 50</span><br><span class=\"line\">table_open_cache = 4096</span><br><span class=\"line\">max_allowed_packet = 32M</span><br><span class=\"line\">max_heap_table_size = 128M</span><br><span class=\"line\">read_rnd_buffer_size = 16M</span><br><span class=\"line\">sort_buffer_size = 16M</span><br><span class=\"line\">join_buffer_size = 16M</span><br><span class=\"line\">thread_cache_size = 16</span><br><span class=\"line\">query_cache_size = 128M</span><br><span class=\"line\">query_cache_limit = 4M</span><br><span class=\"line\">ft_min_word_len = 8</span><br><span class=\"line\">thread_stack = 512K</span><br><span class=\"line\">transaction_isolation = REPEATABLE-READ</span><br><span class=\"line\">tmp_table_size = 128M</span><br><span class=\"line\">long_query_time = 6</span><br><span class=\"line\">server_id=1</span><br><span class=\"line\">innodb_buffer_pool_size = 1G</span><br><span class=\"line\">innodb_thread_concurrency = 16</span><br><span class=\"line\">innodb_log_buffer_size = 16M</span><br><span class=\"line\">innodb_log_file_size = 512M</span><br><span class=\"line\">innodb_log_files_in_group = 3</span><br><span class=\"line\">innodb_max_dirty_pages_pct = 90</span><br><span class=\"line\">innodb_lock_wait_timeout = 120</span><br><span class=\"line\">innodb_file_per_table = on</span><br><span class=\"line\">[mysqldump]</span><br><span class=\"line\">quick max_allowed_packet = 32M</span><br><span class=\"line\">[mysql]</span><br><span class=\"line\">no-auto-rehash</span><br><span class=\"line\">default-character-set=utf8</span><br><span class=\"line\">safe-updates</span><br><span class=\"line\">[myisamchk]</span><br><span class=\"line\">key_buffer = 16M</span><br><span class=\"line\">sort_buffer_size = 16M</span><br><span class=\"line\">read_buffer = 8M</span><br><span class=\"line\">write_buffer = 8M</span><br><span class=\"line\">[mysqlhotcopy]</span><br><span class=\"line\">interactive-timeout</span><br><span class=\"line\">[mysqld_safe]</span><br><span class=\"line\">open-files-limit = 8192</span><br><span class=\"line\">[client]</span><br><span class=\"line\">port = 3306</span><br><span class=\"line\">socket = /usr/local/mysql/mysqld/mysql.sock</span><br><span class=\"line\">default-character-set = utf8</span><br></pre></td></tr></table></figure>\n<h1 id=\"创建文件夹\"><a href=\"#创建文件夹\" class=\"headerlink\" title=\"创建文件夹\"></a>创建文件夹</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mkdir -p /usr/local/mysql/data</span><br><span class=\"line\">$ chown -R mysql:mysql /usr/local/mysql/data</span><br><span class=\"line\">$ chmod -R 755 /usr/local/mysql/data $ mkdir -p /usr/local/mysql/mysqld</span><br><span class=\"line\">$ chown -R mysql:mysql /usr/local/mysql/mysqld</span><br><span class=\"line\">$ chmod -R 755 /usr/local/mysql/mysqld</span><br></pre></td></tr></table></figure>\n<h1 id=\"初始化数据库\"><a href=\"#初始化数据库\" class=\"headerlink\" title=\"初始化数据库\"></a>初始化数据库</h1><p>进入到/usr/local/mysql/bin 下执行以下命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ./mysqld --user=mysql --basedir=/usr/local/mysql--datadir=/usr/local/mysql/data --initialize</span><br></pre></td></tr></table></figure>\n<p>执行结束后会有一个临时密码记入下来<br>A temporary password is generated for root@localhost: dsuIeduSe5&gt;E</p>\n<p>方便等下登录 比如 dsuIeduSe5 就是我的临时密码</p>\n<h1 id=\"创建软链接并配置环境变量\"><a href=\"#创建软链接并配置环境变量\" class=\"headerlink\" title=\"创建软链接并配置环境变量\"></a>创建软链接并配置环境变量</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> $ln -fs /usr/local/mysql/bin/mysql</span><br><span class=\"line\">/usr/local/bin/mysql $ cp /usr/local/mysql/support-files/mysql.server</span><br><span class=\"line\">/etc/init.d/mysqld</span><br></pre></td></tr></table></figure>\n<p>打开 vim /etc/profile 文件填入以下内容：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MYSQL_HOME= /usr/local/mysq/bin PATH=$MYSQL_HOME/bin:$PATH export</span><br><span class=\"line\">MYSQL_HOME</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"启用Mysql\"><a href=\"#启用Mysql\" class=\"headerlink\" title=\"启用Mysql\"></a>启用Mysql</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/etc/init.d/mysqld start 或 service mysql start</span><br></pre></td></tr></table></figure>\n<h1 id=\"登录mysql\"><a href=\"#登录mysql\" class=\"headerlink\" title=\"登录mysql\"></a>登录mysql</h1><pre><code>mysql -uroot -p  回车\n\n输入上述的临时密码\n\n登入成功后出现以下内容则表示成功：\n</code></pre><p>   <img src=\"https://img.mupaie.com/mysql.png\" alt=\"useradd命令\"></p>\n<h1 id=\"安装过程下如果出现以下问题\"><a href=\"#安装过程下如果出现以下问题\" class=\"headerlink\" title=\"安装过程下如果出现以下问题\"></a>安装过程下如果出现以下问题</h1><ul>\n<li><p>问题1：<br>启动 mysql 的时候出现<br>Can’t connect to local MySQL server through socket ‘/var/lib/mysql/mysql.sock’<br>解决方法：查看mysql.sock目录mysql用户是否有权限访问，如果没有权限则赋权</p>\n</li>\n<li><p>问题2：<br>启动 mysql 的时候出现<br>Starting MySQL…[ERROR] The server quit without updating PID file (/usr/local/mysql/data/mysqld.pid).<br>解决：</p>\n</li>\n</ul>\n<ol>\n<li>查看该目录是否有权限</li>\n<li>查看 mysqld进程是否存在</li>\n<li>去mysql的数据目录/data看看，如果存在mysql-bin.index，就赶快把它删除掉吧，它就是罪魁祸首了</li>\n<li>[mysqld]下指定数据目录(datadir) /usr/local/mysql/data </li>\n</ol>\n<ul>\n<li>问题3：</li>\n</ul>\n<ol start=\"5\">\n<li>忘记临时密码<br>上述执行mysqld命令会生成对应的日志文件，目录/var/log/mysqld.log 执行 grep<br>‘temporary password’ /var/log/mysqld.log 查看临时密码<br>如果日志中查不到密码使用以下方法： 进入/usr/local/mysql/bin<br>目录，操作前先关闭mysql服务 执行 mysqld_safe –skip-grant-tables<br>–user=mysql &amp;</li>\n</ol>\n<p>执行 mysql 命令 进入mysql<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">use mysql; update user set authentication_string=password(&quot;新密码&quot;) where user=&apos;root&apos;;</span><br></pre></td></tr></table></figure></p>\n<p>执行这段sql可能会出现以下错误：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Error Code: 1175. You are using safe update mode and you tried to</span><br><span class=\"line\">update a table without a WHERE that uses a KEY column To disable safe</span><br><span class=\"line\">mode, toggle the option in Preferences -&gt; SQL Queries and reconnect.</span><br></pre></td></tr></table></figure></p>\n<p>由于安全模式下更新语句条件必须是主键 关闭安全模式：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SET SQL_SAFE_UPDATES = 0;</span><br></pre></td></tr></table></figure></p>\n<p>修改下数据库模式 继续执行上述sql</p>\n<ul>\n<li>问题4： 远程访问数据库 update user set host = ‘%’ where user=’root’;<br>让root用户可以远程登录，但是这样做有风险不建议使用</li>\n</ul>\n<p>参考文档:</p>\n<p><a href=\"https://www.jianshu.com/p/82790b6b4e08\" target=\"_blank\" rel=\"noopener\">安装：MySQL mysql-5.7.19-linux-glibc2.12-x86_64.tar.gz</a></p>\n<p><a href=\"https://www.cnblogs.com/xuancaoyy/p/5814658.html\" target=\"_blank\" rel=\"noopener\">【MySQL笔记】解除输入的安全模式</a></p>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ck8mkcttq00004osxqgnfq3da","tag_id":"ck8mkcttx00034osxbs8awf2y","_id":"ck8mkctu300084osx7i9qa62r"},{"post_id":"ck8mkcttv00024osx32wfm9v4","tag_id":"ck8mkcttx00034osxbs8awf2y","_id":"ck8mkctu6000c4osxszaz8b6u"},{"post_id":"ck8mkcttz00044osx3l9fw33g","tag_id":"ck8mkctu6000b4osx4pqim812","_id":"ck8mkctug000k4osxnnuoey0e"},{"post_id":"ck8mkcttz00044osx3l9fw33g","tag_id":"ck8mkctub000f4osxee8s2xoj","_id":"ck8mkctuh000m4osxo124uh5t"},{"post_id":"ck8mkctu000054osxam7epwq9","tag_id":"ck8mkcttx00034osxbs8awf2y","_id":"ck8mkctuj000p4osx6ompdigc"},{"post_id":"ck8mkctu000054osxam7epwq9","tag_id":"ck8mkctue000i4osxbkqn3qoj","_id":"ck8mkctuk000r4osxt303r5s0"},{"post_id":"ck8mkctum000u4osx7pi9g7by","tag_id":"ck8mkcttx00034osxbs8awf2y","_id":"ck8mkctuo000x4osx5eaegdca"},{"post_id":"ck8mkctu5000a4osxbkje9g54","tag_id":"ck8mkctuh000n4osxxsb8oljb","_id":"ck8mkctuq000z4osxinbl96bp"},{"post_id":"ck8mkctu5000a4osxbkje9g54","tag_id":"ck8mkctul000t4osx0zwzl392","_id":"ck8mkctut00124osxclzzmoy1"},{"post_id":"ck8mkctu7000d4osx99yl6bdt","tag_id":"ck8mkctuo000w4osxn3gp4615","_id":"ck8mkctuv00144osxcixvwzxn"},{"post_id":"ck8mkctu8000e4osx72vr3jfp","tag_id":"ck8mkctut00114osxzrrbf8b3","_id":"ck8mkctv0001b4osxh5u4ptks"},{"post_id":"ck8mkctu8000e4osx72vr3jfp","tag_id":"ck8mkctuh000n4osxxsb8oljb","_id":"ck8mkctv2001d4osxvn6m439q"},{"post_id":"ck8mkctub000g4osxogiqqu65","tag_id":"ck8mkctuz00194osxiz6kzfw6","_id":"ck8mkctv4001h4osxfjtdfac5"},{"post_id":"ck8mkctub000g4osxogiqqu65","tag_id":"ck8mkctv3001f4osxtq3c3i3k","_id":"ck8mkctv4001i4osx2qv1mhqe"},{"post_id":"ck8mkctuc000h4osx0jq5j09i","tag_id":"ck8mkctv3001g4osxa0zcasmt","_id":"ck8mkctv5001l4osxqzyddwrj"},{"post_id":"ck8mkctuc000h4osx0jq5j09i","tag_id":"ck8mkctv4001j4osxde1cvz64","_id":"ck8mkctv5001m4osxevl2llow"},{"post_id":"ck8mkctuf000j4osxx6otzbl8","tag_id":"ck8mkcttx00034osxbs8awf2y","_id":"ck8mkctv6001o4osx32n38owo"},{"post_id":"ck8mkctuf000j4osxx6otzbl8","tag_id":"ck8mkctv4001k4osxd9q7ytyp","_id":"ck8mkctv6001p4osxw108sonw"},{"post_id":"ck8mkctug000l4osx1ethd54x","tag_id":"ck8mkctv5001n4osx40eo5nkj","_id":"ck8mkctv7001t4osxyyylxdpe"},{"post_id":"ck8mkctug000l4osx1ethd54x","tag_id":"ck8mkctv6001q4osx2u00wp6r","_id":"ck8mkctv7001u4osxyfnqr2sm"},{"post_id":"ck8mkctug000l4osx1ethd54x","tag_id":"ck8mkctv6001r4osxeqksd1av","_id":"ck8mkctv8001w4osxyox5b97j"},{"post_id":"ck8mkctun000v4osx3d5xssp3","tag_id":"ck8mkctv7001s4osx0dwtoawi","_id":"ck8mkctv8001x4osx9tnywrnx"},{"post_id":"ck8mkctuo000y4osxe3ttfkt1","tag_id":"ck8mkctv8001v4osx42lhq4u1","_id":"ck8mkctv9001z4osxs3o7amqf"},{"post_id":"ck8mkctuq00104osxlsnw1z47","tag_id":"ck8mkctv8001v4osx42lhq4u1","_id":"ck8mkctv900214osxekaf6udb"},{"post_id":"ck8mkctuu00134osx890c50k2","tag_id":"ck8mkctv900204osx3kqxpg7w","_id":"ck8mkctva00244osxa8rjfphc"},{"post_id":"ck8mkctuu00134osx890c50k2","tag_id":"ck8mkctva00224osxwzn4ian6","_id":"ck8mkctvb00254osxrp22s5rf"},{"post_id":"ck8mkctux00174osxpxx51gmc","tag_id":"ck8mkctva00234osxiv2xgmho","_id":"ck8mkctvb00274osxg11g8c2k"},{"post_id":"ck8mkctuy00184osxij0d9u1v","tag_id":"ck8mkctvb00264osxuq3jmeg9","_id":"ck8mkctvc00294osx6hyyup7u"},{"post_id":"ck8mkctuz001a4osx6gqifuid","tag_id":"ck8mkctv6001q4osx2u00wp6r","_id":"ck8mkctvd002b4osxdh70mkm9"},{"post_id":"ck8mkctv1001c4osxi3zkuqic","tag_id":"ck8mkctvc002a4osxkygkr9m6","_id":"ck8mkctvd002d4osxbnrr4w2z"},{"post_id":"ck8mkctv1001c4osxi3zkuqic","tag_id":"ck8mkctvd002c4osxw31714u4","_id":"ck8mkctve002e4osxfgsspmth"},{"post_id":"ck8mkctvi002i4osxy9eqmok6","tag_id":"ck8mkctvk002k4osx08cyia8i","_id":"ck8mkctvl002m4osxx943kr76"},{"post_id":"ck8mkctvj002j4osxs0fxm663","tag_id":"ck8mkctvk002l4osxbqzeyb2e","_id":"ck8mkctvl002n4osxmn685rsz"},{"post_id":"ck8mkctvm002o4osxo5kora9p","tag_id":"ck8mkctvn002p4osxzeuhfc04","_id":"ck8mkctvn002q4osx7evd0ad5"}],"Tag":[{"name":"JAVA","_id":"ck8mkcttx00034osxbs8awf2y"},{"name":"java","_id":"ck8mkctu6000b4osx4pqim812"},{"name":"动态代理","_id":"ck8mkctub000f4osxee8s2xoj"},{"name":"Lambda 表达式","_id":"ck8mkctue000i4osxbkqn3qoj"},{"name":"http","_id":"ck8mkctuh000n4osxxsb8oljb"},{"name":"网络安全","_id":"ck8mkctul000t4osx0zwzl392"},{"name":"dubbo","_id":"ck8mkctuo000w4osxn3gp4615"},{"name":"markdown","_id":"ck8mkctut00114osxzrrbf8b3"},{"name":"springMvc","_id":"ck8mkctuz00194osxiz6kzfw6"},{"name":"字符编码","_id":"ck8mkctv3001f4osxtq3c3i3k"},{"name":"JavaScript","_id":"ck8mkctv3001g4osxa0zcasmt"},{"name":"浏览器兼容性","_id":"ck8mkctv4001j4osxde1cvz64"},{"name":"反射机制","_id":"ck8mkctv4001k4osxd9q7ytyp"},{"name":"github","_id":"ck8mkctv5001n4osx40eo5nkj"},{"name":"linux","_id":"ck8mkctv6001q4osx2u00wp6r"},{"name":"CentOS","_id":"ck8mkctv6001r4osxeqksd1av"},{"name":"mybatis","_id":"ck8mkctv7001s4osx0dwtoawi"},{"name":"spring","_id":"ck8mkctv8001v4osx42lhq4u1"},{"name":"多线程","_id":"ck8mkctv900204osx3kqxpg7w"},{"name":"并发","_id":"ck8mkctva00224osxwzn4ian6"},{"name":"HTML","_id":"ck8mkctva00234osxiv2xgmho"},{"name":"JVM","_id":"ck8mkctvb00264osxuq3jmeg9"},{"name":"硬件","_id":"ck8mkctvc002a4osxkygkr9m6"},{"name":"内存","_id":"ck8mkctvd002c4osxw31714u4"},{"name":"JAVA 8","_id":"ck8mkctvk002k4osx08cyia8i"},{"name":"工具","_id":"ck8mkctvk002l4osxbqzeyb2e"},{"name":"mysql","_id":"ck8mkctvn002p4osxzeuhfc04"}]}}